// Code generated by counterfeiter. DO NOT EDIT.
package fakes

import (
	"sync"

	"github.com/IBM/ibmcloud-volume-file-vpc/common/vpcclient/models"
	"github.com/IBM/ibmcloud-volume-file-vpc/common/vpcclient/vpcfilevolume"
	"go.uber.org/zap"
)

type SnapshotService struct {
	CreateSnapshotStub        func(string, *models.Snapshot, *zap.Logger) (*models.Snapshot, error)
	createSnapshotMutex       sync.RWMutex
	createSnapshotArgsForCall []struct {
		arg1 string
		arg2 *models.Snapshot
		arg3 *zap.Logger
	}
	createSnapshotReturns struct {
		result1 *models.Snapshot
		result2 error
	}
	createSnapshotReturnsOnCall map[int]struct {
		result1 *models.Snapshot
		result2 error
	}
	DeleteSnapshotStub        func(string, string, *zap.Logger) error
	deleteSnapshotMutex       sync.RWMutex
	deleteSnapshotArgsForCall []struct {
		arg1 string
		arg2 string
		arg3 *zap.Logger
	}
	deleteSnapshotReturns struct {
		result1 error
	}
	deleteSnapshotReturnsOnCall map[int]struct {
		result1 error
	}
	GetSnapshotStub        func(string, string, *zap.Logger) (*models.Snapshot, error)
	getSnapshotMutex       sync.RWMutex
	getSnapshotArgsForCall []struct {
		arg1 string
		arg2 string
		arg3 *zap.Logger
	}
	getSnapshotReturns struct {
		result1 *models.Snapshot
		result2 error
	}
	getSnapshotReturnsOnCall map[int]struct {
		result1 *models.Snapshot
		result2 error
	}
	GetSnapshotByNameStub        func(string, string, *zap.Logger) (*models.Snapshot, error)
	getSnapshotByNameMutex       sync.RWMutex
	getSnapshotByNameArgsForCall []struct {
		arg1 string
		arg2 string
		arg3 *zap.Logger
	}
	getSnapshotByNameReturns struct {
		result1 *models.Snapshot
		result2 error
	}
	getSnapshotByNameReturnsOnCall map[int]struct {
		result1 *models.Snapshot
		result2 error
	}
	ListSnapshotsStub        func(string, int, string, *models.LisSnapshotFilters, *zap.Logger) (*models.SnapshotList, error)
	listSnapshotsMutex       sync.RWMutex
	listSnapshotsArgsForCall []struct {
		arg1 string
		arg2 int
		arg3 string
		arg4 *models.LisSnapshotFilters
		arg5 *zap.Logger
	}
	listSnapshotsReturns struct {
		result1 *models.SnapshotList
		result2 error
	}
	listSnapshotsReturnsOnCall map[int]struct {
		result1 *models.SnapshotList
		result2 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *SnapshotService) CreateSnapshot(arg1 string, arg2 *models.Snapshot, arg3 *zap.Logger) (*models.Snapshot, error) {
	fake.createSnapshotMutex.Lock()
	ret, specificReturn := fake.createSnapshotReturnsOnCall[len(fake.createSnapshotArgsForCall)]
	fake.createSnapshotArgsForCall = append(fake.createSnapshotArgsForCall, struct {
		arg1 string
		arg2 *models.Snapshot
		arg3 *zap.Logger
	}{arg1, arg2, arg3})
	stub := fake.CreateSnapshotStub
	fakeReturns := fake.createSnapshotReturns
	fake.recordInvocation("CreateSnapshot", []interface{}{arg1, arg2, arg3})
	fake.createSnapshotMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *SnapshotService) CreateSnapshotCallCount() int {
	fake.createSnapshotMutex.RLock()
	defer fake.createSnapshotMutex.RUnlock()
	return len(fake.createSnapshotArgsForCall)
}

func (fake *SnapshotService) CreateSnapshotCalls(stub func(string, *models.Snapshot, *zap.Logger) (*models.Snapshot, error)) {
	fake.createSnapshotMutex.Lock()
	defer fake.createSnapshotMutex.Unlock()
	fake.CreateSnapshotStub = stub
}

func (fake *SnapshotService) CreateSnapshotArgsForCall(i int) (string, *models.Snapshot, *zap.Logger) {
	fake.createSnapshotMutex.RLock()
	defer fake.createSnapshotMutex.RUnlock()
	argsForCall := fake.createSnapshotArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *SnapshotService) CreateSnapshotReturns(result1 *models.Snapshot, result2 error) {
	fake.createSnapshotMutex.Lock()
	defer fake.createSnapshotMutex.Unlock()
	fake.CreateSnapshotStub = nil
	fake.createSnapshotReturns = struct {
		result1 *models.Snapshot
		result2 error
	}{result1, result2}
}

func (fake *SnapshotService) CreateSnapshotReturnsOnCall(i int, result1 *models.Snapshot, result2 error) {
	fake.createSnapshotMutex.Lock()
	defer fake.createSnapshotMutex.Unlock()
	fake.CreateSnapshotStub = nil
	if fake.createSnapshotReturnsOnCall == nil {
		fake.createSnapshotReturnsOnCall = make(map[int]struct {
			result1 *models.Snapshot
			result2 error
		})
	}
	fake.createSnapshotReturnsOnCall[i] = struct {
		result1 *models.Snapshot
		result2 error
	}{result1, result2}
}

func (fake *SnapshotService) DeleteSnapshot(arg1 string, arg2 string, arg3 *zap.Logger) error {
	fake.deleteSnapshotMutex.Lock()
	ret, specificReturn := fake.deleteSnapshotReturnsOnCall[len(fake.deleteSnapshotArgsForCall)]
	fake.deleteSnapshotArgsForCall = append(fake.deleteSnapshotArgsForCall, struct {
		arg1 string
		arg2 string
		arg3 *zap.Logger
	}{arg1, arg2, arg3})
	stub := fake.DeleteSnapshotStub
	fakeReturns := fake.deleteSnapshotReturns
	fake.recordInvocation("DeleteSnapshot", []interface{}{arg1, arg2, arg3})
	fake.deleteSnapshotMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *SnapshotService) DeleteSnapshotCallCount() int {
	fake.deleteSnapshotMutex.RLock()
	defer fake.deleteSnapshotMutex.RUnlock()
	return len(fake.deleteSnapshotArgsForCall)
}

func (fake *SnapshotService) DeleteSnapshotCalls(stub func(string, string, *zap.Logger) error) {
	fake.deleteSnapshotMutex.Lock()
	defer fake.deleteSnapshotMutex.Unlock()
	fake.DeleteSnapshotStub = stub
}

func (fake *SnapshotService) DeleteSnapshotArgsForCall(i int) (string, string, *zap.Logger) {
	fake.deleteSnapshotMutex.RLock()
	defer fake.deleteSnapshotMutex.RUnlock()
	argsForCall := fake.deleteSnapshotArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *SnapshotService) DeleteSnapshotReturns(result1 error) {
	fake.deleteSnapshotMutex.Lock()
	defer fake.deleteSnapshotMutex.Unlock()
	fake.DeleteSnapshotStub = nil
	fake.deleteSnapshotReturns = struct {
		result1 error
	}{result1}
}

func (fake *SnapshotService) DeleteSnapshotReturnsOnCall(i int, result1 error) {
	fake.deleteSnapshotMutex.Lock()
	defer fake.deleteSnapshotMutex.Unlock()
	fake.DeleteSnapshotStub = nil
	if fake.deleteSnapshotReturnsOnCall == nil {
		fake.deleteSnapshotReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.deleteSnapshotReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *SnapshotService) GetSnapshot(arg1 string, arg2 string, arg3 *zap.Logger) (*models.Snapshot, error) {
	fake.getSnapshotMutex.Lock()
	ret, specificReturn := fake.getSnapshotReturnsOnCall[len(fake.getSnapshotArgsForCall)]
	fake.getSnapshotArgsForCall = append(fake.getSnapshotArgsForCall, struct {
		arg1 string
		arg2 string
		arg3 *zap.Logger
	}{arg1, arg2, arg3})
	stub := fake.GetSnapshotStub
	fakeReturns := fake.getSnapshotReturns
	fake.recordInvocation("GetSnapshot", []interface{}{arg1, arg2, arg3})
	fake.getSnapshotMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *SnapshotService) GetSnapshotCallCount() int {
	fake.getSnapshotMutex.RLock()
	defer fake.getSnapshotMutex.RUnlock()
	return len(fake.getSnapshotArgsForCall)
}

func (fake *SnapshotService) GetSnapshotCalls(stub func(string, string, *zap.Logger) (*models.Snapshot, error)) {
	fake.getSnapshotMutex.Lock()
	defer fake.getSnapshotMutex.Unlock()
	fake.GetSnapshotStub = stub
}

func (fake *SnapshotService) GetSnapshotArgsForCall(i int) (string, string, *zap.Logger) {
	fake.getSnapshotMutex.RLock()
	defer fake.getSnapshotMutex.RUnlock()
	argsForCall := fake.getSnapshotArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *SnapshotService) GetSnapshotReturns(result1 *models.Snapshot, result2 error) {
	fake.getSnapshotMutex.Lock()
	defer fake.getSnapshotMutex.Unlock()
	fake.GetSnapshotStub = nil
	fake.getSnapshotReturns = struct {
		result1 *models.Snapshot
		result2 error
	}{result1, result2}
}

func (fake *SnapshotService) GetSnapshotReturnsOnCall(i int, result1 *models.Snapshot, result2 error) {
	fake.getSnapshotMutex.Lock()
	defer fake.getSnapshotMutex.Unlock()
	fake.GetSnapshotStub = nil
	if fake.getSnapshotReturnsOnCall == nil {
		fake.getSnapshotReturnsOnCall = make(map[int]struct {
			result1 *models.Snapshot
			result2 error
		})
	}
	fake.getSnapshotReturnsOnCall[i] = struct {
		result1 *models.Snapshot
		result2 error
	}{result1, result2}
}

func (fake *SnapshotService) GetSnapshotByName(arg1 string, arg2 string, arg3 *zap.Logger) (*models.Snapshot, error) {
	fake.getSnapshotByNameMutex.Lock()
	ret, specificReturn := fake.getSnapshotByNameReturnsOnCall[len(fake.getSnapshotByNameArgsForCall)]
	fake.getSnapshotByNameArgsForCall = append(fake.getSnapshotByNameArgsForCall, struct {
		arg1 string
		arg2 string
		arg3 *zap.Logger
	}{arg1, arg2, arg3})
	stub := fake.GetSnapshotByNameStub
	fakeReturns := fake.getSnapshotByNameReturns
	fake.recordInvocation("GetSnapshotByName", []interface{}{arg1, arg2, arg3})
	fake.getSnapshotByNameMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *SnapshotService) GetSnapshotByNameCallCount() int {
	fake.getSnapshotByNameMutex.RLock()
	defer fake.getSnapshotByNameMutex.RUnlock()
	return len(fake.getSnapshotByNameArgsForCall)
}

func (fake *SnapshotService) GetSnapshotByNameCalls(stub func(string, string, *zap.Logger) (*models.Snapshot, error)) {
	fake.getSnapshotByNameMutex.Lock()
	defer fake.getSnapshotByNameMutex.Unlock()
	fake.GetSnapshotByNameStub = stub
}

func (fake *SnapshotService) GetSnapshotByNameArgsForCall(i int) (string, string, *zap.Logger) {
	fake.getSnapshotByNameMutex.RLock()
	defer fake.getSnapshotByNameMutex.RUnlock()
	argsForCall := fake.getSnapshotByNameArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *SnapshotService) GetSnapshotByNameReturns(result1 *models.Snapshot, result2 error) {
	fake.getSnapshotByNameMutex.Lock()
	defer fake.getSnapshotByNameMutex.Unlock()
	fake.GetSnapshotByNameStub = nil
	fake.getSnapshotByNameReturns = struct {
		result1 *models.Snapshot
		result2 error
	}{result1, result2}
}

func (fake *SnapshotService) GetSnapshotByNameReturnsOnCall(i int, result1 *models.Snapshot, result2 error) {
	fake.getSnapshotByNameMutex.Lock()
	defer fake.getSnapshotByNameMutex.Unlock()
	fake.GetSnapshotByNameStub = nil
	if fake.getSnapshotByNameReturnsOnCall == nil {
		fake.getSnapshotByNameReturnsOnCall = make(map[int]struct {
			result1 *models.Snapshot
			result2 error
		})
	}
	fake.getSnapshotByNameReturnsOnCall[i] = struct {
		result1 *models.Snapshot
		result2 error
	}{result1, result2}
}

func (fake *SnapshotService) ListSnapshots(arg1 string, arg2 int, arg3 string, arg4 *models.LisSnapshotFilters, arg5 *zap.Logger) (*models.SnapshotList, error) {
	fake.listSnapshotsMutex.Lock()
	ret, specificReturn := fake.listSnapshotsReturnsOnCall[len(fake.listSnapshotsArgsForCall)]
	fake.listSnapshotsArgsForCall = append(fake.listSnapshotsArgsForCall, struct {
		arg1 string
		arg2 int
		arg3 string
		arg4 *models.LisSnapshotFilters
		arg5 *zap.Logger
	}{arg1, arg2, arg3, arg4, arg5})
	stub := fake.ListSnapshotsStub
	fakeReturns := fake.listSnapshotsReturns
	fake.recordInvocation("ListSnapshots", []interface{}{arg1, arg2, arg3, arg4, arg5})
	fake.listSnapshotsMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4, arg5)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *SnapshotService) ListSnapshotsCallCount() int {
	fake.listSnapshotsMutex.RLock()
	defer fake.listSnapshotsMutex.RUnlock()
	return len(fake.listSnapshotsArgsForCall)
}

func (fake *SnapshotService) ListSnapshotsCalls(stub func(string, int, string, *models.LisSnapshotFilters, *zap.Logger) (*models.SnapshotList, error)) {
	fake.listSnapshotsMutex.Lock()
	defer fake.listSnapshotsMutex.Unlock()
	fake.ListSnapshotsStub = stub
}

func (fake *SnapshotService) ListSnapshotsArgsForCall(i int) (string, int, string, *models.LisSnapshotFilters, *zap.Logger) {
	fake.listSnapshotsMutex.RLock()
	defer fake.listSnapshotsMutex.RUnlock()
	argsForCall := fake.listSnapshotsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4, argsForCall.arg5
}

func (fake *SnapshotService) ListSnapshotsReturns(result1 *models.SnapshotList, result2 error) {
	fake.listSnapshotsMutex.Lock()
	defer fake.listSnapshotsMutex.Unlock()
	fake.ListSnapshotsStub = nil
	fake.listSnapshotsReturns = struct {
		result1 *models.SnapshotList
		result2 error
	}{result1, result2}
}

func (fake *SnapshotService) ListSnapshotsReturnsOnCall(i int, result1 *models.SnapshotList, result2 error) {
	fake.listSnapshotsMutex.Lock()
	defer fake.listSnapshotsMutex.Unlock()
	fake.ListSnapshotsStub = nil
	if fake.listSnapshotsReturnsOnCall == nil {
		fake.listSnapshotsReturnsOnCall = make(map[int]struct {
			result1 *models.SnapshotList
			result2 error
		})
	}
	fake.listSnapshotsReturnsOnCall[i] = struct {
		result1 *models.SnapshotList
		result2 error
	}{result1, result2}
}

func (fake *SnapshotService) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.createSnapshotMutex.RLock()
	defer fake.createSnapshotMutex.RUnlock()
	fake.deleteSnapshotMutex.RLock()
	defer fake.deleteSnapshotMutex.RUnlock()
	fake.getSnapshotMutex.RLock()
	defer fake.getSnapshotMutex.RUnlock()
	fake.getSnapshotByNameMutex.RLock()
	defer fake.getSnapshotByNameMutex.RUnlock()
	fake.listSnapshotsMutex.RLock()
	defer fake.listSnapshotsMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *SnapshotService) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ vpcfilevolume.SnapshotManager = new(SnapshotService)
