// Code generated by counterfeiter. DO NOT EDIT.
package fakes

import (
	"net/http"
	"sync"

	"github.com/IBM/ibmcloud-volume-file-vpc/common/vpcclient/models"
	"github.com/IBM/ibmcloud-volume-file-vpc/common/vpcclient/vpcfilevolume"
	"github.com/IBM/ibmcloud-volume-interface/lib/provider"
	"go.uber.org/zap"
)

type FileShareService struct {
	CreateFileShareStub        func(*models.Share, *zap.Logger) (*models.Share, error)
	createFileShareMutex       sync.RWMutex
	createFileShareArgsForCall []struct {
		arg1 *models.Share
		arg2 *zap.Logger
	}
	createFileShareReturns struct {
		result1 *models.Share
		result2 error
	}
	createFileShareReturnsOnCall map[int]struct {
		result1 *models.Share
		result2 error
	}
	CreateFileShareTargetStub        func(*models.ShareTarget, *zap.Logger) (*models.ShareTarget, error)
	createFileShareTargetMutex       sync.RWMutex
	createFileShareTargetArgsForCall []struct {
		arg1 *models.ShareTarget
		arg2 *zap.Logger
	}
	createFileShareTargetReturns struct {
		result1 *models.ShareTarget
		result2 error
	}
	createFileShareTargetReturnsOnCall map[int]struct {
		result1 *models.ShareTarget
		result2 error
	}
	DeleteFileShareStub        func(string, *zap.Logger) error
	deleteFileShareMutex       sync.RWMutex
	deleteFileShareArgsForCall []struct {
		arg1 string
		arg2 *zap.Logger
	}
	deleteFileShareReturns struct {
		result1 error
	}
	deleteFileShareReturnsOnCall map[int]struct {
		result1 error
	}
	DeleteFileShareTargetStub        func(*models.ShareTarget, *zap.Logger) (*http.Response, error)
	deleteFileShareTargetMutex       sync.RWMutex
	deleteFileShareTargetArgsForCall []struct {
		arg1 *models.ShareTarget
		arg2 *zap.Logger
	}
	deleteFileShareTargetReturns struct {
		result1 *http.Response
		result2 error
	}
	deleteFileShareTargetReturnsOnCall map[int]struct {
		result1 *http.Response
		result2 error
	}
	ExpandVolumeStub        func(string, *models.Share, *zap.Logger) (*models.Share, error)
	expandVolumeMutex       sync.RWMutex
	expandVolumeArgsForCall []struct {
		arg1 string
		arg2 *models.Share
		arg3 *zap.Logger
	}
	expandVolumeReturns struct {
		result1 *models.Share
		result2 error
	}
	expandVolumeReturnsOnCall map[int]struct {
		result1 *models.Share
		result2 error
	}
	GetFileShareStub        func(string, *zap.Logger) (*models.Share, error)
	getFileShareMutex       sync.RWMutex
	getFileShareArgsForCall []struct {
		arg1 string
		arg2 *zap.Logger
	}
	getFileShareReturns struct {
		result1 *models.Share
		result2 error
	}
	getFileShareReturnsOnCall map[int]struct {
		result1 *models.Share
		result2 error
	}
	GetFileShareByNameStub        func(string, *zap.Logger) (*models.Share, error)
	getFileShareByNameMutex       sync.RWMutex
	getFileShareByNameArgsForCall []struct {
		arg1 string
		arg2 *zap.Logger
	}
	getFileShareByNameReturns struct {
		result1 *models.Share
		result2 error
	}
	getFileShareByNameReturnsOnCall map[int]struct {
		result1 *models.Share
		result2 error
	}
	GetFileShareEtagStub        func(string, *zap.Logger) (*models.Share, string, error)
	getFileShareEtagMutex       sync.RWMutex
	getFileShareEtagArgsForCall []struct {
		arg1 string
		arg2 *zap.Logger
	}
	getFileShareEtagReturns struct {
		result1 *models.Share
		result2 string
		result3 error
	}
	getFileShareEtagReturnsOnCall map[int]struct {
		result1 *models.Share
		result2 string
		result3 error
	}
	GetFileShareTargetStub        func(string, string, *zap.Logger) (*models.ShareTarget, error)
	getFileShareTargetMutex       sync.RWMutex
	getFileShareTargetArgsForCall []struct {
		arg1 string
		arg2 string
		arg3 *zap.Logger
	}
	getFileShareTargetReturns struct {
		result1 *models.ShareTarget
		result2 error
	}
	getFileShareTargetReturnsOnCall map[int]struct {
		result1 *models.ShareTarget
		result2 error
	}
	GetFileShareTargetByNameStub        func(string, string, *zap.Logger) (*models.ShareTarget, error)
	getFileShareTargetByNameMutex       sync.RWMutex
	getFileShareTargetByNameArgsForCall []struct {
		arg1 string
		arg2 string
		arg3 *zap.Logger
	}
	getFileShareTargetByNameReturns struct {
		result1 *models.ShareTarget
		result2 error
	}
	getFileShareTargetByNameReturnsOnCall map[int]struct {
		result1 *models.ShareTarget
		result2 error
	}
	ListFileShareTargetsStub        func(string, *models.ListShareTargetFilters, *zap.Logger) (*models.ShareTargetList, error)
	listFileShareTargetsMutex       sync.RWMutex
	listFileShareTargetsArgsForCall []struct {
		arg1 string
		arg2 *models.ListShareTargetFilters
		arg3 *zap.Logger
	}
	listFileShareTargetsReturns struct {
		result1 *models.ShareTargetList
		result2 error
	}
	listFileShareTargetsReturnsOnCall map[int]struct {
		result1 *models.ShareTargetList
		result2 error
	}
	ListFileSharesStub        func(int, string, *models.ListShareFilters, *zap.Logger) (*models.ShareList, error)
	listFileSharesMutex       sync.RWMutex
	listFileSharesArgsForCall []struct {
		arg1 int
		arg2 string
		arg3 *models.ListShareFilters
		arg4 *zap.Logger
	}
	listFileSharesReturns struct {
		result1 *models.ShareList
		result2 error
	}
	listFileSharesReturnsOnCall map[int]struct {
		result1 *models.ShareList
		result2 error
	}
	ListSecurityGroupsStub        func(int, string, *models.ListSecurityGroupFilters, *zap.Logger) (*models.SecurityGroupList, error)
	listSecurityGroupsMutex       sync.RWMutex
	listSecurityGroupsArgsForCall []struct {
		arg1 int
		arg2 string
		arg3 *models.ListSecurityGroupFilters
		arg4 *zap.Logger
	}
	listSecurityGroupsReturns struct {
		result1 *models.SecurityGroupList
		result2 error
	}
	listSecurityGroupsReturnsOnCall map[int]struct {
		result1 *models.SecurityGroupList
		result2 error
	}
	ListSubnetsStub        func(int, string, *models.ListSubnetFilters, *zap.Logger) (*models.SubnetList, error)
	listSubnetsMutex       sync.RWMutex
	listSubnetsArgsForCall []struct {
		arg1 int
		arg2 string
		arg3 *models.ListSubnetFilters
		arg4 *zap.Logger
	}
	listSubnetsReturns struct {
		result1 *models.SubnetList
		result2 error
	}
	listSubnetsReturnsOnCall map[int]struct {
		result1 *models.SubnetList
		result2 error
	}
	SetEnableBetaStub        func(bool, *zap.Logger)
	setEnableBetaMutex       sync.RWMutex
	setEnableBetaArgsForCall []struct {
		arg1 bool
		arg2 *zap.Logger
	}
	UpdateFileShareWithEtagStub        func(string, string, *models.Share, *zap.Logger) error
	updateFileShareWithEtagMutex       sync.RWMutex
	updateFileShareWithEtagArgsForCall []struct {
		arg1 string
		arg2 string
		arg3 *models.Share
		arg4 *zap.Logger
	}
	updateFileShareWithEtagReturns struct {
		result1 error
	}
	updateFileShareWithEtagReturnsOnCall map[int]struct {
		result1 error
	}
	UpdateVolumeStub        func(*provider.UpdatePVC, *zap.Logger) error
	updateVolumeMutex       sync.RWMutex
	updateVolumeArgsForCall []struct {
		arg1 *provider.UpdatePVC
		arg2 *zap.Logger
	}
	updateVolumeReturns struct {
		result1 error
	}
	updateVolumeReturnsOnCall map[int]struct {
		result1 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FileShareService) CreateFileShare(arg1 *models.Share, arg2 *zap.Logger) (*models.Share, error) {
	fake.createFileShareMutex.Lock()
	ret, specificReturn := fake.createFileShareReturnsOnCall[len(fake.createFileShareArgsForCall)]
	fake.createFileShareArgsForCall = append(fake.createFileShareArgsForCall, struct {
		arg1 *models.Share
		arg2 *zap.Logger
	}{arg1, arg2})
	stub := fake.CreateFileShareStub
	fakeReturns := fake.createFileShareReturns
	fake.recordInvocation("CreateFileShare", []interface{}{arg1, arg2})
	fake.createFileShareMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FileShareService) CreateFileShareCallCount() int {
	fake.createFileShareMutex.RLock()
	defer fake.createFileShareMutex.RUnlock()
	return len(fake.createFileShareArgsForCall)
}

func (fake *FileShareService) CreateFileShareCalls(stub func(*models.Share, *zap.Logger) (*models.Share, error)) {
	fake.createFileShareMutex.Lock()
	defer fake.createFileShareMutex.Unlock()
	fake.CreateFileShareStub = stub
}

func (fake *FileShareService) CreateFileShareArgsForCall(i int) (*models.Share, *zap.Logger) {
	fake.createFileShareMutex.RLock()
	defer fake.createFileShareMutex.RUnlock()
	argsForCall := fake.createFileShareArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FileShareService) CreateFileShareReturns(result1 *models.Share, result2 error) {
	fake.createFileShareMutex.Lock()
	defer fake.createFileShareMutex.Unlock()
	fake.CreateFileShareStub = nil
	fake.createFileShareReturns = struct {
		result1 *models.Share
		result2 error
	}{result1, result2}
}

func (fake *FileShareService) CreateFileShareReturnsOnCall(i int, result1 *models.Share, result2 error) {
	fake.createFileShareMutex.Lock()
	defer fake.createFileShareMutex.Unlock()
	fake.CreateFileShareStub = nil
	if fake.createFileShareReturnsOnCall == nil {
		fake.createFileShareReturnsOnCall = make(map[int]struct {
			result1 *models.Share
			result2 error
		})
	}
	fake.createFileShareReturnsOnCall[i] = struct {
		result1 *models.Share
		result2 error
	}{result1, result2}
}

func (fake *FileShareService) CreateFileShareTarget(arg1 *models.ShareTarget, arg2 *zap.Logger) (*models.ShareTarget, error) {
	fake.createFileShareTargetMutex.Lock()
	ret, specificReturn := fake.createFileShareTargetReturnsOnCall[len(fake.createFileShareTargetArgsForCall)]
	fake.createFileShareTargetArgsForCall = append(fake.createFileShareTargetArgsForCall, struct {
		arg1 *models.ShareTarget
		arg2 *zap.Logger
	}{arg1, arg2})
	stub := fake.CreateFileShareTargetStub
	fakeReturns := fake.createFileShareTargetReturns
	fake.recordInvocation("CreateFileShareTarget", []interface{}{arg1, arg2})
	fake.createFileShareTargetMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FileShareService) CreateFileShareTargetCallCount() int {
	fake.createFileShareTargetMutex.RLock()
	defer fake.createFileShareTargetMutex.RUnlock()
	return len(fake.createFileShareTargetArgsForCall)
}

func (fake *FileShareService) CreateFileShareTargetCalls(stub func(*models.ShareTarget, *zap.Logger) (*models.ShareTarget, error)) {
	fake.createFileShareTargetMutex.Lock()
	defer fake.createFileShareTargetMutex.Unlock()
	fake.CreateFileShareTargetStub = stub
}

func (fake *FileShareService) CreateFileShareTargetArgsForCall(i int) (*models.ShareTarget, *zap.Logger) {
	fake.createFileShareTargetMutex.RLock()
	defer fake.createFileShareTargetMutex.RUnlock()
	argsForCall := fake.createFileShareTargetArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FileShareService) CreateFileShareTargetReturns(result1 *models.ShareTarget, result2 error) {
	fake.createFileShareTargetMutex.Lock()
	defer fake.createFileShareTargetMutex.Unlock()
	fake.CreateFileShareTargetStub = nil
	fake.createFileShareTargetReturns = struct {
		result1 *models.ShareTarget
		result2 error
	}{result1, result2}
}

func (fake *FileShareService) CreateFileShareTargetReturnsOnCall(i int, result1 *models.ShareTarget, result2 error) {
	fake.createFileShareTargetMutex.Lock()
	defer fake.createFileShareTargetMutex.Unlock()
	fake.CreateFileShareTargetStub = nil
	if fake.createFileShareTargetReturnsOnCall == nil {
		fake.createFileShareTargetReturnsOnCall = make(map[int]struct {
			result1 *models.ShareTarget
			result2 error
		})
	}
	fake.createFileShareTargetReturnsOnCall[i] = struct {
		result1 *models.ShareTarget
		result2 error
	}{result1, result2}
}

func (fake *FileShareService) DeleteFileShare(arg1 string, arg2 *zap.Logger) error {
	fake.deleteFileShareMutex.Lock()
	ret, specificReturn := fake.deleteFileShareReturnsOnCall[len(fake.deleteFileShareArgsForCall)]
	fake.deleteFileShareArgsForCall = append(fake.deleteFileShareArgsForCall, struct {
		arg1 string
		arg2 *zap.Logger
	}{arg1, arg2})
	stub := fake.DeleteFileShareStub
	fakeReturns := fake.deleteFileShareReturns
	fake.recordInvocation("DeleteFileShare", []interface{}{arg1, arg2})
	fake.deleteFileShareMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FileShareService) DeleteFileShareCallCount() int {
	fake.deleteFileShareMutex.RLock()
	defer fake.deleteFileShareMutex.RUnlock()
	return len(fake.deleteFileShareArgsForCall)
}

func (fake *FileShareService) DeleteFileShareCalls(stub func(string, *zap.Logger) error) {
	fake.deleteFileShareMutex.Lock()
	defer fake.deleteFileShareMutex.Unlock()
	fake.DeleteFileShareStub = stub
}

func (fake *FileShareService) DeleteFileShareArgsForCall(i int) (string, *zap.Logger) {
	fake.deleteFileShareMutex.RLock()
	defer fake.deleteFileShareMutex.RUnlock()
	argsForCall := fake.deleteFileShareArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FileShareService) DeleteFileShareReturns(result1 error) {
	fake.deleteFileShareMutex.Lock()
	defer fake.deleteFileShareMutex.Unlock()
	fake.DeleteFileShareStub = nil
	fake.deleteFileShareReturns = struct {
		result1 error
	}{result1}
}

func (fake *FileShareService) DeleteFileShareReturnsOnCall(i int, result1 error) {
	fake.deleteFileShareMutex.Lock()
	defer fake.deleteFileShareMutex.Unlock()
	fake.DeleteFileShareStub = nil
	if fake.deleteFileShareReturnsOnCall == nil {
		fake.deleteFileShareReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.deleteFileShareReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FileShareService) DeleteFileShareTarget(arg1 *models.ShareTarget, arg2 *zap.Logger) (*http.Response, error) {
	fake.deleteFileShareTargetMutex.Lock()
	ret, specificReturn := fake.deleteFileShareTargetReturnsOnCall[len(fake.deleteFileShareTargetArgsForCall)]
	fake.deleteFileShareTargetArgsForCall = append(fake.deleteFileShareTargetArgsForCall, struct {
		arg1 *models.ShareTarget
		arg2 *zap.Logger
	}{arg1, arg2})
	stub := fake.DeleteFileShareTargetStub
	fakeReturns := fake.deleteFileShareTargetReturns
	fake.recordInvocation("DeleteFileShareTarget", []interface{}{arg1, arg2})
	fake.deleteFileShareTargetMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FileShareService) DeleteFileShareTargetCallCount() int {
	fake.deleteFileShareTargetMutex.RLock()
	defer fake.deleteFileShareTargetMutex.RUnlock()
	return len(fake.deleteFileShareTargetArgsForCall)
}

func (fake *FileShareService) DeleteFileShareTargetCalls(stub func(*models.ShareTarget, *zap.Logger) (*http.Response, error)) {
	fake.deleteFileShareTargetMutex.Lock()
	defer fake.deleteFileShareTargetMutex.Unlock()
	fake.DeleteFileShareTargetStub = stub
}

func (fake *FileShareService) DeleteFileShareTargetArgsForCall(i int) (*models.ShareTarget, *zap.Logger) {
	fake.deleteFileShareTargetMutex.RLock()
	defer fake.deleteFileShareTargetMutex.RUnlock()
	argsForCall := fake.deleteFileShareTargetArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FileShareService) DeleteFileShareTargetReturns(result1 *http.Response, result2 error) {
	fake.deleteFileShareTargetMutex.Lock()
	defer fake.deleteFileShareTargetMutex.Unlock()
	fake.DeleteFileShareTargetStub = nil
	fake.deleteFileShareTargetReturns = struct {
		result1 *http.Response
		result2 error
	}{result1, result2}
}

func (fake *FileShareService) DeleteFileShareTargetReturnsOnCall(i int, result1 *http.Response, result2 error) {
	fake.deleteFileShareTargetMutex.Lock()
	defer fake.deleteFileShareTargetMutex.Unlock()
	fake.DeleteFileShareTargetStub = nil
	if fake.deleteFileShareTargetReturnsOnCall == nil {
		fake.deleteFileShareTargetReturnsOnCall = make(map[int]struct {
			result1 *http.Response
			result2 error
		})
	}
	fake.deleteFileShareTargetReturnsOnCall[i] = struct {
		result1 *http.Response
		result2 error
	}{result1, result2}
}

func (fake *FileShareService) ExpandVolume(arg1 string, arg2 *models.Share, arg3 *zap.Logger) (*models.Share, error) {
	fake.expandVolumeMutex.Lock()
	ret, specificReturn := fake.expandVolumeReturnsOnCall[len(fake.expandVolumeArgsForCall)]
	fake.expandVolumeArgsForCall = append(fake.expandVolumeArgsForCall, struct {
		arg1 string
		arg2 *models.Share
		arg3 *zap.Logger
	}{arg1, arg2, arg3})
	stub := fake.ExpandVolumeStub
	fakeReturns := fake.expandVolumeReturns
	fake.recordInvocation("ExpandVolume", []interface{}{arg1, arg2, arg3})
	fake.expandVolumeMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FileShareService) ExpandVolumeCallCount() int {
	fake.expandVolumeMutex.RLock()
	defer fake.expandVolumeMutex.RUnlock()
	return len(fake.expandVolumeArgsForCall)
}

func (fake *FileShareService) ExpandVolumeCalls(stub func(string, *models.Share, *zap.Logger) (*models.Share, error)) {
	fake.expandVolumeMutex.Lock()
	defer fake.expandVolumeMutex.Unlock()
	fake.ExpandVolumeStub = stub
}

func (fake *FileShareService) ExpandVolumeArgsForCall(i int) (string, *models.Share, *zap.Logger) {
	fake.expandVolumeMutex.RLock()
	defer fake.expandVolumeMutex.RUnlock()
	argsForCall := fake.expandVolumeArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FileShareService) ExpandVolumeReturns(result1 *models.Share, result2 error) {
	fake.expandVolumeMutex.Lock()
	defer fake.expandVolumeMutex.Unlock()
	fake.ExpandVolumeStub = nil
	fake.expandVolumeReturns = struct {
		result1 *models.Share
		result2 error
	}{result1, result2}
}

func (fake *FileShareService) ExpandVolumeReturnsOnCall(i int, result1 *models.Share, result2 error) {
	fake.expandVolumeMutex.Lock()
	defer fake.expandVolumeMutex.Unlock()
	fake.ExpandVolumeStub = nil
	if fake.expandVolumeReturnsOnCall == nil {
		fake.expandVolumeReturnsOnCall = make(map[int]struct {
			result1 *models.Share
			result2 error
		})
	}
	fake.expandVolumeReturnsOnCall[i] = struct {
		result1 *models.Share
		result2 error
	}{result1, result2}
}

func (fake *FileShareService) GetFileShare(arg1 string, arg2 *zap.Logger) (*models.Share, error) {
	fake.getFileShareMutex.Lock()
	ret, specificReturn := fake.getFileShareReturnsOnCall[len(fake.getFileShareArgsForCall)]
	fake.getFileShareArgsForCall = append(fake.getFileShareArgsForCall, struct {
		arg1 string
		arg2 *zap.Logger
	}{arg1, arg2})
	stub := fake.GetFileShareStub
	fakeReturns := fake.getFileShareReturns
	fake.recordInvocation("GetFileShare", []interface{}{arg1, arg2})
	fake.getFileShareMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FileShareService) GetFileShareCallCount() int {
	fake.getFileShareMutex.RLock()
	defer fake.getFileShareMutex.RUnlock()
	return len(fake.getFileShareArgsForCall)
}

func (fake *FileShareService) GetFileShareCalls(stub func(string, *zap.Logger) (*models.Share, error)) {
	fake.getFileShareMutex.Lock()
	defer fake.getFileShareMutex.Unlock()
	fake.GetFileShareStub = stub
}

func (fake *FileShareService) GetFileShareArgsForCall(i int) (string, *zap.Logger) {
	fake.getFileShareMutex.RLock()
	defer fake.getFileShareMutex.RUnlock()
	argsForCall := fake.getFileShareArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FileShareService) GetFileShareReturns(result1 *models.Share, result2 error) {
	fake.getFileShareMutex.Lock()
	defer fake.getFileShareMutex.Unlock()
	fake.GetFileShareStub = nil
	fake.getFileShareReturns = struct {
		result1 *models.Share
		result2 error
	}{result1, result2}
}

func (fake *FileShareService) GetFileShareReturnsOnCall(i int, result1 *models.Share, result2 error) {
	fake.getFileShareMutex.Lock()
	defer fake.getFileShareMutex.Unlock()
	fake.GetFileShareStub = nil
	if fake.getFileShareReturnsOnCall == nil {
		fake.getFileShareReturnsOnCall = make(map[int]struct {
			result1 *models.Share
			result2 error
		})
	}
	fake.getFileShareReturnsOnCall[i] = struct {
		result1 *models.Share
		result2 error
	}{result1, result2}
}

func (fake *FileShareService) GetFileShareByName(arg1 string, arg2 *zap.Logger) (*models.Share, error) {
	fake.getFileShareByNameMutex.Lock()
	ret, specificReturn := fake.getFileShareByNameReturnsOnCall[len(fake.getFileShareByNameArgsForCall)]
	fake.getFileShareByNameArgsForCall = append(fake.getFileShareByNameArgsForCall, struct {
		arg1 string
		arg2 *zap.Logger
	}{arg1, arg2})
	stub := fake.GetFileShareByNameStub
	fakeReturns := fake.getFileShareByNameReturns
	fake.recordInvocation("GetFileShareByName", []interface{}{arg1, arg2})
	fake.getFileShareByNameMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FileShareService) GetFileShareByNameCallCount() int {
	fake.getFileShareByNameMutex.RLock()
	defer fake.getFileShareByNameMutex.RUnlock()
	return len(fake.getFileShareByNameArgsForCall)
}

func (fake *FileShareService) GetFileShareByNameCalls(stub func(string, *zap.Logger) (*models.Share, error)) {
	fake.getFileShareByNameMutex.Lock()
	defer fake.getFileShareByNameMutex.Unlock()
	fake.GetFileShareByNameStub = stub
}

func (fake *FileShareService) GetFileShareByNameArgsForCall(i int) (string, *zap.Logger) {
	fake.getFileShareByNameMutex.RLock()
	defer fake.getFileShareByNameMutex.RUnlock()
	argsForCall := fake.getFileShareByNameArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FileShareService) GetFileShareByNameReturns(result1 *models.Share, result2 error) {
	fake.getFileShareByNameMutex.Lock()
	defer fake.getFileShareByNameMutex.Unlock()
	fake.GetFileShareByNameStub = nil
	fake.getFileShareByNameReturns = struct {
		result1 *models.Share
		result2 error
	}{result1, result2}
}

func (fake *FileShareService) GetFileShareByNameReturnsOnCall(i int, result1 *models.Share, result2 error) {
	fake.getFileShareByNameMutex.Lock()
	defer fake.getFileShareByNameMutex.Unlock()
	fake.GetFileShareByNameStub = nil
	if fake.getFileShareByNameReturnsOnCall == nil {
		fake.getFileShareByNameReturnsOnCall = make(map[int]struct {
			result1 *models.Share
			result2 error
		})
	}
	fake.getFileShareByNameReturnsOnCall[i] = struct {
		result1 *models.Share
		result2 error
	}{result1, result2}
}

func (fake *FileShareService) GetFileShareEtag(arg1 string, arg2 *zap.Logger) (*models.Share, string, error) {
	fake.getFileShareEtagMutex.Lock()
	ret, specificReturn := fake.getFileShareEtagReturnsOnCall[len(fake.getFileShareEtagArgsForCall)]
	fake.getFileShareEtagArgsForCall = append(fake.getFileShareEtagArgsForCall, struct {
		arg1 string
		arg2 *zap.Logger
	}{arg1, arg2})
	stub := fake.GetFileShareEtagStub
	fakeReturns := fake.getFileShareEtagReturns
	fake.recordInvocation("GetFileShareEtag", []interface{}{arg1, arg2})
	fake.getFileShareEtagMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FileShareService) GetFileShareEtagCallCount() int {
	fake.getFileShareEtagMutex.RLock()
	defer fake.getFileShareEtagMutex.RUnlock()
	return len(fake.getFileShareEtagArgsForCall)
}

func (fake *FileShareService) GetFileShareEtagCalls(stub func(string, *zap.Logger) (*models.Share, string, error)) {
	fake.getFileShareEtagMutex.Lock()
	defer fake.getFileShareEtagMutex.Unlock()
	fake.GetFileShareEtagStub = stub
}

func (fake *FileShareService) GetFileShareEtagArgsForCall(i int) (string, *zap.Logger) {
	fake.getFileShareEtagMutex.RLock()
	defer fake.getFileShareEtagMutex.RUnlock()
	argsForCall := fake.getFileShareEtagArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FileShareService) GetFileShareEtagReturns(result1 *models.Share, result2 string, result3 error) {
	fake.getFileShareEtagMutex.Lock()
	defer fake.getFileShareEtagMutex.Unlock()
	fake.GetFileShareEtagStub = nil
	fake.getFileShareEtagReturns = struct {
		result1 *models.Share
		result2 string
		result3 error
	}{result1, result2, result3}
}

func (fake *FileShareService) GetFileShareEtagReturnsOnCall(i int, result1 *models.Share, result2 string, result3 error) {
	fake.getFileShareEtagMutex.Lock()
	defer fake.getFileShareEtagMutex.Unlock()
	fake.GetFileShareEtagStub = nil
	if fake.getFileShareEtagReturnsOnCall == nil {
		fake.getFileShareEtagReturnsOnCall = make(map[int]struct {
			result1 *models.Share
			result2 string
			result3 error
		})
	}
	fake.getFileShareEtagReturnsOnCall[i] = struct {
		result1 *models.Share
		result2 string
		result3 error
	}{result1, result2, result3}
}

func (fake *FileShareService) GetFileShareTarget(arg1 string, arg2 string, arg3 *zap.Logger) (*models.ShareTarget, error) {
	fake.getFileShareTargetMutex.Lock()
	ret, specificReturn := fake.getFileShareTargetReturnsOnCall[len(fake.getFileShareTargetArgsForCall)]
	fake.getFileShareTargetArgsForCall = append(fake.getFileShareTargetArgsForCall, struct {
		arg1 string
		arg2 string
		arg3 *zap.Logger
	}{arg1, arg2, arg3})
	stub := fake.GetFileShareTargetStub
	fakeReturns := fake.getFileShareTargetReturns
	fake.recordInvocation("GetFileShareTarget", []interface{}{arg1, arg2, arg3})
	fake.getFileShareTargetMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FileShareService) GetFileShareTargetCallCount() int {
	fake.getFileShareTargetMutex.RLock()
	defer fake.getFileShareTargetMutex.RUnlock()
	return len(fake.getFileShareTargetArgsForCall)
}

func (fake *FileShareService) GetFileShareTargetCalls(stub func(string, string, *zap.Logger) (*models.ShareTarget, error)) {
	fake.getFileShareTargetMutex.Lock()
	defer fake.getFileShareTargetMutex.Unlock()
	fake.GetFileShareTargetStub = stub
}

func (fake *FileShareService) GetFileShareTargetArgsForCall(i int) (string, string, *zap.Logger) {
	fake.getFileShareTargetMutex.RLock()
	defer fake.getFileShareTargetMutex.RUnlock()
	argsForCall := fake.getFileShareTargetArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FileShareService) GetFileShareTargetReturns(result1 *models.ShareTarget, result2 error) {
	fake.getFileShareTargetMutex.Lock()
	defer fake.getFileShareTargetMutex.Unlock()
	fake.GetFileShareTargetStub = nil
	fake.getFileShareTargetReturns = struct {
		result1 *models.ShareTarget
		result2 error
	}{result1, result2}
}

func (fake *FileShareService) GetFileShareTargetReturnsOnCall(i int, result1 *models.ShareTarget, result2 error) {
	fake.getFileShareTargetMutex.Lock()
	defer fake.getFileShareTargetMutex.Unlock()
	fake.GetFileShareTargetStub = nil
	if fake.getFileShareTargetReturnsOnCall == nil {
		fake.getFileShareTargetReturnsOnCall = make(map[int]struct {
			result1 *models.ShareTarget
			result2 error
		})
	}
	fake.getFileShareTargetReturnsOnCall[i] = struct {
		result1 *models.ShareTarget
		result2 error
	}{result1, result2}
}

func (fake *FileShareService) GetFileShareTargetByName(arg1 string, arg2 string, arg3 *zap.Logger) (*models.ShareTarget, error) {
	fake.getFileShareTargetByNameMutex.Lock()
	ret, specificReturn := fake.getFileShareTargetByNameReturnsOnCall[len(fake.getFileShareTargetByNameArgsForCall)]
	fake.getFileShareTargetByNameArgsForCall = append(fake.getFileShareTargetByNameArgsForCall, struct {
		arg1 string
		arg2 string
		arg3 *zap.Logger
	}{arg1, arg2, arg3})
	stub := fake.GetFileShareTargetByNameStub
	fakeReturns := fake.getFileShareTargetByNameReturns
	fake.recordInvocation("GetFileShareTargetByName", []interface{}{arg1, arg2, arg3})
	fake.getFileShareTargetByNameMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FileShareService) GetFileShareTargetByNameCallCount() int {
	fake.getFileShareTargetByNameMutex.RLock()
	defer fake.getFileShareTargetByNameMutex.RUnlock()
	return len(fake.getFileShareTargetByNameArgsForCall)
}

func (fake *FileShareService) GetFileShareTargetByNameCalls(stub func(string, string, *zap.Logger) (*models.ShareTarget, error)) {
	fake.getFileShareTargetByNameMutex.Lock()
	defer fake.getFileShareTargetByNameMutex.Unlock()
	fake.GetFileShareTargetByNameStub = stub
}

func (fake *FileShareService) GetFileShareTargetByNameArgsForCall(i int) (string, string, *zap.Logger) {
	fake.getFileShareTargetByNameMutex.RLock()
	defer fake.getFileShareTargetByNameMutex.RUnlock()
	argsForCall := fake.getFileShareTargetByNameArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FileShareService) GetFileShareTargetByNameReturns(result1 *models.ShareTarget, result2 error) {
	fake.getFileShareTargetByNameMutex.Lock()
	defer fake.getFileShareTargetByNameMutex.Unlock()
	fake.GetFileShareTargetByNameStub = nil
	fake.getFileShareTargetByNameReturns = struct {
		result1 *models.ShareTarget
		result2 error
	}{result1, result2}
}

func (fake *FileShareService) GetFileShareTargetByNameReturnsOnCall(i int, result1 *models.ShareTarget, result2 error) {
	fake.getFileShareTargetByNameMutex.Lock()
	defer fake.getFileShareTargetByNameMutex.Unlock()
	fake.GetFileShareTargetByNameStub = nil
	if fake.getFileShareTargetByNameReturnsOnCall == nil {
		fake.getFileShareTargetByNameReturnsOnCall = make(map[int]struct {
			result1 *models.ShareTarget
			result2 error
		})
	}
	fake.getFileShareTargetByNameReturnsOnCall[i] = struct {
		result1 *models.ShareTarget
		result2 error
	}{result1, result2}
}

func (fake *FileShareService) ListFileShareTargets(arg1 string, arg2 *models.ListShareTargetFilters, arg3 *zap.Logger) (*models.ShareTargetList, error) {
	fake.listFileShareTargetsMutex.Lock()
	ret, specificReturn := fake.listFileShareTargetsReturnsOnCall[len(fake.listFileShareTargetsArgsForCall)]
	fake.listFileShareTargetsArgsForCall = append(fake.listFileShareTargetsArgsForCall, struct {
		arg1 string
		arg2 *models.ListShareTargetFilters
		arg3 *zap.Logger
	}{arg1, arg2, arg3})
	stub := fake.ListFileShareTargetsStub
	fakeReturns := fake.listFileShareTargetsReturns
	fake.recordInvocation("ListFileShareTargets", []interface{}{arg1, arg2, arg3})
	fake.listFileShareTargetsMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FileShareService) ListFileShareTargetsCallCount() int {
	fake.listFileShareTargetsMutex.RLock()
	defer fake.listFileShareTargetsMutex.RUnlock()
	return len(fake.listFileShareTargetsArgsForCall)
}

func (fake *FileShareService) ListFileShareTargetsCalls(stub func(string, *models.ListShareTargetFilters, *zap.Logger) (*models.ShareTargetList, error)) {
	fake.listFileShareTargetsMutex.Lock()
	defer fake.listFileShareTargetsMutex.Unlock()
	fake.ListFileShareTargetsStub = stub
}

func (fake *FileShareService) ListFileShareTargetsArgsForCall(i int) (string, *models.ListShareTargetFilters, *zap.Logger) {
	fake.listFileShareTargetsMutex.RLock()
	defer fake.listFileShareTargetsMutex.RUnlock()
	argsForCall := fake.listFileShareTargetsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FileShareService) ListFileShareTargetsReturns(result1 *models.ShareTargetList, result2 error) {
	fake.listFileShareTargetsMutex.Lock()
	defer fake.listFileShareTargetsMutex.Unlock()
	fake.ListFileShareTargetsStub = nil
	fake.listFileShareTargetsReturns = struct {
		result1 *models.ShareTargetList
		result2 error
	}{result1, result2}
}

func (fake *FileShareService) ListFileShareTargetsReturnsOnCall(i int, result1 *models.ShareTargetList, result2 error) {
	fake.listFileShareTargetsMutex.Lock()
	defer fake.listFileShareTargetsMutex.Unlock()
	fake.ListFileShareTargetsStub = nil
	if fake.listFileShareTargetsReturnsOnCall == nil {
		fake.listFileShareTargetsReturnsOnCall = make(map[int]struct {
			result1 *models.ShareTargetList
			result2 error
		})
	}
	fake.listFileShareTargetsReturnsOnCall[i] = struct {
		result1 *models.ShareTargetList
		result2 error
	}{result1, result2}
}

func (fake *FileShareService) ListFileShares(arg1 int, arg2 string, arg3 *models.ListShareFilters, arg4 *zap.Logger) (*models.ShareList, error) {
	fake.listFileSharesMutex.Lock()
	ret, specificReturn := fake.listFileSharesReturnsOnCall[len(fake.listFileSharesArgsForCall)]
	fake.listFileSharesArgsForCall = append(fake.listFileSharesArgsForCall, struct {
		arg1 int
		arg2 string
		arg3 *models.ListShareFilters
		arg4 *zap.Logger
	}{arg1, arg2, arg3, arg4})
	stub := fake.ListFileSharesStub
	fakeReturns := fake.listFileSharesReturns
	fake.recordInvocation("ListFileShares", []interface{}{arg1, arg2, arg3, arg4})
	fake.listFileSharesMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FileShareService) ListFileSharesCallCount() int {
	fake.listFileSharesMutex.RLock()
	defer fake.listFileSharesMutex.RUnlock()
	return len(fake.listFileSharesArgsForCall)
}

func (fake *FileShareService) ListFileSharesCalls(stub func(int, string, *models.ListShareFilters, *zap.Logger) (*models.ShareList, error)) {
	fake.listFileSharesMutex.Lock()
	defer fake.listFileSharesMutex.Unlock()
	fake.ListFileSharesStub = stub
}

func (fake *FileShareService) ListFileSharesArgsForCall(i int) (int, string, *models.ListShareFilters, *zap.Logger) {
	fake.listFileSharesMutex.RLock()
	defer fake.listFileSharesMutex.RUnlock()
	argsForCall := fake.listFileSharesArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FileShareService) ListFileSharesReturns(result1 *models.ShareList, result2 error) {
	fake.listFileSharesMutex.Lock()
	defer fake.listFileSharesMutex.Unlock()
	fake.ListFileSharesStub = nil
	fake.listFileSharesReturns = struct {
		result1 *models.ShareList
		result2 error
	}{result1, result2}
}

func (fake *FileShareService) ListFileSharesReturnsOnCall(i int, result1 *models.ShareList, result2 error) {
	fake.listFileSharesMutex.Lock()
	defer fake.listFileSharesMutex.Unlock()
	fake.ListFileSharesStub = nil
	if fake.listFileSharesReturnsOnCall == nil {
		fake.listFileSharesReturnsOnCall = make(map[int]struct {
			result1 *models.ShareList
			result2 error
		})
	}
	fake.listFileSharesReturnsOnCall[i] = struct {
		result1 *models.ShareList
		result2 error
	}{result1, result2}
}

func (fake *FileShareService) ListSecurityGroups(arg1 int, arg2 string, arg3 *models.ListSecurityGroupFilters, arg4 *zap.Logger) (*models.SecurityGroupList, error) {
	fake.listSecurityGroupsMutex.Lock()
	ret, specificReturn := fake.listSecurityGroupsReturnsOnCall[len(fake.listSecurityGroupsArgsForCall)]
	fake.listSecurityGroupsArgsForCall = append(fake.listSecurityGroupsArgsForCall, struct {
		arg1 int
		arg2 string
		arg3 *models.ListSecurityGroupFilters
		arg4 *zap.Logger
	}{arg1, arg2, arg3, arg4})
	stub := fake.ListSecurityGroupsStub
	fakeReturns := fake.listSecurityGroupsReturns
	fake.recordInvocation("ListSecurityGroups", []interface{}{arg1, arg2, arg3, arg4})
	fake.listSecurityGroupsMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FileShareService) ListSecurityGroupsCallCount() int {
	fake.listSecurityGroupsMutex.RLock()
	defer fake.listSecurityGroupsMutex.RUnlock()
	return len(fake.listSecurityGroupsArgsForCall)
}

func (fake *FileShareService) ListSecurityGroupsCalls(stub func(int, string, *models.ListSecurityGroupFilters, *zap.Logger) (*models.SecurityGroupList, error)) {
	fake.listSecurityGroupsMutex.Lock()
	defer fake.listSecurityGroupsMutex.Unlock()
	fake.ListSecurityGroupsStub = stub
}

func (fake *FileShareService) ListSecurityGroupsArgsForCall(i int) (int, string, *models.ListSecurityGroupFilters, *zap.Logger) {
	fake.listSecurityGroupsMutex.RLock()
	defer fake.listSecurityGroupsMutex.RUnlock()
	argsForCall := fake.listSecurityGroupsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FileShareService) ListSecurityGroupsReturns(result1 *models.SecurityGroupList, result2 error) {
	fake.listSecurityGroupsMutex.Lock()
	defer fake.listSecurityGroupsMutex.Unlock()
	fake.ListSecurityGroupsStub = nil
	fake.listSecurityGroupsReturns = struct {
		result1 *models.SecurityGroupList
		result2 error
	}{result1, result2}
}

func (fake *FileShareService) ListSecurityGroupsReturnsOnCall(i int, result1 *models.SecurityGroupList, result2 error) {
	fake.listSecurityGroupsMutex.Lock()
	defer fake.listSecurityGroupsMutex.Unlock()
	fake.ListSecurityGroupsStub = nil
	if fake.listSecurityGroupsReturnsOnCall == nil {
		fake.listSecurityGroupsReturnsOnCall = make(map[int]struct {
			result1 *models.SecurityGroupList
			result2 error
		})
	}
	fake.listSecurityGroupsReturnsOnCall[i] = struct {
		result1 *models.SecurityGroupList
		result2 error
	}{result1, result2}
}

func (fake *FileShareService) ListSubnets(arg1 int, arg2 string, arg3 *models.ListSubnetFilters, arg4 *zap.Logger) (*models.SubnetList, error) {
	fake.listSubnetsMutex.Lock()
	ret, specificReturn := fake.listSubnetsReturnsOnCall[len(fake.listSubnetsArgsForCall)]
	fake.listSubnetsArgsForCall = append(fake.listSubnetsArgsForCall, struct {
		arg1 int
		arg2 string
		arg3 *models.ListSubnetFilters
		arg4 *zap.Logger
	}{arg1, arg2, arg3, arg4})
	stub := fake.ListSubnetsStub
	fakeReturns := fake.listSubnetsReturns
	fake.recordInvocation("ListSubnets", []interface{}{arg1, arg2, arg3, arg4})
	fake.listSubnetsMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FileShareService) ListSubnetsCallCount() int {
	fake.listSubnetsMutex.RLock()
	defer fake.listSubnetsMutex.RUnlock()
	return len(fake.listSubnetsArgsForCall)
}

func (fake *FileShareService) ListSubnetsCalls(stub func(int, string, *models.ListSubnetFilters, *zap.Logger) (*models.SubnetList, error)) {
	fake.listSubnetsMutex.Lock()
	defer fake.listSubnetsMutex.Unlock()
	fake.ListSubnetsStub = stub
}

func (fake *FileShareService) ListSubnetsArgsForCall(i int) (int, string, *models.ListSubnetFilters, *zap.Logger) {
	fake.listSubnetsMutex.RLock()
	defer fake.listSubnetsMutex.RUnlock()
	argsForCall := fake.listSubnetsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FileShareService) ListSubnetsReturns(result1 *models.SubnetList, result2 error) {
	fake.listSubnetsMutex.Lock()
	defer fake.listSubnetsMutex.Unlock()
	fake.ListSubnetsStub = nil
	fake.listSubnetsReturns = struct {
		result1 *models.SubnetList
		result2 error
	}{result1, result2}
}

func (fake *FileShareService) ListSubnetsReturnsOnCall(i int, result1 *models.SubnetList, result2 error) {
	fake.listSubnetsMutex.Lock()
	defer fake.listSubnetsMutex.Unlock()
	fake.ListSubnetsStub = nil
	if fake.listSubnetsReturnsOnCall == nil {
		fake.listSubnetsReturnsOnCall = make(map[int]struct {
			result1 *models.SubnetList
			result2 error
		})
	}
	fake.listSubnetsReturnsOnCall[i] = struct {
		result1 *models.SubnetList
		result2 error
	}{result1, result2}
}

func (fake *FileShareService) SetEnableBeta(arg1 bool, arg2 *zap.Logger) {
	fake.setEnableBetaMutex.Lock()
	fake.setEnableBetaArgsForCall = append(fake.setEnableBetaArgsForCall, struct {
		arg1 bool
		arg2 *zap.Logger
	}{arg1, arg2})
	stub := fake.SetEnableBetaStub
	fake.recordInvocation("SetEnableBeta", []interface{}{arg1, arg2})
	fake.setEnableBetaMutex.Unlock()
	if stub != nil {
		fake.SetEnableBetaStub(arg1, arg2)
	}
}

func (fake *FileShareService) SetEnableBetaCallCount() int {
	fake.setEnableBetaMutex.RLock()
	defer fake.setEnableBetaMutex.RUnlock()
	return len(fake.setEnableBetaArgsForCall)
}

func (fake *FileShareService) SetEnableBetaCalls(stub func(bool, *zap.Logger)) {
	fake.setEnableBetaMutex.Lock()
	defer fake.setEnableBetaMutex.Unlock()
	fake.SetEnableBetaStub = stub
}

func (fake *FileShareService) SetEnableBetaArgsForCall(i int) (bool, *zap.Logger) {
	fake.setEnableBetaMutex.RLock()
	defer fake.setEnableBetaMutex.RUnlock()
	argsForCall := fake.setEnableBetaArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FileShareService) UpdateFileShareWithEtag(arg1 string, arg2 string, arg3 *models.Share, arg4 *zap.Logger) error {
	fake.updateFileShareWithEtagMutex.Lock()
	ret, specificReturn := fake.updateFileShareWithEtagReturnsOnCall[len(fake.updateFileShareWithEtagArgsForCall)]
	fake.updateFileShareWithEtagArgsForCall = append(fake.updateFileShareWithEtagArgsForCall, struct {
		arg1 string
		arg2 string
		arg3 *models.Share
		arg4 *zap.Logger
	}{arg1, arg2, arg3, arg4})
	stub := fake.UpdateFileShareWithEtagStub
	fakeReturns := fake.updateFileShareWithEtagReturns
	fake.recordInvocation("UpdateFileShareWithEtag", []interface{}{arg1, arg2, arg3, arg4})
	fake.updateFileShareWithEtagMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FileShareService) UpdateFileShareWithEtagCallCount() int {
	fake.updateFileShareWithEtagMutex.RLock()
	defer fake.updateFileShareWithEtagMutex.RUnlock()
	return len(fake.updateFileShareWithEtagArgsForCall)
}

func (fake *FileShareService) UpdateFileShareWithEtagCalls(stub func(string, string, *models.Share, *zap.Logger) error) {
	fake.updateFileShareWithEtagMutex.Lock()
	defer fake.updateFileShareWithEtagMutex.Unlock()
	fake.UpdateFileShareWithEtagStub = stub
}

func (fake *FileShareService) UpdateFileShareWithEtagArgsForCall(i int) (string, string, *models.Share, *zap.Logger) {
	fake.updateFileShareWithEtagMutex.RLock()
	defer fake.updateFileShareWithEtagMutex.RUnlock()
	argsForCall := fake.updateFileShareWithEtagArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FileShareService) UpdateFileShareWithEtagReturns(result1 error) {
	fake.updateFileShareWithEtagMutex.Lock()
	defer fake.updateFileShareWithEtagMutex.Unlock()
	fake.UpdateFileShareWithEtagStub = nil
	fake.updateFileShareWithEtagReturns = struct {
		result1 error
	}{result1}
}

func (fake *FileShareService) UpdateFileShareWithEtagReturnsOnCall(i int, result1 error) {
	fake.updateFileShareWithEtagMutex.Lock()
	defer fake.updateFileShareWithEtagMutex.Unlock()
	fake.UpdateFileShareWithEtagStub = nil
	if fake.updateFileShareWithEtagReturnsOnCall == nil {
		fake.updateFileShareWithEtagReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.updateFileShareWithEtagReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FileShareService) UpdateVolume(arg1 *provider.UpdatePVC, arg2 *zap.Logger) error {
	fake.updateVolumeMutex.Lock()
	ret, specificReturn := fake.updateVolumeReturnsOnCall[len(fake.updateVolumeArgsForCall)]
	fake.updateVolumeArgsForCall = append(fake.updateVolumeArgsForCall, struct {
		arg1 *provider.UpdatePVC
		arg2 *zap.Logger
	}{arg1, arg2})
	stub := fake.UpdateVolumeStub
	fakeReturns := fake.updateVolumeReturns
	fake.recordInvocation("UpdateVolume", []interface{}{arg1, arg2})
	fake.updateVolumeMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FileShareService) UpdateVolumeCallCount() int {
	fake.updateVolumeMutex.RLock()
	defer fake.updateVolumeMutex.RUnlock()
	return len(fake.updateVolumeArgsForCall)
}

func (fake *FileShareService) UpdateVolumeCalls(stub func(*provider.UpdatePVC, *zap.Logger) error) {
	fake.updateVolumeMutex.Lock()
	defer fake.updateVolumeMutex.Unlock()
	fake.UpdateVolumeStub = stub
}

func (fake *FileShareService) UpdateVolumeArgsForCall(i int) (*provider.UpdatePVC, *zap.Logger) {
	fake.updateVolumeMutex.RLock()
	defer fake.updateVolumeMutex.RUnlock()
	argsForCall := fake.updateVolumeArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FileShareService) UpdateVolumeReturns(result1 error) {
	fake.updateVolumeMutex.Lock()
	defer fake.updateVolumeMutex.Unlock()
	fake.UpdateVolumeStub = nil
	fake.updateVolumeReturns = struct {
		result1 error
	}{result1}
}

func (fake *FileShareService) UpdateVolumeReturnsOnCall(i int, result1 error) {
	fake.updateVolumeMutex.Lock()
	defer fake.updateVolumeMutex.Unlock()
	fake.UpdateVolumeStub = nil
	if fake.updateVolumeReturnsOnCall == nil {
		fake.updateVolumeReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.updateVolumeReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FileShareService) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.createFileShareMutex.RLock()
	defer fake.createFileShareMutex.RUnlock()
	fake.createFileShareTargetMutex.RLock()
	defer fake.createFileShareTargetMutex.RUnlock()
	fake.deleteFileShareMutex.RLock()
	defer fake.deleteFileShareMutex.RUnlock()
	fake.deleteFileShareTargetMutex.RLock()
	defer fake.deleteFileShareTargetMutex.RUnlock()
	fake.expandVolumeMutex.RLock()
	defer fake.expandVolumeMutex.RUnlock()
	fake.getFileShareMutex.RLock()
	defer fake.getFileShareMutex.RUnlock()
	fake.getFileShareByNameMutex.RLock()
	defer fake.getFileShareByNameMutex.RUnlock()
	fake.getFileShareEtagMutex.RLock()
	defer fake.getFileShareEtagMutex.RUnlock()
	fake.getFileShareTargetMutex.RLock()
	defer fake.getFileShareTargetMutex.RUnlock()
	fake.getFileShareTargetByNameMutex.RLock()
	defer fake.getFileShareTargetByNameMutex.RUnlock()
	fake.listFileShareTargetsMutex.RLock()
	defer fake.listFileShareTargetsMutex.RUnlock()
	fake.listFileSharesMutex.RLock()
	defer fake.listFileSharesMutex.RUnlock()
	fake.listSecurityGroupsMutex.RLock()
	defer fake.listSecurityGroupsMutex.RUnlock()
	fake.listSubnetsMutex.RLock()
	defer fake.listSubnetsMutex.RUnlock()
	fake.setEnableBetaMutex.RLock()
	defer fake.setEnableBetaMutex.RUnlock()
	fake.updateFileShareWithEtagMutex.RLock()
	defer fake.updateFileShareWithEtagMutex.RUnlock()
	fake.updateVolumeMutex.RLock()
	defer fake.updateVolumeMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FileShareService) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ vpcfilevolume.FileShareManager = new(FileShareService)
