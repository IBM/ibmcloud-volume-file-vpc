
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>auth: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/IBM/ibmcloud-volume-file-vpc/common/auth/factory.go (90.0%)</option>
				
				<option value="file1">github.com/IBM/ibmcloud-volume-file-vpc/common/iam/token_exchange_iks.go (92.5%)</option>
				
				<option value="file2">github.com/IBM/ibmcloud-volume-file-vpc/common/messages/messages.go (100.0%)</option>
				
				<option value="file3">github.com/IBM/ibmcloud-volume-file-vpc/common/messages/messages_en.go (100.0%)</option>
				
				<option value="file4">github.com/IBM/ibmcloud-volume-file-vpc/common/registry/registry.go (100.0%)</option>
				
				<option value="file5">github.com/IBM/ibmcloud-volume-file-vpc/common/vpcclient/client/authentication.go (80.0%)</option>
				
				<option value="file6">github.com/IBM/ibmcloud-volume-file-vpc/common/vpcclient/client/client.go (100.0%)</option>
				
				<option value="file7">github.com/IBM/ibmcloud-volume-file-vpc/common/vpcclient/client/params.go (100.0%)</option>
				
				<option value="file8">github.com/IBM/ibmcloud-volume-file-vpc/common/vpcclient/client/payload/body_provider.go (52.4%)</option>
				
				<option value="file9">github.com/IBM/ibmcloud-volume-file-vpc/common/vpcclient/client/payload/response_consumer.go (100.0%)</option>
				
				<option value="file10">github.com/IBM/ibmcloud-volume-file-vpc/common/vpcclient/client/request.go (84.8%)</option>
				
				<option value="file11">github.com/IBM/ibmcloud-volume-file-vpc/common/vpcclient/riaas/config.go (100.0%)</option>
				
				<option value="file12">github.com/IBM/ibmcloud-volume-file-vpc/common/vpcclient/riaas/riaas.go (95.8%)</option>
				
				<option value="file13">github.com/IBM/ibmcloud-volume-file-vpc/common/vpcclient/vpcfilevolume/create_file_share.go (93.3%)</option>
				
				<option value="file14">github.com/IBM/ibmcloud-volume-file-vpc/common/vpcclient/vpcfilevolume/create_file_share_target.go (100.0%)</option>
				
				<option value="file15">github.com/IBM/ibmcloud-volume-file-vpc/common/vpcclient/vpcfilevolume/delete_file_share.go (100.0%)</option>
				
				<option value="file16">github.com/IBM/ibmcloud-volume-file-vpc/common/vpcclient/vpcfilevolume/delete_file_share_target.go (100.0%)</option>
				
				<option value="file17">github.com/IBM/ibmcloud-volume-file-vpc/common/vpcclient/vpcfilevolume/expand_volume.go (100.0%)</option>
				
				<option value="file18">github.com/IBM/ibmcloud-volume-file-vpc/common/vpcclient/vpcfilevolume/file_share_service.go (100.0%)</option>
				
				<option value="file19">github.com/IBM/ibmcloud-volume-file-vpc/common/vpcclient/vpcfilevolume/get_file_share.go (100.0%)</option>
				
				<option value="file20">github.com/IBM/ibmcloud-volume-file-vpc/common/vpcclient/vpcfilevolume/get_file_share_etag.go (100.0%)</option>
				
				<option value="file21">github.com/IBM/ibmcloud-volume-file-vpc/common/vpcclient/vpcfilevolume/get_file_share_target.go (96.0%)</option>
				
				<option value="file22">github.com/IBM/ibmcloud-volume-file-vpc/common/vpcclient/vpcfilevolume/get_share_profile.go (100.0%)</option>
				
				<option value="file23">github.com/IBM/ibmcloud-volume-file-vpc/common/vpcclient/vpcfilevolume/iks_update_volume.go (100.0%)</option>
				
				<option value="file24">github.com/IBM/ibmcloud-volume-file-vpc/common/vpcclient/vpcfilevolume/iks_volume_service.go (100.0%)</option>
				
				<option value="file25">github.com/IBM/ibmcloud-volume-file-vpc/common/vpcclient/vpcfilevolume/list_file_share_targets.go (100.0%)</option>
				
				<option value="file26">github.com/IBM/ibmcloud-volume-file-vpc/common/vpcclient/vpcfilevolume/list_file_shares.go (100.0%)</option>
				
				<option value="file27">github.com/IBM/ibmcloud-volume-file-vpc/common/vpcclient/vpcfilevolume/list_security_groups.go (100.0%)</option>
				
				<option value="file28">github.com/IBM/ibmcloud-volume-file-vpc/common/vpcclient/vpcfilevolume/list_subnets.go (100.0%)</option>
				
				<option value="file29">github.com/IBM/ibmcloud-volume-file-vpc/common/vpcclient/vpcfilevolume/update_file_share_with_etag.go (100.0%)</option>
				
				<option value="file30">github.com/IBM/ibmcloud-volume-file-vpc/common/vpcclient/vpcfilevolume/update_volume.go (100.0%)</option>
				
				<option value="file31">github.com/IBM/ibmcloud-volume-file-vpc/file/provider/create_volume.go (93.7%)</option>
				
				<option value="file32">github.com/IBM/ibmcloud-volume-file-vpc/file/provider/create_volume_access_point.go (100.0%)</option>
				
				<option value="file33">github.com/IBM/ibmcloud-volume-file-vpc/file/provider/delete_volume.go (91.7%)</option>
				
				<option value="file34">github.com/IBM/ibmcloud-volume-file-vpc/file/provider/delete_volume_access_point.go (100.0%)</option>
				
				<option value="file35">github.com/IBM/ibmcloud-volume-file-vpc/file/provider/expand_volume.go (92.3%)</option>
				
				<option value="file36">github.com/IBM/ibmcloud-volume-file-vpc/file/provider/get_security_group.go (58.8%)</option>
				
				<option value="file37">github.com/IBM/ibmcloud-volume-file-vpc/file/provider/get_subnet.go (58.8%)</option>
				
				<option value="file38">github.com/IBM/ibmcloud-volume-file-vpc/file/provider/get_volume.access_point.go (100.0%)</option>
				
				<option value="file39">github.com/IBM/ibmcloud-volume-file-vpc/file/provider/get_volume.go (100.0%)</option>
				
				<option value="file40">github.com/IBM/ibmcloud-volume-file-vpc/file/provider/get_volume_profile.go (100.0%)</option>
				
				<option value="file41">github.com/IBM/ibmcloud-volume-file-vpc/file/provider/list_volumes.go (91.2%)</option>
				
				<option value="file42">github.com/IBM/ibmcloud-volume-file-vpc/file/provider/provider.go (84.3%)</option>
				
				<option value="file43">github.com/IBM/ibmcloud-volume-file-vpc/file/provider/session.go (100.0%)</option>
				
				<option value="file44">github.com/IBM/ibmcloud-volume-file-vpc/file/provider/token_generator.go (47.7%)</option>
				
				<option value="file45">github.com/IBM/ibmcloud-volume-file-vpc/file/provider/update_volume.go (96.3%)</option>
				
				<option value="file46">github.com/IBM/ibmcloud-volume-file-vpc/file/provider/util.go (83.8%)</option>
				
				<option value="file47">github.com/IBM/ibmcloud-volume-file-vpc/file/provider/wait_for_create_volume_access_point.go (100.0%)</option>
				
				<option value="file48">github.com/IBM/ibmcloud-volume-file-vpc/file/provider/wait_for_delete_volume_access_point.go (100.0%)</option>
				
				<option value="file49">github.com/IBM/ibmcloud-volume-file-vpc/file/provider/wait_for_valid_volume_state.go (100.0%)</option>
				
				<option value="file50">github.com/IBM/ibmcloud-volume-file-vpc/file/utils/init_provider.go (95.5%)</option>
				
				<option value="file51">github.com/IBM/ibmcloud-volume-file-vpc/iks/provider/provider.go (21.8%)</option>
				
				<option value="file52">github.com/IBM/ibmcloud-volume-file-vpc/iks/provider/session.go (100.0%)</option>
				
				<option value="file53">github.com/IBM/ibmcloud-volume-file-vpc/iks/provider/update_volume.go (51.4%)</option>
				
				<option value="file54">github.com/IBM/ibmcloud-volume-file-vpc/pkg/ibmcloudprovider/fake_volume_provider.go (45.5%)</option>
				
				<option value="file55">github.com/IBM/ibmcloud-volume-file-vpc/pkg/ibmcloudprovider/volume_provider.go (55.6%)</option>
				
				<option value="file56">github.com/IBM/ibmcloud-volume-file-vpc/pkg/metadata/fake_node_metadata.go (46.0%)</option>
				
				<option value="file57">github.com/IBM/ibmcloud-volume-file-vpc/pkg/metadata/fakemetadata.go (100.0%)</option>
				
				<option value="file58">github.com/IBM/ibmcloud-volume-file-vpc/pkg/metadata/metadata.go (22.2%)</option>
				
				<option value="file59">github.com/IBM/ibmcloud-volume-file-vpc/pkg/watcher/pv_watcher.go (26.4%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">/**
 * Copyright 2021 IBM Corp.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// Package auth ...
package auth

import (
        vpciam "github.com/IBM/ibmcloud-volume-file-vpc/common/iam"
        vpcfileconfig "github.com/IBM/ibmcloud-volume-file-vpc/file/vpcconfig"
        "github.com/IBM/ibmcloud-volume-interface/provider/auth"
        "github.com/IBM/ibmcloud-volume-interface/provider/iam"
        "github.com/IBM/secret-utils-lib/pkg/k8s_utils"
)

// NewVPCContextCredentialsFactory ...
func NewVPCContextCredentialsFactory(config *vpcfileconfig.VPCFileConfig, k8sClient *k8s_utils.KubernetesClient) (*auth.ContextCredentialsFactory, error) <span class="cov8" title="1">{
        authConfig := &amp;iam.AuthConfiguration{
                IamURL:          config.VPCConfig.G2TokenExchangeURL,
                IamClientID:     config.VPCConfig.IamClientID,
                IamClientSecret: config.VPCConfig.IamClientSecret,
        }
        ccf, err := auth.NewContextCredentialsFactory(authConfig, k8sClient, iam.VPC)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if config.VPCConfig.IKSTokenExchangePrivateURL != "" </span><span class="cov8" title="1">{
                authIKSConfig := &amp;vpciam.IksAuthConfiguration{
                        IamAPIKey:       config.VPCConfig.G2APIKey,
                        PrivateAPIRoute: config.VPCConfig.IKSTokenExchangePrivateURL, // Only for private cluster
                }
                ccf.TokenExchangeService, err = vpciam.NewTokenExchangeIKSService(authIKSConfig, k8sClient)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }
        <span class="cov8" title="1">return ccf, nil</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">/**
 * Copyright 2021 IBM Corp.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// Package iam ...
package iam

import (
        "errors"
        "fmt"
        "net/http"
        "time"

        "github.com/IBM-Cloud/ibm-cloud-cli-sdk/common/rest"
        "github.com/IBM/ibmcloud-volume-interface/config"
        util "github.com/IBM/ibmcloud-volume-interface/lib/utils"
        "github.com/IBM/ibmcloud-volume-interface/provider/iam"
        "github.com/IBM/secret-common-lib/pkg/secret_provider"
        "github.com/IBM/secret-utils-lib/pkg/k8s_utils"
        sp "github.com/IBM/secret-utils-lib/pkg/secret_provider"
        "go.uber.org/zap"
)

// tokenExchangeIKSService ...
type tokenExchangeIKSService struct {
        iksAuthConfig *IksAuthConfiguration
        httpClient    *http.Client
        spObject      sp.SecretProviderInterface
}

// IksAuthConfiguration ...
type IksAuthConfiguration struct {
        PrivateAPIRoute string
        IamAPIKey       string
        CSRFToken       string
}

// TokenExchangeService ...
var _ iam.TokenExchangeService = &amp;tokenExchangeIKSService{}

// NewTokenExchangeIKSService ...
func NewTokenExchangeIKSService(iksAuthConfig *IksAuthConfiguration, k8sClient *k8s_utils.KubernetesClient) (iam.TokenExchangeService, error) <span class="cov8" title="1">{
        httpClient, err := config.GeneralCAHttpClient()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">providerType := map[string]string{
                secret_provider.ProviderType: secret_provider.VPC,
        }
        spObject, err := secret_provider.NewSecretProvider(k8sClient, providerType)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return &amp;tokenExchangeIKSService{
                iksAuthConfig: iksAuthConfig,
                httpClient:    httpClient,
                spObject:      spObject,
        }, nil</span>
}

// tokenExchangeIKSRequest ...
type tokenExchangeIKSRequest struct {
        tes          *tokenExchangeIKSService
        request      *rest.Request
        client       *rest.Client
        logger       *zap.Logger
        errorRetrier *util.ErrorRetrier
}

// tokenExchangeIKSResponse ...
type tokenExchangeIKSResponse struct {
        AccessToken string `json:"token"`
        //ImsToken    string `json:"ims_token"`
}

// ExchangeRefreshTokenForAccessToken ...
func (tes *tokenExchangeIKSService) ExchangeRefreshTokenForAccessToken(refreshToken string, logger *zap.Logger) (*iam.AccessToken, error) <span class="cov8" title="1">{
        r := tes.newTokenExchangeRequest(logger)
        return r.exchangeForAccessToken()
}</span>

// ExchangeIAMAPIKeyForAccessToken ...
func (tes *tokenExchangeIKSService) ExchangeIAMAPIKeyForAccessToken(iamAPIKey string, logger *zap.Logger) (*iam.AccessToken, error) <span class="cov8" title="1">{
        logger.Info("Fetching using secret provider")
        token, _, err := tes.spObject.GetDefaultIAMToken(false)
        if err != nil </span><span class="cov8" title="1">{
                logger.Error("Error fetching iam token", zap.Error(err))
                return nil, err
        }</span>
        <span class="cov0" title="0">logger.Info("Successfully fetched iam token")
        return &amp;iam.AccessToken{Token: token}, nil</span>
}

// newTokenExchangeRequest ...
func (tes *tokenExchangeIKSService) newTokenExchangeRequest(logger *zap.Logger) *tokenExchangeIKSRequest <span class="cov8" title="1">{
        client := rest.NewClient()
        client.HTTPClient = tes.httpClient
        retyrInterval, _ := time.ParseDuration("3s")
        return &amp;tokenExchangeIKSRequest{
                tes:          tes,
                request:      rest.PostRequest(fmt.Sprintf("%s/v1/iam/apikey", tes.iksAuthConfig.PrivateAPIRoute)),
                client:       client,
                logger:       logger,
                errorRetrier: util.NewErrorRetrier(40, retyrInterval, logger),
        }
}</span>

// ExchangeAccessTokenForIMSToken ...
func (tes *tokenExchangeIKSService) ExchangeAccessTokenForIMSToken(accessToken iam.AccessToken, logger *zap.Logger) (*iam.IMSToken, error) <span class="cov8" title="1">{
        return nil, nil
}</span>

// ExchangeIAMAPIKeyForIMSToken ...
func (tes *tokenExchangeIKSService) ExchangeIAMAPIKeyForIMSToken(iamAPIKey string, logger *zap.Logger) (*iam.IMSToken, error) <span class="cov8" title="1">{
        return nil, nil
}</span>

func (tes *tokenExchangeIKSService) GetIAMAccountIDFromAccessToken(accessToken iam.AccessToken, logger *zap.Logger) (accountID string, err error) <span class="cov8" title="1">{
        return "Not required to implement", nil
}</span>

// exchangeForAccessToken ...
func (r *tokenExchangeIKSRequest) exchangeForAccessToken() (*iam.AccessToken, error) <span class="cov8" title="1">{
        var iamResp *tokenExchangeIKSResponse
        var err error
        err = r.errorRetrier.ErrorRetry(func() (error, bool) </span><span class="cov8" title="1">{
                iamResp, err = r.sendTokenExchangeRequest()
                return err, !iam.IsConnectionError(err) // Skip retry if its not connection error
        }</span>)
        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return &amp;iam.AccessToken{Token: iamResp.AccessToken}, nil</span>
}

// sendTokenExchangeRequest ...
func (r *tokenExchangeIKSRequest) sendTokenExchangeRequest() (*tokenExchangeIKSResponse, error) <span class="cov8" title="1">{
        r.logger.Info("In tokenExchangeIKSRequest's sendTokenExchangeRequest()")
        // Set headers
        r.request = r.request.Add("X-CSRF-TOKEN", r.tes.iksAuthConfig.CSRFToken)
        // Setting body
        var apikey = struct {
                APIKey string `json:"apikey"`
        }{
                APIKey: r.tes.iksAuthConfig.IamAPIKey,
        }
        r.request = r.request.Body(&amp;apikey)

        var successV tokenExchangeIKSResponse
        var errorV = struct {
                ErrorCode        string `json:"code"`
                ErrorDescription string `json:"description"`
                ErrorType        string `json:"type"`
                IncidentID       string `json:"incidentID"`
        }{}

        r.logger.Info("Sending IAM token exchange request to container api server")
        resp, err := r.client.Do(r.request, &amp;successV, &amp;errorV)
        if err != nil </span><span class="cov8" title="1">{
                r.logger.Error("IAM token exchange request failed", zap.Reflect("Response", resp), zap.Error(err))
                return nil,
                        util.NewError("ErrorUnclassified",
                                "IAM token exchange request failed", err)
        }</span>

        <span class="cov8" title="1">if resp != nil &amp;&amp; resp.StatusCode == 200 </span><span class="cov8" title="1">{
                r.logger.Debug("IAM token exchange request successful")
                return &amp;successV, nil
        }</span>
        // closing resp body only when some issues, in case of success its not required
        // to close here
        <span class="cov8" title="1">defer resp.Body.Close()

        if errorV.ErrorDescription != "" </span><span class="cov8" title="1">{
                r.logger.Error("IAM token exchange request failed with message",
                        zap.Int("StatusCode", resp.StatusCode), zap.Reflect("API IncidentID", errorV.IncidentID),
                        zap.Reflect("Error", errorV))

                err := util.NewError("ErrorFailedTokenExchange",
                        "IAM token exchange request failed: "+errorV.ErrorDescription,
                        errors.New(errorV.ErrorCode+" "+errorV.ErrorType+", Description: "+errorV.ErrorDescription+", API IncidentID:"+errorV.IncidentID))
                return nil, err
        }</span>

        <span class="cov8" title="1">r.logger.Error("Unexpected IAM token exchange response",
                zap.Int("StatusCode", resp.StatusCode), zap.Reflect("Response", resp))

        return nil,
                util.NewError("ErrorUnclassified",
                        "Unexpected IAM token exchange response")</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">/**
 * Copyright 2021 IBM Corp.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// Package messages ...
package messages

import (
        "fmt"

        util "github.com/IBM/ibmcloud-volume-interface/lib/utils"
)

// MessagesEn ...
var MessagesEn map[string]util.Message

// GetUserErr ...
func GetUserErr(code string, err error, args ...interface{}) error <span class="cov8" title="1">{
        //Incase of no error message, dont construct the Error Object
        if err == nil </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">userMsg := GetUserMsg(code, args...)
        userMsg.BackendError = err.Error()
        return userMsg</span>
}

// GetUserMsg ...
func GetUserMsg(code string, args ...interface{}) util.Message <span class="cov8" title="1">{
        userMsg := MessagesEn[code]
        if len(args) &gt; 0 </span><span class="cov8" title="1">{
                userMsg.Description = fmt.Sprintf(userMsg.Description, args...)
        }</span>
        <span class="cov8" title="1">return userMsg</span>
}

// GetUserError ...
func GetUserError(code string, err error, args ...interface{}) error <span class="cov8" title="1">{
        userMsg := GetUserMsg(code, args...)

        if err != nil </span><span class="cov8" title="1">{
                userMsg.BackendError = err.Error()
        }</span>
        <span class="cov8" title="1">return userMsg</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">/**
 * Copyright 2021 IBM Corp.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// Package messages ...
package messages

import (
        util "github.com/IBM/ibmcloud-volume-interface/lib/utils"
)

// messagesEn ...
var messagesEn = map[string]util.Message{
        "ErrorRequiredFieldMissing": {
                Code:        "ErrorRequiredFieldMissing",
                Description: "[%s] is required to complete the operation.",
                Type:        util.InvalidRequest,
                RC:          400,
                Action:      "Review the error that is returned. Provide the missing information in your request and try again.",
        },
        "FailedToPlaceOrder": {
                Code:        "FailedToPlaceOrder",
                Description: "Failed to create file share with the storage provider",
                Type:        util.ProvisioningFailed,
                RC:          500,
                Action:      "Review the error that is returned. If the file share creation service is currently unavailable, try to manually create the file share with the 'ibmcloud is share-create' command.",
        },
        "FailedToDeleteVolume": {
                Code:        "FailedToDeleteVolume",
                Description: "The file share ID '%d' could not be deleted from your VPC.",
                Type:        util.DeletionFailed,
                RC:          500,
                Action:      "Verify that the file share ID exists. Run 'ibmcloud is shares' to list available file shares in your account. If the ID is correct, try to delete the file share with the 'ibmcloud is share-delete' command. ",
        },
        "FailedToExpandVolume": {
                Code:        "FailedToExpandVolume",
                Description: "The volume ID '%s' could not be expanded from your VPC.",
                Type:        util.ExpansionFailed,
                RC:          500,
                Action:      "Verify that the volume ID exists. If the ID is correct, check that expected capacity is valid and supported",
        },
        "FailedToUpdateVolume": {
                Code:        "FailedToUpdateVolume",
                Description: "The file share ID '%d' could not be updated",
                Type:        util.UpdateFailed,
                RC:          500,
                Action:      "Verify that the file share ID exists. Run 'ibmcloud is shares' to list available file share in your account.",
        },
        "StorageFindFailedWithVolumeId": {
                Code:        "StorageFindFailedWithVolumeId",
                Description: "A file share with the specified file share ID '%s' could not be found.",
                Type:        util.RetrivalFailed,
                RC:          404,
                Action:      "Verify that the file share ID exists. Run 'ibmcloud is shares' to list available file shares in your account.",
        },
        "StorageFindFailedWithVolumeName": {
                Code:        "StorageFindFailedWithVolumeName",
                Description: "A file share with the specified file share name '%s' does not exist.",
                Type:        util.RetrivalFailed,
                RC:          404,
                Action:      "Verify that the specified file share exists. Run 'ibmcloud is shares' to list available file shares in your account.",
        },
        "AccessPointWithAPIDFindFailed": {
                Code:        AccessPointWithAPIDFindFailed,
                Description: "No mount target could be found for the specified file share ID '%s' and mount target ID '%s'",
                Type:        util.VolumeAccessPointFindFailed,
                RC:          400,
                Action:      "Verify that a mount target for your file share exists. Run `ibmcloud is share-targets &lt;SHARE_ID&gt;` to list all mount targets for a file share. Check if file share ID and mount target ID is valid",
        },
        "AccessPointWithVPCIDFindFailed": {
                Code:        AccessPointWithVPCIDFindFailed,
                Description: "No mount target could be found for the specified file share ID '%s' and VPC ID %s",
                Type:        util.VolumeAccessPointFindFailed,
                RC:          400,
                Action:      "Verify that a mount target for your file share exists. Run `ibmcloud is share-targets &lt;SHARE_ID&gt;` to list all volume targets for a file share. Check if file share ID and VPC ID is valid",
        },
        "CreateVolumeAccessPointFailed": {
                Code:        CreateVolumeAccessPointFailed,
                Description: "The file share ID '%s' could not create mount target for VPC ID %s.",
                Type:        util.CreateVolumeAccessPointFailed,
                RC:          500,
                Action:      "Verify that the file share ID and VPC ID exist.",
        },
        "CreateVolumeAccessPointTimedOut": {
                Code:        CreateVolumeAccessPointTimedOut,
                Description: "The file share ID '%s' could not create mount target ID '%s'.",
                Type:        util.CreateVolumeAccessPointFailed,
                RC:          500,
                Action:      "Verify that the file share ID exists.",
        },
        "DeleteVolumeAccessPointFailed": {
                Code:        DeleteVolumeAccessPointFailed,
                Description: "The file share ID '%s' could not delete mount target ID '%s'.",
                Type:        util.DeleteVolumeAccessPointFailed,
                RC:          500,
                Action:      "Verify that the specified file share ID has active mount target.",
        },
        "DeleteVolumeAccessPointTimedOut": {
                Code:        DeleteVolumeAccessPointTimedOut,
                Description: "The file share ID '%s' could not delete mount target ID '%s'",
                Type:        util.DeleteVolumeAccessPointFailed,
                RC:          500,
                Action:      "Verify that the specified file share ID has active mount targets.",
        },
        "InvalidVolumeID": {
                Code:        "InvalidVolumeID",
                Description: "The specified file share ID '%s' is not valid.",
                Type:        util.InvalidRequest,
                RC:          400,
                Action:      "Verify that the file share ID exists. Run 'ibmcloud is shares' to list available file shares in your account.",
        },
        "InvalidVolumeName": {
                Code:        "InvalidVolumeName",
                Description: "The specified file share name '%s' is not valid. ",
                Type:        util.InvalidRequest,
                RC:          400,
                Action:      "Verify that the file share name exists. Run 'ibmcloud is shares' to list available file shares in your account.",
        },
        "VolumeCapacityInvalid": {
                Code:        "VolumeCapacityInvalid",
                Description: "The specified file share capacity '%d' is not valid. ",
                Type:        util.InvalidRequest,
                RC:          400,
                Action:      "Verify the specified file share capacity. The file share capacity must be a positive number between 10 GB and maximum allowed value for the respective storage profile. Refer IBM Cloud File Storage for VPC documentation https://cloud.ibm.com/docs/vpc?topic=vpc-file-storage-profiles.",
        },
        "EmptyResourceGroup": {
                Code:        "EmptyResourceGroup",
                Description: "Resource group information could not be found.",
                Type:        util.InvalidRequest,
                RC:          400,
                Action:      "Provide the name or ID of the resource group that you want to use for your file share. Run 'ibmcloud resource groups' to list the resource groups that you have access to. ",
        },
        "EmptyResourceGroupIDandName": {
                Code:        "EmptyResourceGroupIDandName",
                Description: "Resource group ID or name could not be found.",
                Type:        util.InvalidRequest,
                RC:          400,
                Action:      "Provide the name or ID of the resource group that you want to use for your file share. Run 'ibmcloud resource groups' to list the resource groups that you have access to.",
        },
        "VolumeNotInValidState": {
                Code:        "VolumeNotInValidState",
                Description: "Share %s did not get valid (stable) status within timeout period.",
                Type:        util.ProvisioningFailed,
                RC:          500,
                Action:      "Run 'ibmcloud is share &lt;SHARE-ID&gt;' and check the current status. If the status is not stable, contact support.",
        },
        "SubnetsListFailed": {
                Code:        "SubnetsListFailed",
                Description: "Unable to fetch list of subnet.",
                Type:        util.RetrivalFailed,
                RC:          500,
                Action:      "Unable to list subnet. Target to appropriate region 'ibmcloud target -r &lt;region&gt;' and verify if 'ibmcloud is subnets' is returning the subnets. If it is not returning then raise ticket for VPC team else raise ticket for IKS team.",
        },
        "SubnetFindFailed": {
                Code:        "SubnetFindFailed",
                Description: "A subnet with the specified zone '%s' and available cluster subnet list '%s' could not be found.",
                Type:        util.RetrivalFailed,
                RC:          404,
                Action:      "Check whether your VPC and cluster are in different resource groups. If your VPC and cluster are in different resource groups, then refer to https://cloud.ibm.com/docs/containers?topic=containers-storage-file-vpc-apps#storage-file-vpc-custom-sc for more details. If your VPC and cluster are in the same resource group, contact support.",
        },
        "SecurityGroupsListFailed": {
                Code:        "SecurityGroupsListFailed",
                Description: "Unable to fetch list of securityGroup.",
                Type:        util.RetrivalFailed,
                RC:          500,
                Action:      "Unable to list securityGroup. Target to appropriate region 'ibmcloud target -r &lt;region&gt;' and verify if 'ibmcloud is securityGroups' is returning the securityGroups. If it is not returning then raise ticket for VPC team else raise ticket for IKS team.",
        },
        "SecurityGroupFindFailed": {
                Code:        "SecurityGroupFindFailed",
                Description: "A securityGroup with the specified securityGroup name '%s' could not be found.",
                Type:        util.RetrivalFailed,
                RC:          404,
                Action:      "Verify that the cluster securityGroup exists. Target to appropriate region 'ibmcloud target -r &lt;region&gt;' and verify if 'ibmcloud is securityGroups' is returning the securityGroups. Please provide the output and raise ticket for IKS team.",
        },
        "ListVolumesFailed": {
                Code:        "ListVolumesFailed",
                Description: "Unable to fetch list of file shares.",
                Type:        util.RetrivalFailed,
                RC:          404,
                Action:      "Unable to list file shares. Run 'ibmcloud is shares' to list available file shares in your account.",
        },
        "InvalidListVolumesLimit": {
                Code:        "InvalidListVolumesLimit",
                Description: "The value '%v' specified in the limit parameter of the list file share call is not valid.",
                Type:        util.InvalidRequest,
                RC:          400,
                Action:      "Verify the limit parameter's value. The limit must be a positive number between 0 and 100.",
        },
        "StartVolumeIDNotFound": {
                Code:        "StartVolumeIDNotFound",
                Description: "The file share ID '%s' specified in the start parameter of the list volume call could not be found.",
                Type:        util.InvalidRequest,
                RC:          400,
                Action:      "Please verify that the start file share ID is correct and whether you have access to the file share ID.",
        },
        VolumeAccessPointExist: {
                Code:        VolumeAccessPointExist,
                Description: "The file share ID '%s' could not be deleted from your VPC. File share has mount targets which needs to deleted. Please go through the list of VPCs = '%v'",
                Type:        util.DeletionFailed,
                Action:      "User need to review all mount targets and delete them first before deleting file share. Run `ibmcloud is share-targets &lt;SHARE_ID&gt;` to get the mount target for the file share. ",
        },
}

// InitMessages ...
func InitMessages() map[string]util.Message <span class="cov8" title="1">{
        return messagesEn
}</span>
</pre>
		
		<pre class="file" id="file4" style="display: none">/**
 * Copyright 2021 IBM Corp.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// Package registry ...
package registry

import (
        //"github.com/prometheus/client_golang/prometheus"
        util "github.com/IBM/ibmcloud-volume-interface/lib/utils"
        "github.com/IBM/ibmcloud-volume-interface/provider/local"
)

// Providers is a registry interface for IaaS providers
//
//go:generate counterfeiter -o fakes/provider_registry.go --fake-name Providers . Providers
type Providers interface {
        Get(providerID string) (local.Provider, error)
        Register(providerID string, prov local.Provider)
}

var _ Providers = &amp;ProviderRegistry{}

// ProviderRegistry is the core implementation of the Providers registry
type ProviderRegistry struct {
        providers map[string]local.Provider
}

// Get returns the identified Provider
func (pr *ProviderRegistry) Get(providerID string) (prov local.Provider, err error) <span class="cov8" title="1">{
        prov = pr.providers[providerID]
        if prov == nil </span><span class="cov8" title="1">{
                err = util.NewError("ErrorUnclassified", "Provider unknown: "+providerID)
        }</span>
        <span class="cov8" title="1">return</span>
}

// Register registers a given provider under the supplied key
func (pr *ProviderRegistry) Register(providerID string, p local.Provider) <span class="cov8" title="1">{
        if pr.providers == nil </span><span class="cov8" title="1">{
                pr.providers = map[string]local.Provider{}
        }</span>
        <span class="cov8" title="1">pr.providers[providerID] = p</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">/**
 * Copyright 2021 IBM Corp.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// Package client ...
package client

import (
        "errors"
)

// ErrAuthenticationRequired is returned if a request is made before an authentication
// token has been provided to the client
var ErrAuthenticationRequired = errors.New("authentication token required")

type authenticationHandler struct {
        authToken     string
        resourceGroup string
}

// Before is called before each request
func (a *authenticationHandler) Before(request *Request) error <span class="cov8" title="1">{
        request.resourceGroup = a.resourceGroup

        if a.authToken == "" </span><span class="cov0" title="0">{
                return ErrAuthenticationRequired
        }</span>
        <span class="cov8" title="1">request.headers.Set("Authorization", "Bearer "+a.authToken)
        return nil</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">/**
 * Copyright 2021 IBM Corp.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// Package client ...
package client

import (
        "context"
        "io"
        "net/http"
        "net/url"

        "github.com/IBM/ibmcloud-volume-file-vpc/common/vpcclient/models"
)

// handler ...
type handler interface {
        Before(request *Request) error
}

// SessionClient provides an interface for a REST API client
// go:generate counterfeiter -o fakes/client.go --fake-name SessionClient . SessionClient
type SessionClient interface {
        NewRequest(operation *Operation) *Request
        WithDebug(writer io.Writer) SessionClient
        WithAuthToken(authToken string) SessionClient
        WithPathParameter(name, value string) SessionClient
        WithQueryValue(name, value string) SessionClient
}

type client struct {
        baseURL       string
        httpClient    *http.Client
        pathParams    Params
        queryValues   url.Values
        authenHandler handler
        debugWriter   io.Writer
        resourceGroup string
        contextID     string
        context       context.Context
}

// New creates a new instance of a SessionClient
func New(ctx context.Context, baseURL string, queryValues url.Values, httpClient *http.Client, contextID string, resourceGroupID string) SessionClient <span class="cov8" title="1">{
        return &amp;client{
                baseURL:       baseURL,
                httpClient:    httpClient,
                pathParams:    Params{},
                queryValues:   queryValues,
                authenHandler: &amp;authenticationHandler{},
                contextID:     contextID,
                context:       ctx,
                resourceGroup: resourceGroupID,
        }
}</span>

// NewRequest creates a request and configures it with the supplied operation
func (c *client) NewRequest(operation *Operation) *Request <span class="cov8" title="1">{
        headers := http.Header{}
        headers.Set("Accept", "application/json")
        headers.Set("User-Agent", models.UserAgent)
        if c.contextID != "" </span><span class="cov8" title="1">{
                headers.Set("X-Request-ID", c.contextID)
                headers.Set("X-Transaction-ID", c.contextID) // To avoid IKS cloudflare overriding X-Request-ID
        }</span>

        <span class="cov8" title="1">if c.resourceGroup != "" </span><span class="cov8" title="1">{
                headers.Set("X-Auth-Resource-Group-ID", c.resourceGroup)
        }</span>

        // Copy the query values to a new map
        <span class="cov8" title="1">qv := url.Values{}
        for k, v := range c.queryValues </span><span class="cov8" title="1">{
                qv[k] = v
        }</span>

        <span class="cov8" title="1">return &amp;Request{
                httpClient:    c.httpClient,
                context:       c.context,
                baseURL:       c.baseURL,
                operation:     operation,
                pathParams:    c.pathParams.Copy(),
                authenHandler: c.authenHandler,
                headers:       headers,
                debugWriter:   c.debugWriter,
                resourceGroup: c.resourceGroup,
                queryValues:   qv,
        }</span>
}

// WithDebug enables debug for this SessionClient, outputting to the supplied writer
func (c *client) WithDebug(writer io.Writer) SessionClient <span class="cov8" title="1">{
        c.debugWriter = writer
        return c
}</span>

// WithAuthToken supplies the authentication token to use for all requests made by this session
func (c *client) WithAuthToken(authToken string) SessionClient <span class="cov8" title="1">{
        c.authenHandler = &amp;authenticationHandler{
                authToken: authToken,
        }
        return c
}</span>

// WithPathParameter adds a path parameter to the request
func (c *client) WithPathParameter(name, value string) SessionClient <span class="cov8" title="1">{
        c.pathParams[name] = value
        return c
}</span>

// WithQueryValue adds a query parameter to the request
func (c *client) WithQueryValue(name, value string) SessionClient <span class="cov8" title="1">{
        c.queryValues.Set(name, value)
        return c
}</span>
</pre>
		
		<pre class="file" id="file7" style="display: none">/**
 * Copyright 2021 IBM Corp.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// Package client ...
package client

// Params ...
type Params map[string]string

// Copy performs a shallow copy of a Params object
func (p Params) Copy() Params <span class="cov8" title="1">{
        params := Params{}
        for k, v := range p </span><span class="cov8" title="1">{
                params[k] = v
        }</span>
        <span class="cov8" title="1">return params</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">/**
 * Copyright 2021 IBM Corp.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// Package payload ...
package payload

import (
        "bytes"
        "encoding/json"
        "io"
        "mime/multipart"
)

// JSONBodyProvider ...
type JSONBodyProvider struct{ payload interface{} }

// NewJSONBodyProvider ...
func NewJSONBodyProvider(p interface{}) *JSONBodyProvider <span class="cov8" title="1">{
        return &amp;JSONBodyProvider{payload: p}
}</span>

// ContentType ...
func (p *JSONBodyProvider) ContentType() string <span class="cov8" title="1">{
        return "application/json"
}</span>

// Body ...
func (p *JSONBodyProvider) Body() (io.Reader, error) <span class="cov8" title="1">{
        buf := &amp;bytes.Buffer{}

        err := json.NewEncoder(buf).Encode(p.payload)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return buf, nil</span>
}

// MultipartFileBody ...
type MultipartFileBody struct {
        name            string
        contents        io.Reader
        multipartWriter *multipart.Writer
        pipeReader      *io.PipeReader
        pipeWriter      *io.PipeWriter
}

// NewMultipartFileBody ...
func NewMultipartFileBody(name string, contents io.Reader) *MultipartFileBody <span class="cov8" title="1">{
        pr, pw := io.Pipe()
        return &amp;MultipartFileBody{
                name:            name,
                contents:        contents,
                pipeReader:      pr,
                pipeWriter:      pw,
                multipartWriter: multipart.NewWriter(pw),
        }
}</span>

// ContentType ...
func (p *MultipartFileBody) ContentType() string <span class="cov8" title="1">{
        return p.multipartWriter.FormDataContentType()
}</span>

// Body ...
func (p *MultipartFileBody) Body() (io.Reader, error) <span class="cov8" title="1">{
        go p.copyBody()
        return p.pipeReader, nil
}</span>

func (p *MultipartFileBody) copyBody() <span class="cov0" title="0">{
        defer p.Close()

        fileWriter, err := p.multipartWriter.CreateFormFile(p.name, "image")
        if err != nil </span><span class="cov0" title="0">{
                p.pipeWriter.CloseWithError(err)
        }</span>

        <span class="cov0" title="0">_, err = io.Copy(fileWriter, p.contents)
        if err != nil </span><span class="cov0" title="0">{
                p.pipeWriter.CloseWithError(err)
        }</span>
}

// Close ...
func (p *MultipartFileBody) Close() <span class="cov0" title="0">{
        _ = p.multipartWriter.Close()
        _ = p.pipeWriter.Close()
}</span>
</pre>
		
		<pre class="file" id="file9" style="display: none">/**
 * Copyright 2021 IBM Corp.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// Package payload ...
package payload

import (
        "encoding/json"
        "io"
)

// JSONConsumer ...
type JSONConsumer struct{ receiver interface{} }

// NewJSONConsumer ...
func NewJSONConsumer(receiver interface{}) *JSONConsumer <span class="cov8" title="1">{
        return &amp;JSONConsumer{receiver: receiver}
}</span>

// Consume ...
func (c *JSONConsumer) Consume(reader io.Reader) error <span class="cov8" title="1">{
        decoder := json.NewDecoder(reader)
        return decoder.Decode(c.receiver)
}</span>

// Receiver ...
func (c *JSONConsumer) Receiver() interface{} <span class="cov8" title="1">{
        return c.receiver
}</span>
</pre>
		
		<pre class="file" id="file10" style="display: none">/**
 * Copyright 2021 IBM Corp.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// Package client ...
package client

import (
        "context"
        "fmt"
        "io"
        "net/http"
        "net/http/httputil"
        "net/url"
        "reflect"
        "regexp"
        "strings"
        "time"

        "github.com/IBM/ibmcloud-volume-file-vpc/common/vpcclient/client/payload"
        "github.com/IBM/ibmcloud-volume-file-vpc/common/vpcclient/models"
        "github.com/fatih/structs"
)

// Operation defines the API operation to be invoked
type Operation struct {
        Name        string
        Method      string
        PathPattern string
}

// Request defines the properties of an API request. It can then be invoked to
// call the underlying API specified by the supplied operation
type Request struct {
        httpClient    *http.Client
        baseURL       string
        authenHandler handler

        context context.Context

        operation  *Operation
        pathParams Params
        headers    http.Header

        debugWriter io.Writer

        queryValues     url.Values
        bodyProvider    BodyProvider
        successConsumer ResponseConsumer
        errorConsumer   ResponseConsumer
        resourceGroup   string
}

// BodyProvider declares an interface that describes an HTTP body, for
// both request and response
type BodyProvider interface {
        ContentType() string
        Body() (io.Reader, error)
}

// ResponseConsumer ...
type ResponseConsumer interface {
        Consume(io.Reader) error
        Receiver() interface{}
}

func (r *Request) path() string <span class="cov8" title="1">{
        path := r.operation.PathPattern
        for k, v := range r.pathParams </span><span class="cov8" title="1">{
                path = strings.Replace(path, "{"+k+"}", v, -1)
        }</span>
        <span class="cov8" title="1">return path</span>
}

// URL constructs the full URL for a request
func (r *Request) URL() string <span class="cov8" title="1">{
        baseURL, baseErr := url.Parse(r.baseURL)
        if baseErr != nil </span><span class="cov8" title="1">{
                return ""
        }</span>
        <span class="cov8" title="1">if !strings.HasSuffix(baseURL.Path, "/") </span><span class="cov8" title="1">{
                baseURL.Path += "/"
        }</span>
        <span class="cov8" title="1">pathURL, pathErr := url.Parse(r.path())
        if pathErr != nil </span><span class="cov8" title="1">{
                return ""
        }</span>
        <span class="cov8" title="1">resolvedURL := baseURL.ResolveReference(pathURL)
        resolvedURL.RawQuery = r.queryValues.Encode()

        return resolvedURL.String()</span>
}

// PathParameter sets a path parameter to be resolved on invocation of a request
func (r *Request) PathParameter(name, value string) *Request <span class="cov8" title="1">{
        r.pathParams[name] = value
        return r
}</span>

// AddQueryValue ...
func (r *Request) AddQueryValue(key, value string) *Request <span class="cov8" title="1">{
        if r.queryValues == nil </span><span class="cov8" title="1">{
                r.queryValues = url.Values{}
        }</span>
        <span class="cov8" title="1">r.queryValues.Add(key, value)
        return r</span>
}

// SetQueryValue ...
func (r *Request) SetQueryValue(key, value string) *Request <span class="cov8" title="1">{
        if r.queryValues == nil </span><span class="cov8" title="1">{
                r.queryValues = url.Values{}
        }</span>
        <span class="cov8" title="1">r.queryValues.Set(key, value)
        return r</span>
}

// SetHeader ...
func (r *Request) SetHeader(key, value string) *Request <span class="cov8" title="1">{
        r.headers.Set(key, value)
        return r
}</span>

// JSONBody converts the supplied argument to JSON to use as the body of a request
func (r *Request) JSONBody(p interface{}) *Request <span class="cov8" title="1">{
        if r.operation.Method == http.MethodPost &amp;&amp; reflect.ValueOf(p).Kind() == reflect.Struct </span><span class="cov0" title="0">{
                structs.DefaultTagName = "json"
                m := structs.Map(p)

                if r.resourceGroup != "" </span><span class="cov0" title="0">{
                        m["resourceGroup"] = r.resourceGroup
                }</span>

                <span class="cov0" title="0">r.bodyProvider = payload.NewJSONBodyProvider(m)</span>
        } else<span class="cov8" title="1"> {
                r.bodyProvider = payload.NewJSONBodyProvider(p)
        }</span>
        <span class="cov8" title="1">return r</span>
}

// MultipartFileBody configures the POST payload to be sent in multi-part format. The
// content is read from the supplied Reader.
func (r *Request) MultipartFileBody(name string, contents io.Reader) *Request <span class="cov8" title="1">{
        r.bodyProvider = payload.NewMultipartFileBody(name, contents)
        return r
}</span>

// JSONSuccess configures the receiver to use to process a JSON response
// for a successful (2xx) response
func (r *Request) JSONSuccess(receiver interface{}) *Request <span class="cov8" title="1">{
        r.successConsumer = payload.NewJSONConsumer(receiver)
        return r
}</span>

// JSONError configures the error to populate in the event of an unsuccessful
// (non-2xx) response
func (r *Request) JSONError(receiver error) *Request <span class="cov8" title="1">{
        r.errorConsumer = payload.NewJSONConsumer(receiver)
        return r
}</span>

// Invoke performs the request, and populates the response or error as appropriate
func (r *Request) Invoke() (*http.Response, error) <span class="cov8" title="1">{
        err := r.authenHandler.Before(r)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">var body io.Reader
        if r.bodyProvider != nil </span><span class="cov8" title="1">{
                body, err = r.bodyProvider.Body()
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov8" title="1">if contentType := r.bodyProvider.ContentType(); contentType != "" </span><span class="cov8" title="1">{
                        r.headers.Set("Content-Type", contentType)
                }</span>
        }

        <span class="cov8" title="1">httpRequest, err := http.NewRequest(r.operation.Method, r.URL(), body)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">for k, v := range r.headers </span><span class="cov8" title="1">{
                httpRequest.Header[k] = v
        }</span>

        <span class="cov8" title="1">r.debugRequest(httpRequest)

        resp, err := r.httpClient.Do(httpRequest.WithContext(r.context))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">defer resp.Body.Close()

        r.debugResponse(resp)

        switch </span>{
        case resp.StatusCode == http.StatusNoContent:<span class="cov0" title="0">
                break</span>

        case resp.StatusCode &gt;= 200 &amp;&amp; resp.StatusCode &lt;= 299:<span class="cov8" title="1">
                if r.successConsumer != nil </span><span class="cov8" title="1">{
                        err = r.successConsumer.Consume(resp.Body)
                }</span>

        default:<span class="cov8" title="1">
                if r.errorConsumer != nil </span><span class="cov8" title="1">{
                        err = r.errorConsumer.Consume(resp.Body)
                        if err == nil </span><span class="cov8" title="1">{
                                err = r.errorConsumer.Receiver().(error)
                                apiErr, ok := err.(*models.Error)
                                if ok &amp;&amp; len(apiErr.Errors) &gt; 0 </span><span class="cov8" title="1">{
                                        apiErr.Errors[0].Status = resp.Status
                                }</span>
                        }
                }
        }

        <span class="cov8" title="1">return resp, err</span>
}

func (r *Request) debugRequest(req *http.Request) <span class="cov8" title="1">{
        if r.debugWriter == nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">multipart := strings.Contains(req.Header.Get("Content-Type"), "multipart/form-data")
        dumpedRequest, err := httputil.DumpRequest(req, !multipart)
        if err != nil </span><span class="cov0" title="0">{
                r.debugf("Error dumping request\n%s\n", err)
                return
        }</span>

        <span class="cov8" title="1">r.debugf("\nREQUEST: [%s]\n%s\n", time.Now().Format(time.RFC3339), sanitize(dumpedRequest))
        if multipart </span><span class="cov8" title="1">{
                r.debugf("[MULTIPART/FORM-DATA CONTENT HIDDEN]\n")
        }</span>
}

func (r *Request) debugResponse(resp *http.Response) <span class="cov8" title="1">{
        if r.debugWriter == nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">dumpedResponse, err := httputil.DumpResponse(resp, true)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Fprintf(r.debugWriter, "Error dumping response\n%s\n", err)
                return
        }</span>

        <span class="cov8" title="1">r.debugf("\nRESPONSE: [%s]\n%s\n", time.Now().Format(time.RFC3339), sanitize(dumpedResponse))</span>
}

func (r *Request) debugf(format string, args ...interface{}) <span class="cov8" title="1">{
        fmt.Fprintf(r.debugWriter, format, args...)
}</span>

// RedactedFillin used as a replacement string in debug logs for sensitive data
const RedactedFillin = "[REDACTED]"

func sanitize(input []byte) string <span class="cov8" title="1">{
        sanitized := string(input)

        re := regexp.MustCompile(`(?mi)^Authorization: .*`)
        sanitized = re.ReplaceAllString(sanitized, "Authorization: "+RedactedFillin)

        re = regexp.MustCompile(`(?mi)^X-Auth-Token: .*`)
        sanitized = re.ReplaceAllString(sanitized, "X-Auth-Token: "+RedactedFillin)

        re = regexp.MustCompile(`(?mi)^APIKey: .*`)
        sanitized = re.ReplaceAllString(sanitized, "APIKey: "+RedactedFillin)

        sanitized = sanitizeJSON("key", sanitized)
        sanitized = sanitizeJSON("password", sanitized)
        sanitized = sanitizeJSON("passphrase", sanitized)

        return sanitized
}</span>

func sanitizeJSON(propertySubstring string, json string) string <span class="cov8" title="1">{
        regex := regexp.MustCompile(fmt.Sprintf(`(?i)"([^"]*%s[^"]*)":\s*"[^\,]*"`, propertySubstring))
        return regex.ReplaceAllString(json, fmt.Sprintf(`"$1":"%s"`, RedactedFillin))
}</span>
</pre>
		
		<pre class="file" id="file11" style="display: none">/**
 * Copyright 2021 IBM Corp.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// Package riaas ...
package riaas

import (
        "context"
        "io"
        "net/http"
)

// Config for the Session
type Config struct {
        BaseURL       string
        AccountID     string
        Username      string
        APIKey        string
        ResourceGroup string
        Password      string
        ContextID     string

        DebugWriter   io.Writer
        HTTPClient    *http.Client
        Context       context.Context
        APIVersion    string
        APIGeneration int
}

func (c Config) httpClient() *http.Client <span class="cov8" title="1">{
        if c.HTTPClient != nil </span><span class="cov8" title="1">{
                return c.HTTPClient
        }</span>

        <span class="cov8" title="1">return http.DefaultClient</span>
}

func (c Config) baseURL() string <span class="cov8" title="1">{
        return c.BaseURL
}</span>
</pre>
		
		<pre class="file" id="file12" style="display: none">/**
 * Copyright 2021 IBM Corp.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// Package riaas ...
package riaas

import (
        "context"
        "net/url"
        "strconv"

        "github.com/IBM/ibmcloud-volume-file-vpc/common/vpcclient/client"
        "github.com/IBM/ibmcloud-volume-file-vpc/common/vpcclient/models"
        "github.com/IBM/ibmcloud-volume-file-vpc/common/vpcclient/vpcfilevolume"
)

// RegionalAPI is the main interface for the RIAAS API client. From here, service
// objects for the individual parts of the API can be obtained
//
//go:generate counterfeiter -o fakes/regional_api.go --fake-name RegionalAPI . RegionalAPI
type RegionalAPI interface {
        Login(token string) error

        FileShareService() vpcfilevolume.FileShareManager
}

var _ RegionalAPI = &amp;Session{}

// Session is a base implementation of the RegionalAPI interface
type Session struct {
        client client.SessionClient
        config Config
}

// New creates a new Session volume, using the supplied config
func New(config Config) (*Session, error) <span class="cov8" title="1">{
        ctx := config.Context
        if ctx == nil </span><span class="cov8" title="1">{
                ctx = context.Background()
        }</span>

        // Default API version
        <span class="cov8" title="1">backendAPIVersion := models.APIVersion

        // Overwrite if the version is passed
        if len(config.APIVersion) &gt; 0 </span><span class="cov8" title="1">{
                backendAPIVersion = config.APIVersion
        }</span>

        // Overwrite if the generation is passed
        <span class="cov8" title="1">apiGen := models.APIGeneration
        if config.APIGeneration &gt; 0 </span><span class="cov8" title="1">{
                apiGen = config.APIGeneration
        }</span>

        <span class="cov8" title="1">queryValues := url.Values{
                "version":    []string{backendAPIVersion},
                "generation": []string{strconv.Itoa(apiGen)},
        }

        riaasClient := client.New(ctx, config.baseURL(), queryValues, config.httpClient(), config.ContextID, config.ResourceGroup)

        if config.DebugWriter != nil </span><span class="cov8" title="1">{
                riaasClient.WithDebug(config.DebugWriter)
        }</span>
        <span class="cov8" title="1">return &amp;Session{
                client: riaasClient,
                config: config,
        }, nil</span>
}

// Login configures the session with the supplied Authentication token
// which is used for all requests to the API
func (s *Session) Login(token string) error <span class="cov8" title="1">{
        s.client.WithAuthToken(token)
        return nil
}</span>

// VolumeFileService returns the Volume service for managing file volumes
func (s *Session) FileShareService() vpcfilevolume.FileShareManager <span class="cov8" title="1">{
        return vpcfilevolume.New(s.client)
}</span>

// RegionalAPIClientProvider declares an interface for a provider that can supply a new
// RegionalAPI client session
//
//go:generate counterfeiter -o fakes/client_provider.go --fake-name RegionalAPIClientProvider . RegionalAPIClientProvider
type RegionalAPIClientProvider interface {
        New(config Config) (RegionalAPI, error)
}

// DefaultRegionalAPIClientProvider declares a basic client provider that delegates to
// New(). Can be used for dependency injection.
type DefaultRegionalAPIClientProvider struct {
}

var _ RegionalAPIClientProvider = DefaultRegionalAPIClientProvider{}

// New creates a new Session volume, using the supplied config
func (d DefaultRegionalAPIClientProvider) New(config Config) (RegionalAPI, error) <span class="cov8" title="1">{
        return New(config)
}</span>

// IKSSession ...
type IKSSession struct {
        Session
}

var _ RegionalAPI = &amp;IKSSession{}

// FileShareService returns the FileShare service for managing shares
func (s *IKSSession) FileShareService() vpcfilevolume.FileShareManager <span class="cov8" title="1">{
        return vpcfilevolume.NewIKSVolumeService(s.client)
}</span>

// IKSRegionalAPIClientProvider ...
type IKSRegionalAPIClientProvider struct {
        RegionalAPIClientProvider
}

var _ RegionalAPIClientProvider = IKSRegionalAPIClientProvider{}

// New creates a new Session , using the supplied config
func (d IKSRegionalAPIClientProvider) New(config Config) (RegionalAPI, error) <span class="cov8" title="1">{
        session, err := New(config)
        if err != nil || session == nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">iksSession := &amp;IKSSession{
                Session: *session,
        }
        return iksSession, err</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">/**
 * Copyright 2021 IBM Corp.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// Package vpcfilevolume ...
package vpcfilevolume

import (
        "time"

        "github.com/IBM/ibmcloud-volume-file-vpc/common/vpcclient/client"
        "github.com/IBM/ibmcloud-volume-file-vpc/common/vpcclient/models"
        util "github.com/IBM/ibmcloud-volume-interface/lib/utils"
        "go.uber.org/zap"
)

// CreateFileShare POSTs to v1/shares
func (vs *FileShareService) CreateFileShare(shareTemplate *models.Share, ctxLogger *zap.Logger) (*models.Share, error) <span class="cov8" title="1">{
        ctxLogger.Debug("Entry Backend CreateFileShare")
        defer ctxLogger.Debug("Exit Backend CreateFileShare")

        defer util.TimeTracker("CreateFileShare", time.Now())

        operation := &amp;client.Operation{
                Name:        "CreateFileShare",
                Method:      "POST",
                PathPattern: sharesPath,
        }

        var share models.Share
        var apiErr models.Error
        var request *client.Request

        //Revert this code once RFS is LA/GA from VPC IAAS side
        if shareTemplate.Profile != nil &amp;&amp; shareTemplate.Profile.Name == RFSProfile </span><span class="cov0" title="0">{
                request = vs.client.WithQueryValue("maturity", "beta").NewRequest(operation)
        }</span> else<span class="cov8" title="1"> {
                request = vs.client.NewRequest(operation)
        }</span>

        <span class="cov8" title="1">ctxLogger.Info("Equivalent curl command and payload details", zap.Reflect("URL", request.URL()), zap.Reflect("Payload", shareTemplate), zap.Reflect("Operation", operation))

        _, err := request.JSONBody(shareTemplate).JSONSuccess(&amp;share).JSONError(&amp;apiErr).Invoke()
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return &amp;share, nil</span>
}
</pre>
		
		<pre class="file" id="file14" style="display: none">/**
 * Copyright 2021 IBM Corp.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// Package instances ...
package vpcfilevolume

import (
        "time"

        "github.com/IBM/ibmcloud-volume-file-vpc/common/vpcclient/client"
        "github.com/IBM/ibmcloud-volume-file-vpc/common/vpcclient/models"
        "github.com/IBM/ibmcloud-volume-interface/lib/metrics"
        util "github.com/IBM/ibmcloud-volume-interface/lib/utils"
        "go.uber.org/zap"
)

// CreateFileShareTarget POSTs to /shares/{share-id}/target
// creates file share target with given share target details
func (vs *FileShareService) CreateFileShareTarget(fileShareTargetRequest *models.ShareTarget, ctxLogger *zap.Logger) (*models.ShareTarget, error) <span class="cov8" title="1">{
        methodName := "FileShareService.CreateFileShareTarget"
        defer util.TimeTracker(methodName, time.Now())
        defer metrics.UpdateDurationFromStart(ctxLogger, methodName, time.Now())

        operation := &amp;client.Operation{
                Name:        "CreateFileShareTarget",
                Method:      "POST",
                PathPattern: shareIDPath + shareTargetsPath,
        }

        var shareTarget models.ShareTarget
        var apiErr models.Error

        request := vs.client.NewRequest(operation)

        ctxLogger.Info("Equivalent curl command and payload details", zap.Reflect("URL", request.URL()), zap.Reflect("Payload", fileShareTargetRequest), zap.Reflect("Operation", operation), zap.Reflect("PathParameters", fileShareTargetRequest.ShareID))

        req := request.PathParameter(shareIDParam, fileShareTargetRequest.ShareID)

        _, err := req.JSONBody(fileShareTargetRequest).JSONSuccess(&amp;shareTarget).JSONError(&amp;apiErr).Invoke()
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">ctxLogger.Info("Successfully created the file share target")
        return &amp;shareTarget, nil</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">/**
 * Copyright 2021 IBM Corp.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// Package vpcfilevolume ...
package vpcfilevolume

import (
        "time"

        "github.com/IBM/ibmcloud-volume-file-vpc/common/vpcclient/client"
        "github.com/IBM/ibmcloud-volume-file-vpc/common/vpcclient/models"
        util "github.com/IBM/ibmcloud-volume-interface/lib/utils"
        "go.uber.org/zap"
)

// DeleteFileShare DELETEs to /shares/{share-id}
func (vs *FileShareService) DeleteFileShare(shareID string, ctxLogger *zap.Logger) error <span class="cov8" title="1">{
        ctxLogger.Debug("Entry Backend DeleteFileShare")
        defer ctxLogger.Debug("Exit Backend DeleteFileShare")

        defer util.TimeTracker("DeleteVolume", time.Now())

        operation := &amp;client.Operation{
                Name:        "DeleteFileShare",
                Method:      "DELETE",
                PathPattern: shareIDPath,
        }

        var apiErr models.Error

        request := vs.client.NewRequest(operation)
        ctxLogger.Info("Equivalent curl command", zap.Reflect("URL", request.URL()), zap.Reflect("Operation", operation))

        _, err := request.PathParameter(shareIDParam, shareID).JSONError(&amp;apiErr).Invoke()
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file16" style="display: none">/**
 * Copyright 2021 IBM Corp.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// Package vpcfilevolume ...
package vpcfilevolume

import (
        "net/http"
        "time"

        "github.com/IBM/ibmcloud-volume-file-vpc/common/vpcclient/client"
        "github.com/IBM/ibmcloud-volume-file-vpc/common/vpcclient/models"
        util "github.com/IBM/ibmcloud-volume-interface/lib/utils"
        "go.uber.org/zap"
)

// DeleteFileShareTarget DELETE to /shares/{share-id}/target/{target-id}
func (vs *FileShareService) DeleteFileShareTarget(deleteShareTargetRequest *models.ShareTarget, ctxLogger *zap.Logger) (*http.Response, error) <span class="cov8" title="1">{
        ctxLogger.Debug("Entry Backend DeleteFileShareTarget")
        defer ctxLogger.Debug("Exit Backend DeleteFileShareTarget")

        defer util.TimeTracker("DeleteFileShareTarget", time.Now())

        operation := &amp;client.Operation{
                Name:        "DeleteFileShareTarget",
                Method:      "DELETE",
                PathPattern: shareIDPath + shareTargetIDPath,
        }

        var apiErr models.Error

        request := vs.client.NewRequest(operation)
        ctxLogger.Info("Equivalent curl command", zap.Reflect("URL", request.URL()), zap.Reflect("Operation", operation))

        resp, err := request.PathParameter(shareIDParam, deleteShareTargetRequest.ShareID).PathParameter(shareTargetIDParam, deleteShareTargetRequest.ID).JSONError(&amp;apiErr).Invoke()
        if err != nil </span><span class="cov8" title="1">{
                ctxLogger.Error("Error occurred while deleting file share target", zap.Error(err))
                if resp != nil &amp;&amp; resp.StatusCode == http.StatusNotFound </span><span class="cov8" title="1">{
                        // file share target is deleted. So do not want to retry
                        ctxLogger.Info("Exit DeleteFileShareTarget", zap.Any("resp", resp.StatusCode), zap.Error(err), zap.Error(apiErr))
                        return resp, apiErr
                }</span>
        }
        <span class="cov8" title="1">ctxLogger.Info("DeleteFileShareTarget successfull")
        return resp, nil</span>
}
</pre>
		
		<pre class="file" id="file17" style="display: none">/**
 * Copyright 2022 IBM Corp.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// Package vpcfilevolume ...
package vpcfilevolume

import (
        "time"

        "github.com/IBM/ibmcloud-volume-file-vpc/common/vpcclient/client"
        "github.com/IBM/ibmcloud-volume-file-vpc/common/vpcclient/models"
        util "github.com/IBM/ibmcloud-volume-interface/lib/utils"
        "go.uber.org/zap"
)

// ExpandVolume PATCH to /volumes
func (vs *FileShareService) ExpandVolume(shareID string, volumeTemplate *models.Share, ctxLogger *zap.Logger) (*models.Share, error) <span class="cov8" title="1">{
        ctxLogger.Debug("Entry Backend ExpandVolume")
        defer ctxLogger.Debug("Exit Backend ExpandVolume")

        defer util.TimeTracker("ExpandVolume", time.Now())

        operation := &amp;client.Operation{
                Name:        "ExpandVolume",
                Method:      "PATCH",
                PathPattern: shareIDPath,
        }

        var share models.Share
        var apiErr models.Error

        request := vs.client.NewRequest(operation)
        req := request.PathParameter(shareIDParam, shareID)
        ctxLogger.Info("Equivalent curl command and payload details", zap.Reflect("URL", req.URL()), zap.Reflect("Payload", volumeTemplate), zap.Reflect("Operation", operation))
        _, err := req.JSONBody(volumeTemplate).JSONSuccess(&amp;share).JSONError(&amp;apiErr).Invoke()
        if err != nil </span><span class="cov8" title="1">{
                ctxLogger.Info("Exit Backend ExpandVolume due to error.", zap.Reflect("Error: ", err))
                return nil, err
        }</span>

        <span class="cov8" title="1">return &amp;share, nil</span>
}
</pre>
		
		<pre class="file" id="file18" style="display: none">/**
 * Copyright 2021 IBM Corp.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// Package vpcfilevolume ...
package vpcfilevolume

import (
        "net/http"

        "github.com/IBM/ibmcloud-volume-file-vpc/common/vpcclient/client"
        "github.com/IBM/ibmcloud-volume-file-vpc/common/vpcclient/models"
        "github.com/IBM/ibmcloud-volume-interface/lib/provider"
        "go.uber.org/zap"
)

// FileShareManager operations
//
//go:generate counterfeiter -o fakes/share.go --fake-name FileShareService . FileShareManager
type FileShareManager interface {

        // Get the share profile by using profile name
        GetShareProfile(profileName string, ctxLogger *zap.Logger) (*models.ProfileDetails, error)

        // Create the file share with authorisation by passing required information in the share object
        CreateFileShare(volumeTemplate *models.Share, ctxLogger *zap.Logger) (*models.Share, error)

        // UpdateVolume updates the volume with authorisation by passing required information in the volume object
        UpdateVolume(pvcTemplate *provider.UpdatePVC, ctxLogger *zap.Logger) error

        // Get all file shares lists by using filter options
        ListFileShares(limit int, start string, filters *models.ListShareFilters, ctxLogger *zap.Logger) (*models.ShareList, error)

        // Get the file share by using ID
        GetFileShare(shareID string, ctxLogger *zap.Logger) (*models.Share, error)

        // Get the file share by using share name
        GetFileShareByName(shareName string, ctxLogger *zap.Logger) (*models.Share, error)

        // Get the file share etag by using ID
        GetFileShareEtag(shareID string, ctxLogger *zap.Logger) (*models.Share, string, error)

        // UpdateFileShareWithEtag updates the shares with tags by passing etag in header
        UpdateFileShareWithEtag(shareID string, etag string, shareTemplate *models.Share, ctxLogger *zap.Logger) error

        // Delete the file share
        DeleteFileShare(shareID string, ctxLogger *zap.Logger) error

        //CreateFileShareTarget creates file share target
        CreateFileShareTarget(shareTargetRequest *models.ShareTarget, ctxLogger *zap.Logger) (*models.ShareTarget, error)

        // Get file share target lists by using share ID
        ListFileShareTargets(shareID string, filters *models.ListShareTargetFilters, ctxLogger *zap.Logger) (*models.ShareTargetList, error)

        // Get the file share target by using share ID and target ID
        GetFileShareTarget(shareID string, targetID string, ctxLogger *zap.Logger) (*models.ShareTarget, error)

        // Get the file share by using share ID and target name
        GetFileShareTargetByName(targetName string, shareID string, ctxLogger *zap.Logger) (*models.ShareTarget, error)

        // DeleteFileShareTarget delete the share target by share ID and target ID/VPC ID/Subnet ID
        DeleteFileShareTarget(shareTargetDeleteRequest *models.ShareTarget, ctxLogger *zap.Logger) (*http.Response, error)

        // ExpandVolume expand the share by share ID and target
        ExpandVolume(shareID string, shareTemplate *models.Share, ctxLogger *zap.Logger) (*models.Share, error)

        // Get all subnets by using filter options
        ListSubnets(limit int, start string, filters *models.ListSubnetFilters, ctxLogger *zap.Logger) (*models.SubnetList, error)

        // Get all securityGroups by using filter options
        ListSecurityGroups(limit int, start string, filters *models.ListSecurityGroupFilters, ctxLogger *zap.Logger) (*models.SecurityGroupList, error)
}

// FileShareService ...
type FileShareService struct {
        client client.SessionClient
}

var _ FileShareManager = &amp;FileShareService{}

// New ...
func New(client client.SessionClient) FileShareManager <span class="cov8" title="1">{
        return &amp;FileShareService{
                client: client,
        }
}</span>
</pre>
		
		<pre class="file" id="file19" style="display: none">/**
 * Copyright 2021 IBM Corp.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// Package vpcfilevolume ...
package vpcfilevolume

import (
        "time"

        "github.com/IBM/ibmcloud-volume-file-vpc/common/vpcclient/client"
        "github.com/IBM/ibmcloud-volume-file-vpc/common/vpcclient/models"
        util "github.com/IBM/ibmcloud-volume-interface/lib/utils"
        "go.uber.org/zap"
)

// GetFileShare POSTs to /shares/{share-id}
func (vs *FileShareService) GetFileShare(shareID string, ctxLogger *zap.Logger) (*models.Share, error) <span class="cov8" title="1">{
        ctxLogger.Debug("Entry Backend GetFileShare")
        defer ctxLogger.Debug("Exit Backend GetFileShare")

        defer util.TimeTracker("GetFileShare", time.Now())

        operation := &amp;client.Operation{
                Name:        "GetFileShare",
                Method:      "GET",
                PathPattern: shareIDPath,
        }

        var share models.Share
        var apiErr models.Error

        request := vs.client.NewRequest(operation)
        ctxLogger.Info("Equivalent curl command", zap.Reflect("URL", request.URL()), zap.Reflect("Operation", operation))

        req := request.PathParameter(shareIDParam, shareID)
        _, err := req.JSONSuccess(&amp;share).JSONError(&amp;apiErr).Invoke()
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return &amp;share, nil</span>
}

// GetFileShareByName GETs /shares
func (vs *FileShareService) GetFileShareByName(shareName string, ctxLogger *zap.Logger) (*models.Share, error) <span class="cov8" title="1">{
        ctxLogger.Debug("Entry Backend GetFileShareByName")
        defer ctxLogger.Debug("Exit Backend GetFileShareByName")

        defer util.TimeTracker("GetFileShareByName", time.Now())

        // Get the file share details for a single file share, ListFileShareFilters will return only 1 file share in list
        filters := &amp;models.ListShareFilters{ShareName: shareName}
        shares, err := vs.ListFileShares(1, "", filters, ctxLogger)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">if shares != nil </span><span class="cov8" title="1">{
                shareslist := shares.Shares
                if len(shareslist) &gt; 0 </span><span class="cov8" title="1">{
                        return shareslist[0], nil
                }</span>
        }
        <span class="cov8" title="1">return nil, err</span>
}
</pre>
		
		<pre class="file" id="file20" style="display: none">/**
 * Copyright 2025 IBM Corp.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// Package vpcfilevolume ...
package vpcfilevolume

import (
        "time"

        "github.com/IBM/ibmcloud-volume-file-vpc/common/vpcclient/client"
        "github.com/IBM/ibmcloud-volume-file-vpc/common/vpcclient/models"
        util "github.com/IBM/ibmcloud-volume-interface/lib/utils"
        "go.uber.org/zap"
)

// GetFileShare GET to /shares/{share-id}
func (vs *FileShareService) GetFileShareEtag(shareID string, ctxLogger *zap.Logger) (*models.Share, string, error) <span class="cov8" title="1">{
        ctxLogger.Debug("Entry Backend GetFileShareEtag")
        defer ctxLogger.Debug("Exit Backend GetFileShareEtag")

        defer util.TimeTracker("GetFileShareEtag", time.Now())

        operation := &amp;client.Operation{
                Name:        "GetFileShareEtag",
                Method:      "GET",
                PathPattern: shareIDPath,
        }

        var share models.Share
        var apiErr models.Error

        request := vs.client.NewRequest(operation)
        ctxLogger.Info("Equivalent curl command", zap.Reflect("URL", request.URL()), zap.Reflect("Operation", operation))

        req := request.PathParameter(shareIDParam, shareID)
        resp, err := req.JSONSuccess(&amp;share).JSONError(&amp;apiErr).Invoke()
        if err != nil </span><span class="cov8" title="1">{
                return nil, "", err
        }</span>

        <span class="cov8" title="1">return &amp;share, resp.Header.Get("etag"), nil</span>
}
</pre>
		
		<pre class="file" id="file21" style="display: none">/**
 * Copyright 2021 IBM Corp.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// Package vpcfilevolume ...
package vpcfilevolume

import (
        "time"

        "github.com/IBM/ibmcloud-volume-file-vpc/common/vpcclient/client"
        "github.com/IBM/ibmcloud-volume-file-vpc/common/vpcclient/models"
        util "github.com/IBM/ibmcloud-volume-interface/lib/utils"
        "go.uber.org/zap"
)

// GetFileShareTarget GETs to /shares/{share-id}/mount_targets/{target-id}
func (vs *FileShareService) GetFileShareTarget(shareID string, targetID string, ctxLogger *zap.Logger) (*models.ShareTarget, error) <span class="cov8" title="1">{
        ctxLogger.Debug("Entry Backend GetFileShareTarget")
        defer ctxLogger.Debug("Exit Backend GetFileShareTarget")

        defer util.TimeTracker("GetFileShareTarget", time.Now())

        operation := &amp;client.Operation{
                Name:        "GetFileShareTarget",
                Method:      "GET",
                PathPattern: shareIDPath + shareTargetIDPath,
        }

        var shareTarget models.ShareTarget
        var apiErr models.Error

        request := vs.client.NewRequest(operation)
        ctxLogger.Info("Equivalent curl command", zap.Reflect("URL", request.URL()), zap.Reflect("Operation", operation))

        req := request.PathParameter(shareIDParam, shareID).PathParameter(shareTargetIDParam, targetID)

        _, err := req.JSONSuccess(&amp;shareTarget).JSONError(&amp;apiErr).Invoke()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return &amp;shareTarget, nil</span>
}

// GetFileShareTargetByName GETs /shares/{share-id}/mount_targets by target name
func (vs *FileShareService) GetFileShareTargetByName(shareID string, targetName string, ctxLogger *zap.Logger) (*models.ShareTarget, error) <span class="cov8" title="1">{
        ctxLogger.Debug("Entry Backend GetFileShareTargetByName")
        defer ctxLogger.Debug("Exit Backend GetFileShareTargetByName")

        defer util.TimeTracker("GetFileShareTargetByName", time.Now())

        // Get the file share target details for a single share target, ListFileShareTargets will return only 1 share target in list
        filters := &amp;models.ListShareTargetFilters{ShareTargetName: targetName}
        targets, err := vs.ListFileShareTargets(targetName, filters, ctxLogger)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">if targets != nil </span><span class="cov8" title="1">{
                targetslist := targets.ShareTargets
                if len(targetslist) &gt; 0 </span><span class="cov8" title="1">{
                        return targetslist[0], nil
                }</span>
        }
        <span class="cov8" title="1">return nil, err</span>
}
</pre>
		
		<pre class="file" id="file22" style="display: none">/**
 * Copyright 2025 IBM Corp.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// Package vpcfilevolume ...
package vpcfilevolume

import (
        "time"

        "github.com/IBM/ibmcloud-volume-file-vpc/common/vpcclient/client"
        "github.com/IBM/ibmcloud-volume-file-vpc/common/vpcclient/models"
        util "github.com/IBM/ibmcloud-volume-interface/lib/utils"
        "go.uber.org/zap"
)

// GetShareProfile GET to /shares/profiles/{profile-name}
func (vs *FileShareService) GetShareProfile(name string, ctxLogger *zap.Logger) (*models.ProfileDetails, error) <span class="cov8" title="1">{
        ctxLogger.Debug("Entry GetShareProfile")
        defer ctxLogger.Debug("Exit GetShareProfile")

        defer util.TimeTracker("GetShareProfile", time.Now())

        operation := &amp;client.Operation{
                Name:        "GetShareProfile",
                Method:      "GET",
                PathPattern: shareProfileName,
        }

        var profile models.ProfileDetails
        var apiErr models.Error

        request := vs.client.NewRequest(operation)
        ctxLogger.Info("Equivalent curl command", zap.Reflect("URL", request.URL()), zap.Reflect("Operation", operation))

        req := request.PathParameter(profileName, name)
        _, err := req.JSONSuccess(&amp;profile).JSONError(&amp;apiErr).Invoke()
        if err != nil </span><span class="cov8" title="1">{
                ctxLogger.Error("Error fetching profile.", zap.Reflect("profileName: ", name), zap.Reflect("Error: ", err))
                return nil, err
        }</span>

        <span class="cov8" title="1">ctxLogger.Info("Profile details", zap.Reflect("profile", profile))
        return &amp;profile, nil</span>
}
</pre>
		
		<pre class="file" id="file23" style="display: none">/**
 * Copyright 2024 IBM Corp.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// Package vpcvolume ...
package vpcfilevolume

import (
        "time"

        "github.com/IBM/ibmcloud-volume-file-vpc/common/vpcclient/client"
        "github.com/IBM/ibmcloud-volume-interface/lib/provider"
        util "github.com/IBM/ibmcloud-volume-interface/lib/utils"
        "go.uber.org/zap"
)

// UpdateVolume POSTs to /v2/storage/updateVolume
func (vs *IKSVolumeService) UpdateVolume(pvcTemplate *provider.UpdatePVC, ctxLogger *zap.Logger) error <span class="cov8" title="1">{
        ctxLogger.Debug("Entry Backend IKSVolumeService.UpdateVolume")
        defer ctxLogger.Debug("Exit Backend IKSVolumeService.UpdateVolume")

        defer util.TimeTracker("IKSVolumeService.UpdateVolume", time.Now())

        operation := &amp;client.Operation{
                Name:        "UpdateVolume",
                Method:      "POST",
                PathPattern: vs.pathPrefix + updateVolume,
        }
        apiErr := vs.receiverError
        request := vs.client.NewRequest(operation)
        ctxLogger.Info("Equivalent curl command", zap.Reflect("URL", request.URL()), zap.Reflect("Operation", operation), zap.Reflect("pvcTemplate", pvcTemplate))

        _, err := request.JSONBody(pvcTemplate).JSONError(apiErr).Invoke()
        if err != nil </span><span class="cov8" title="1">{
                ctxLogger.Error("Update volume failed with error", zap.Error(err), zap.Error(apiErr))
        }</span>
        <span class="cov8" title="1">return err</span>
}
</pre>
		
		<pre class="file" id="file24" style="display: none">/**
 * Copyright 2024 IBM Corp.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// Package vpcvolume ...
package vpcfilevolume

import (
        "github.com/IBM/ibmcloud-volume-file-vpc/common/vpcclient/client"
        "github.com/IBM/ibmcloud-volume-file-vpc/common/vpcclient/models"
)

const (
        //IksV2PathPrefix ...
        IksV2PathPrefix = "v2/storage/"
)

// IKSVolumeService ...
type IKSVolumeService struct {
        FileShareService
        pathPrefix    string
        receiverError error
}

var _ FileShareManager = &amp;IKSVolumeService{}

// NewIKSVolumeService ...
func NewIKSVolumeService(client client.SessionClient) FileShareManager <span class="cov8" title="1">{
        err := models.IksError{}
        iksVolumeService := &amp;IKSVolumeService{
                FileShareService: FileShareService{
                        client: client,
                },
                pathPrefix:    IksV2PathPrefix,
                receiverError: &amp;err,
        }
        return iksVolumeService
}</span>
</pre>
		
		<pre class="file" id="file25" style="display: none">/**
 * Copyright 2021 IBM Corp.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// Package vpcfilevolume ...
package vpcfilevolume

import (
        "time"

        "github.com/IBM/ibmcloud-volume-file-vpc/common/vpcclient/client"
        "github.com/IBM/ibmcloud-volume-file-vpc/common/vpcclient/models"
        util "github.com/IBM/ibmcloud-volume-interface/lib/utils"
        "go.uber.org/zap"
)

// ListFileShareTargets GETs /shares/{share-id}/mount_targets
func (vs *FileShareService) ListFileShareTargets(shareID string, filters *models.ListShareTargetFilters, ctxLogger *zap.Logger) (*models.ShareTargetList, error) <span class="cov8" title="1">{
        ctxLogger.Debug("Entry Backend ListFileShareTargets")
        defer ctxLogger.Debug("Exit Backend ListFileShareTargets")

        defer util.TimeTracker("ListFileShareTargets", time.Now())

        operation := &amp;client.Operation{
                Name:        "ListFileShareTargets",
                Method:      "GET",
                PathPattern: shareIDPath + shareTargetsPath,
        }

        var targets models.ShareTargetList
        var apiErr models.Error

        request := vs.client.NewRequest(operation)
        ctxLogger.Info("Equivalent curl command", zap.Reflect("URL", request.URL()), zap.Reflect("Operation", operation))

        req := request.PathParameter(shareIDParam, shareID)

        req = req.JSONSuccess(&amp;targets).JSONError(&amp;apiErr)

        if filters != nil </span><span class="cov8" title="1">{
                if filters.ShareTargetName != "" </span><span class="cov8" title="1">{
                        req.AddQueryValue("name", filters.ShareTargetName)
                }</span>
        }

        <span class="cov8" title="1">_, err := req.Invoke()
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return &amp;targets, nil</span>
}
</pre>
		
		<pre class="file" id="file26" style="display: none">/**
 * Copyright 2021 IBM Corp.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// Package vpcfilevolume ...
package vpcfilevolume

import (
        "strconv"
        "time"

        "github.com/IBM/ibmcloud-volume-file-vpc/common/vpcclient/client"
        "github.com/IBM/ibmcloud-volume-file-vpc/common/vpcclient/models"
        util "github.com/IBM/ibmcloud-volume-interface/lib/utils"
        "go.uber.org/zap"
)

// ListFileShares GETs /shares
func (vs *FileShareService) ListFileShares(limit int, start string, filters *models.ListShareFilters, ctxLogger *zap.Logger) (*models.ShareList, error) <span class="cov8" title="1">{
        ctxLogger.Debug("Entry Backend ListFileShares")
        defer ctxLogger.Debug("Exit Backend ListFileShares")

        defer util.TimeTracker("ListFileShares", time.Now())

        operation := &amp;client.Operation{
                Name:        "ListFileShares",
                Method:      "GET",
                PathPattern: sharesPath,
        }

        var shares models.ShareList
        var apiErr models.Error

        request := vs.client.NewRequest(operation)
        ctxLogger.Info("Equivalent curl command", zap.Reflect("URL", request.URL()), zap.Reflect("Operation", operation))

        req := request.JSONSuccess(&amp;shares).JSONError(&amp;apiErr)

        if limit &gt; 0 </span><span class="cov8" title="1">{
                req.AddQueryValue("limit", strconv.Itoa(limit))
        }</span>

        <span class="cov8" title="1">if start != "" </span><span class="cov8" title="1">{
                req.AddQueryValue("start", start)
        }</span>

        <span class="cov8" title="1">if filters != nil </span><span class="cov8" title="1">{
                if filters.ResourceGroupID != "" </span><span class="cov8" title="1">{
                        req.AddQueryValue("resource_group.id", filters.ResourceGroupID)
                }</span>
                <span class="cov8" title="1">if filters.ShareName != "" </span><span class="cov8" title="1">{
                        req.AddQueryValue("name", filters.ShareName)
                }</span>
        }

        <span class="cov8" title="1">_, err := req.Invoke()
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return &amp;shares, nil</span>
}
</pre>
		
		<pre class="file" id="file27" style="display: none">/**
 * Copyright 2023 IBM Corp.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// Package vpcfilevolume ...
package vpcfilevolume

import (
        "strconv"
        "time"

        "github.com/IBM/ibmcloud-volume-file-vpc/common/vpcclient/client"
        "github.com/IBM/ibmcloud-volume-file-vpc/common/vpcclient/models"
        util "github.com/IBM/ibmcloud-volume-interface/lib/utils"
        "go.uber.org/zap"
)

// ListSecurityGroups GETs /security_groups
func (vs *FileShareService) ListSecurityGroups(limit int, start string, filters *models.ListSecurityGroupFilters, ctxLogger *zap.Logger) (*models.SecurityGroupList, error) <span class="cov8" title="1">{
        ctxLogger.Debug("Entry Backend ListSecurityGroups")
        defer ctxLogger.Debug("Exit Backend ListSecurityGroups")

        defer util.TimeTracker("ListSecurityGroups", time.Now())

        operation := &amp;client.Operation{
                Name:        "ListSecurityGroups",
                Method:      "GET",
                PathPattern: securityGroups,
        }

        var securityGroups models.SecurityGroupList
        var apiErr models.Error

        request := vs.client.NewRequest(operation)
        ctxLogger.Info("Equivalent curl command", zap.Reflect("URL", request.URL()), zap.Reflect("Operation", operation))

        req := request.JSONSuccess(&amp;securityGroups).JSONError(&amp;apiErr)

        if limit &gt; 0 </span><span class="cov8" title="1">{
                req.AddQueryValue("limit", strconv.Itoa(limit))
        }</span>

        <span class="cov8" title="1">if start != "" </span><span class="cov8" title="1">{
                req.AddQueryValue("start", start)
        }</span>

        <span class="cov8" title="1">if filters != nil </span><span class="cov8" title="1">{
                if filters.ResourceGroupID != "" </span><span class="cov8" title="1">{
                        req.AddQueryValue("resource_group.id", filters.ResourceGroupID)
                }</span>
                <span class="cov8" title="1">if filters.VPCID != "" </span><span class="cov8" title="1">{
                        req.AddQueryValue("vpc.id", filters.VPCID)
                }</span>
        }

        <span class="cov8" title="1">ctxLogger.Info("Equivalent curl command", zap.Reflect("URL", req.URL()))

        _, err := req.Invoke()
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return &amp;securityGroups, nil</span>
}
</pre>
		
		<pre class="file" id="file28" style="display: none">/**
 * Copyright 2023 IBM Corp.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// Package vpcfilevolume ...
package vpcfilevolume

import (
        "strconv"
        "time"

        "github.com/IBM/ibmcloud-volume-file-vpc/common/vpcclient/client"
        "github.com/IBM/ibmcloud-volume-file-vpc/common/vpcclient/models"
        util "github.com/IBM/ibmcloud-volume-interface/lib/utils"
        "go.uber.org/zap"
)

// ListSubnets GETs /subnets
func (vs *FileShareService) ListSubnets(limit int, start string, filters *models.ListSubnetFilters, ctxLogger *zap.Logger) (*models.SubnetList, error) <span class="cov8" title="1">{
        ctxLogger.Debug("Entry Backend ListSubnets")
        defer ctxLogger.Debug("Exit Backend ListSubnets")

        defer util.TimeTracker("ListSubnets", time.Now())

        operation := &amp;client.Operation{
                Name:        "ListSubnets",
                Method:      "GET",
                PathPattern: subnets,
        }

        var subnets models.SubnetList
        var apiErr models.Error

        request := vs.client.NewRequest(operation)

        req := request.JSONSuccess(&amp;subnets).JSONError(&amp;apiErr)

        if limit &gt; 0 </span><span class="cov8" title="1">{
                req.AddQueryValue("limit", strconv.Itoa(limit))
        }</span>

        <span class="cov8" title="1">if start != "" </span><span class="cov8" title="1">{
                req.AddQueryValue("start", start)
        }</span>

        <span class="cov8" title="1">if filters != nil </span><span class="cov8" title="1">{
                if filters.ResourceGroupID != "" </span><span class="cov8" title="1">{
                        req.AddQueryValue("resource_group.id", filters.ResourceGroupID)
                }</span>
                <span class="cov8" title="1">if filters.VPCID != "" </span><span class="cov8" title="1">{
                        req.AddQueryValue("vpc.id", filters.VPCID)
                }</span>
                <span class="cov8" title="1">if filters.ZoneName != "" </span><span class="cov8" title="1">{
                        req.AddQueryValue("zone.name", filters.ZoneName)
                }</span>
        }

        <span class="cov8" title="1">ctxLogger.Info("Equivalent curl command", zap.Reflect("URL", req.URL()))

        _, err := req.Invoke()
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return &amp;subnets, nil</span>
}
</pre>
		
		<pre class="file" id="file29" style="display: none">/**
 * Copyright 2025 IBM Corp.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// Package vpcvolume ...
package vpcfilevolume

import (
        "time"

        "github.com/IBM/ibmcloud-volume-file-vpc/common/vpcclient/client"
        "github.com/IBM/ibmcloud-volume-file-vpc/common/vpcclient/models"
        util "github.com/IBM/ibmcloud-volume-interface/lib/utils"
        "go.uber.org/zap"
)

// UpdateVolume PATCH to /shares for updating user tags only
func (vs *FileShareService) UpdateFileShareWithEtag(shareID string, etag string, shareTemplate *models.Share, ctxLogger *zap.Logger) error <span class="cov8" title="1">{
        ctxLogger.Debug("Entry Backend UpdateVolumeWithEtag")
        defer ctxLogger.Debug("Exit Backend UpdateVolumeWithEtag")

        defer util.TimeTracker("UpdateVolumeWithEtag", time.Now())

        operation := &amp;client.Operation{
                Name:        "UpdateFileShare",
                Method:      "PATCH",
                PathPattern: shareIDPath,
        }

        var apiErr models.Error

        request := vs.client.NewRequest(operation)
        request.SetHeader("If-Match", etag)

        req := request.PathParameter(shareIDParam, shareID)
        ctxLogger.Info("Equivalent curl command and payload details", zap.Reflect("URL", req.URL()), zap.Reflect("Payload", shareTemplate), zap.Reflect("Operation", operation))
        _, err := req.JSONBody(shareTemplate).JSONError(&amp;apiErr).Invoke()

        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file30" style="display: none">/**
 * Copyright 2024 IBM Corp.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// Package vpcvolume ...
package vpcfilevolume

import (
        "errors"

        "github.com/IBM/ibmcloud-volume-interface/lib/provider"
        "go.uber.org/zap"
)

// UpdateVolume POSTs to /volumes. Riaas/VPC does have volume update support yet
func (vs *FileShareService) UpdateVolume(pvcTemplate *provider.UpdatePVC, ctxLogger *zap.Logger) error <span class="cov8" title="1">{
        return errors.New("unsupported Operation")
}</span>
</pre>
		
		<pre class="file" id="file31" style="display: none">/**
 * Copyright 2021 IBM Corp.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// Package provider ...
package provider

import (
        "time"

        userError "github.com/IBM/ibmcloud-volume-file-vpc/common/messages"
        "github.com/IBM/ibmcloud-volume-file-vpc/common/vpcclient/models"
        vpcfile "github.com/IBM/ibmcloud-volume-file-vpc/common/vpcclient/vpcfilevolume"
        "github.com/IBM/ibmcloud-volume-interface/lib/metrics"
        "github.com/IBM/ibmcloud-volume-interface/lib/provider"
        "go.uber.org/zap"
)

const (
        minSize    = 10 //10 GB
        dp2Profile = "dp2"
)

// CreateVolume creates file share
func (vpcs *VPCSession) CreateVolume(volumeRequest provider.Volume) (volumeResponse *provider.Volume, err error) <span class="cov8" title="1">{
        vpcs.Logger.Debug("Entry of CreateVolume method...")
        defer vpcs.Logger.Debug("Exit from CreateVolume method...")
        defer metrics.UpdateDurationFromStart(vpcs.Logger, "CreateVolume", time.Now())

        var iops int64
        var bandwidth int32
        vpcs.Logger.Info("Basic validation for CreateVolume request... ", zap.Reflect("RequestedVolumeDetails", volumeRequest))
        resourceGroup, iops, bandwidth, err := validateVolumeRequest(volumeRequest)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">vpcs.Logger.Info("Successfully validated inputs for CreateVolume request... ")

        // Set zone if provided
        var zone *models.Zone
        if volumeRequest.Az != "" </span><span class="cov0" title="0">{
                zone = &amp;models.Zone{
                        Name: volumeRequest.Az,
                }
        }</span>

        // Build the share template to send to backend
        <span class="cov8" title="1">shareTemplate := &amp;models.Share{
                Name:              *volumeRequest.Name,
                Size:              int64(*volumeRequest.Capacity),
                InitialOwner:      (*models.InitialOwner)(volumeRequest.InitialOwner),
                Iops:              iops,
                Bandwidth:         bandwidth,
                AccessControlMode: volumeRequest.AccessControlMode,
                ResourceGroup:     &amp;resourceGroup,
                Profile: &amp;models.Profile{
                        Name: volumeRequest.VPCVolume.Profile.Name,
                },
                Zone: zone,
        }

        // Check for VPC ID, SubnetID or PrimaryIPID either of the one is mandatory for VolumeAccessPoint/FileShareTarget creation
        // If AccessControlMode is vpc then VPCID is mandatory
        // If AccessControlMode is security_group either subnetID or primaryIPID is mandatory
        if len(volumeRequest.VPCID) != 0 || len(volumeRequest.SubnetID) != 0 || (volumeRequest.PrimaryIP != nil &amp;&amp; len(volumeRequest.PrimaryIP.ID) != 0) </span><span class="cov8" title="1">{

                //Build File Share target template to send to backend
                shareTargetTemplate := models.ShareTarget{
                        Name: *volumeRequest.Name,
                }

                // if VNI enabled
                if volumeRequest.AccessControlMode == SecurityGroup </span><span class="cov8" title="1">{
                        setENIParameters(&amp;shareTargetTemplate, volumeRequest)
                }</span> else<span class="cov8" title="1"> { // If VPC Mode is enabled.
                        shareTargetTemplate.VPC = &amp;provider.VPC{
                                ID: volumeRequest.VPCID,
                        }
                }</span>

                // if EIT enabled
                <span class="cov8" title="1">if volumeRequest.TransitEncryption == EncryptionTrasitMode </span><span class="cov8" title="1">{
                        shareTargetTemplate.TransitEncryption = volumeRequest.TransitEncryption
                }</span>

                // Set access_protocol and transit_encryption ONLY for 'rfs' profile
                // Note: These are mandatory parameters for rfs profile
                <span class="cov8" title="1">if volumeRequest.VPCVolume.Profile != nil &amp;&amp; volumeRequest.VPCVolume.Profile.Name == vpcfile.RFSProfile </span><span class="cov0" title="0">{
                        shareTargetTemplate.AccessProtocol = "nfs4"
                        shareTargetTemplate.TransitEncryption = "none"
                }</span>

                <span class="cov8" title="1">volumeAccessPointList := make([]models.ShareTarget, 1)
                volumeAccessPointList[0] = shareTargetTemplate

                shareTemplate.ShareTargets = &amp;volumeAccessPointList</span>
        }

        <span class="cov8" title="1">var encryptionKeyCRN string
        if volumeRequest.VPCVolume.VolumeEncryptionKey != nil &amp;&amp; len(volumeRequest.VPCVolume.VolumeEncryptionKey.CRN) &gt; 0 </span><span class="cov8" title="1">{
                encryptionKeyCRN = volumeRequest.VPCVolume.VolumeEncryptionKey.CRN
                shareTemplate.EncryptionKey = &amp;models.EncryptionKey{CRN: encryptionKeyCRN}
        }</span>

        <span class="cov8" title="1">vpcs.Logger.Info("Calling VPC provider for volume creation...")
        var volume *models.Share

        err = retry(vpcs.Logger, func() error </span><span class="cov8" title="1">{
                volume, err = vpcs.Apiclient.FileShareService().CreateFileShare(shareTemplate, vpcs.Logger)
                return err
        }</span>)

        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                vpcs.Logger.Debug("Failed to create volume from VPC provider", zap.Reflect("BackendError", err))
                return nil, userError.GetUserError("FailedToPlaceOrder", err)
        }</span>

        <span class="cov8" title="1">vpcs.Logger.Info("Successfully created volume from VPC provider...", zap.Reflect("VolumeDetails", volume))

        vpcs.Logger.Info("Waiting for volume to be in valid (stable) state", zap.Reflect("VolumeDetails", volume))
        err = WaitForValidVolumeState(vpcs, volume.ID)
        if err != nil </span><span class="cov8" title="1">{
                return nil, userError.GetUserError("VolumeNotInValidState", err, volume.ID)
        }</span>

        <span class="cov8" title="1">vpcs.Logger.Info("Volume got valid (stable) state", zap.Reflect("VolumeDetails", volume))

        // Converting share to lib volume type
        volumeResponse = FromProviderToLibVolume(volume, vpcs.Logger)
        // VPC does have region yet . So use requested region in response
        volumeResponse.Region = volumeRequest.Region

        /* // TBD Return reuested tag as is if not tags returned by backend
        if len(volumeResponse.Tags) == 0 &amp;&amp; len(volumeRequest.Tags) &gt; 0 {
                volumeResponse.Tags = volumeRequest.Tags
        } */
        vpcs.Logger.Info("VolumeResponse", zap.Reflect("volumeResponse", volumeResponse))

        return volumeResponse, err</span>
}

// validateVolumeRequest validating volume request
func validateVolumeRequest(volumeRequest provider.Volume) (models.ResourceGroup, int64, int32, error) <span class="cov8" title="1">{
        resourceGroup := models.ResourceGroup{}
        var iops int64
        iops = 0
        var bandwidth int32
        bandwidth = 0

        // Volume name should not be empty
        if volumeRequest.Name == nil || len(*volumeRequest.Name) == 0 </span><span class="cov8" title="1">{
                return resourceGroup, iops, bandwidth, userError.GetUserError("InvalidVolumeName", nil, nil)
        }</span>

        <span class="cov8" title="1">if volumeRequest.VPCVolume.Profile == nil </span><span class="cov8" title="1">{
                return resourceGroup, iops, bandwidth, userError.GetUserError("VolumeProfileEmpty", nil)
        }</span>

        // validate and add resource group ID or Name whichever is provided by user
        <span class="cov8" title="1">if volumeRequest.VPCVolume.ResourceGroup == nil </span><span class="cov8" title="1">{
                return resourceGroup, iops, bandwidth, userError.GetUserError("EmptyResourceGroup", nil)
        }</span>

        // validate and add resource group ID or Name whichever is provided by user
        <span class="cov8" title="1">if len(volumeRequest.VPCVolume.ResourceGroup.ID) == 0 &amp;&amp; len(volumeRequest.VPCVolume.ResourceGroup.Name) == 0 </span><span class="cov8" title="1">{
                return resourceGroup, iops, bandwidth, userError.GetUserError("EmptyResourceGroupIDandName", nil)
        }</span>

        <span class="cov8" title="1">if len(volumeRequest.VPCVolume.ResourceGroup.ID) &gt; 0 </span><span class="cov8" title="1">{
                resourceGroup.ID = volumeRequest.VPCVolume.ResourceGroup.ID
        }</span>
        <span class="cov8" title="1">if len(volumeRequest.VPCVolume.ResourceGroup.Name) &gt; 0 </span><span class="cov8" title="1">{
                // get the resource group ID from resource group name as Name is not supported by RIaaS
                resourceGroup.Name = volumeRequest.VPCVolume.ResourceGroup.Name
        }</span>

        <span class="cov8" title="1">if volumeRequest.Capacity == nil </span><span class="cov0" title="0">{
                return resourceGroup, iops, bandwidth, userError.GetUserError("VolumeCapacityInvalid", nil, nil)
        }</span>

        // Minimum Capacity validation for non RFS profiles.
        <span class="cov8" title="1">if *volumeRequest.Capacity &lt; minSize &amp;&amp; volumeRequest.VPCVolume.Profile.Name != vpcfile.RFSProfile </span><span class="cov0" title="0">{
                return resourceGroup, iops, bandwidth, userError.GetUserError("VolumeCapacityInvalid", nil, *volumeRequest.Capacity)
        }</span>

        <span class="cov8" title="1">if volumeRequest.Iops != nil </span><span class="cov8" title="1">{
                iops = ToInt64(*volumeRequest.Iops)
        }</span>

        <span class="cov8" title="1">bandwidth = volumeRequest.VPCVolume.Bandwidth

        return resourceGroup, iops, bandwidth, nil</span>
}

func setENIParameters(shareTarget *models.ShareTarget, volumeRequest provider.Volume) <span class="cov8" title="1">{
        shareTarget.VirtualNetworkInterface = &amp;models.VirtualNetworkInterface{
                SecurityGroups: volumeRequest.SecurityGroups,
                ResourceGroup:  volumeRequest.ResourceGroup,
        }

        if len(volumeRequest.SubnetID) != 0 </span><span class="cov8" title="1">{
                shareTarget.VirtualNetworkInterface.Subnet = &amp;models.SubnetRef{
                        ID: volumeRequest.SubnetID,
                }
        }</span>

        <span class="cov8" title="1">if volumeRequest.PrimaryIP != nil </span><span class="cov8" title="1">{
                shareTarget.VirtualNetworkInterface.PrimaryIP = volumeRequest.PrimaryIP
        }</span>
}
</pre>
		
		<pre class="file" id="file32" style="display: none">/**
 * Copyright 2021 IBM Corp.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// Package provider ...
package provider

import (
        "time"

        userError "github.com/IBM/ibmcloud-volume-file-vpc/common/messages"
        "github.com/IBM/ibmcloud-volume-file-vpc/common/vpcclient/models"
        "github.com/IBM/ibmcloud-volume-interface/lib/metrics"
        "github.com/IBM/ibmcloud-volume-interface/lib/provider"
        "github.com/IBM/ibmcloud-volume-interface/lib/utils/reasoncode"

        "go.uber.org/zap"
)

// VpcVolumeAccessPoint ...
const (
        StatusStable   = "stable"
        StatusDeleting = "deleting"
        StatusDeleted  = "deleted"
)

// VolumeAccessPoint create volume target based on given volume accessPoint request
func (vpcs *VPCSession) CreateVolumeAccessPoint(volumeAccessPointRequest provider.VolumeAccessPointRequest) (*provider.VolumeAccessPointResponse, error) <span class="cov8" title="1">{
        vpcs.Logger.Debug("Entry of CreateVolumeAccessPoint method...")
        defer vpcs.Logger.Debug("Exit from CreateVolumeAccessPoint method...")
        defer metrics.UpdateDurationFromStart(vpcs.Logger, "CreateVolumeAccessPoint", time.Now())
        var err error
        vpcs.Logger.Info("Validating basic inputs for CreateVolumeAccessPoint method...", zap.Reflect("volumeAccessPointRequest", volumeAccessPointRequest))
        err = vpcs.validateVolumeAccessPointRequest(volumeAccessPointRequest)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">var volumeAccessPointResult *models.ShareTarget
        var varp *provider.VolumeAccessPointResponse

        volumeAccessPoint := models.NewShareTarget(volumeAccessPointRequest)

        err = vpcs.APIRetry.FlexyRetry(vpcs.Logger, func() (error, bool) </span><span class="cov8" title="1">{
                /*First , check if volume target is already created
                Even if we remove this check RIAAS will respond "shares_target_vpc_duplicate" erro code.
                We need to again do GetVolumeAccessPoint to fetch the already created access point */
                vpcs.Logger.Info("Checking if volume accessPoint is already created by other thread")
                currentVolAccessPoint, err := vpcs.GetVolumeAccessPoint(volumeAccessPointRequest)
                if err == nil &amp;&amp; currentVolAccessPoint != nil </span><span class="cov8" title="1">{
                        vpcs.Logger.Info("Volume accessPoint is already created", zap.Reflect("currentVolAccessPoint", currentVolAccessPoint))
                        varp = currentVolAccessPoint
                        return nil, true // stop retry volume accessPoint already created
                }</span>

                // If ENI/VNI is enabled
                <span class="cov8" title="1">if volumeAccessPointRequest.AccessControlMode == SecurityGroup </span><span class="cov8" title="1">{
                        volumeAccessPoint.VPC = nil // We can either pass VPC or VNI
                        volumeAccessPoint.VirtualNetworkInterface = &amp;models.VirtualNetworkInterface{
                                SecurityGroups: volumeAccessPointRequest.SecurityGroups,
                                ResourceGroup:  volumeAccessPointRequest.ResourceGroup,
                        }

                        if len(volumeAccessPointRequest.SubnetID) != 0 </span><span class="cov8" title="1">{
                                volumeAccessPoint.VirtualNetworkInterface.Subnet = &amp;models.SubnetRef{
                                        ID: volumeAccessPointRequest.SubnetID,
                                }
                        }</span>

                        <span class="cov8" title="1">if volumeAccessPointRequest.PrimaryIP != nil </span><span class="cov8" title="1">{
                                volumeAccessPoint.VirtualNetworkInterface.PrimaryIP = volumeAccessPointRequest.PrimaryIP
                        }</span>
                }

                //Try creating volume accessPoint if it's not already created or there is error in getting current volume accessPoint
                <span class="cov8" title="1">vpcs.Logger.Info("Creating volume accessPoint from VPC provider...")
                volumeAccessPointResult, err = vpcs.Apiclient.FileShareService().CreateFileShareTarget(&amp;volumeAccessPoint, vpcs.Logger)
                // Keep retry, until we get the proper volumeAccessPointResult object
                if err != nil &amp;&amp; volumeAccessPointResult == nil </span><span class="cov8" title="1">{
                        return err, skipRetryForObviousErrors(err)
                }</span>
                <span class="cov8" title="1">varp = volumeAccessPointResult.ToVolumeAccessPointResponse()

                return err, true</span> // stop retry as no error
        })

        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                userErr := userError.GetUserError(string(userError.CreateVolumeAccessPointFailed), err, volumeAccessPointRequest.VolumeID, volumeAccessPointRequest.VPCID)
                return nil, userErr
        }</span>
        <span class="cov8" title="1">vpcs.Logger.Info("Successfully created volume accessPoint from VPC provider", zap.Reflect("volumeAccessPointResponse", varp))
        varp.VolumeID = volumeAccessPointRequest.VolumeID
        return varp, nil</span>
}

// validateVolume validating volume ID and VPC ID
func (vpcs *VPCSession) validateVolumeAccessPointRequest(volumeAccessPointRequest provider.VolumeAccessPointRequest) error <span class="cov8" title="1">{
        var err error
        // Check for VolumeID - required validation
        if len(volumeAccessPointRequest.VolumeID) == 0 </span><span class="cov8" title="1">{
                err = userError.GetUserError(string(reasoncode.ErrorRequiredFieldMissing), nil, "VolumeID")
                vpcs.Logger.Error("volumeAccessPointRequest.VolumeID is required", zap.Error(err))
                return err
        }</span>

        // Check for VPC ID, SubnetID or AccessPointID  - required validation
        <span class="cov8" title="1">if len(volumeAccessPointRequest.VPCID) == 0 &amp;&amp; len(volumeAccessPointRequest.SubnetID) == 0 &amp;&amp; len(volumeAccessPointRequest.AccessPointID) == 0 </span><span class="cov8" title="1">{
                err = userError.GetUserError(string(reasoncode.ErrorRequiredFieldMissing), nil, "VPCID or SubnetID or AccessPointID")
                vpcs.Logger.Error("One of volumeAccessPointRequest.VPCID, volumeAccessPointRequest.SubnetID and volumeAccessPointRequest.AccessPoint is required", zap.Error(err))
                return err
        }</span>

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file33" style="display: none">/**
 * Copyright 2021 IBM Corp.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// Package provider ...
package provider

import (
        "time"

        userError "github.com/IBM/ibmcloud-volume-file-vpc/common/messages"
        "github.com/IBM/ibmcloud-volume-file-vpc/common/vpcclient/models"
        "github.com/IBM/ibmcloud-volume-interface/lib/metrics"
        "github.com/IBM/ibmcloud-volume-interface/lib/provider"
        "go.uber.org/zap"
)

// DeleteVolume deletes the file share
func (vpcs *VPCSession) DeleteVolume(volume *provider.Volume) (err error) <span class="cov8" title="1">{
        vpcs.Logger.Debug("Entry of DeleteVolume method...")
        defer vpcs.Logger.Debug("Exit from DeleteVolume method...")
        defer metrics.UpdateDurationFromStart(vpcs.Logger, "DeleteVolume", time.Now())

        vpcs.Logger.Info("Validating basic inputs for DeleteVolume method...", zap.Reflect("VolumeDetails", volume))
        err = validateVolume(volume)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">existingVol, err := vpcs.GetVolume(volume.VolumeID)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        //If there exists any access point for volume we should abort delete
        <span class="cov8" title="1">if existingVol.VolumeAccessPoints != nil &amp;&amp; len(*existingVol.VolumeAccessPoints) != 0 </span><span class="cov8" title="1">{
                var vpcIDList = []string{}
                for _, volAccessPoint := range *existingVol.VolumeAccessPoints </span><span class="cov8" title="1">{
                        if volAccessPoint.VPC != nil </span><span class="cov8" title="1">{
                                vpcIDList = append(vpcIDList, volAccessPoint.VPC.ID)
                        }</span>
                }
                <span class="cov8" title="1">return userError.GetUserError(string(userError.VolumeAccessPointExist), nil, volume.VolumeID, vpcIDList)</span>
        }

        <span class="cov8" title="1">vpcs.Logger.Info("Deleting file share from VPC provider...")
        err = retry(vpcs.Logger, func() error </span><span class="cov8" title="1">{
                vpcs.Logger.Info("Calling VPC client for file share deletion...")
                err = vpcs.Apiclient.FileShareService().DeleteFileShare(volume.VolumeID, vpcs.Logger)
                return err
        }</span>)
        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                return userError.GetUserError("FailedToDeleteVolume", err, volume.VolumeID)
        }</span>

        <span class="cov8" title="1">err = WaitForVolumeDeletion(vpcs, volume.VolumeID)
        if err != nil </span><span class="cov0" title="0">{
                return userError.GetUserError("FailedToDeleteVolume", err, volume.VolumeID)
        }</span>

        <span class="cov8" title="1">vpcs.Logger.Info("Successfully deleted volume from VPC provider")
        return err</span>
}

// validateVolume validating volume ID
func validateVolume(volume *provider.Volume) (err error) <span class="cov8" title="1">{
        if volume == nil </span><span class="cov8" title="1">{
                err = userError.GetUserError("InvalidVolumeID", nil, nil)
                return
        }</span>

        <span class="cov8" title="1">if IsValidVolumeIDFormat(volume.VolumeID) </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">err = userError.GetUserError("InvalidVolumeID", nil, volume.VolumeID)
        return</span>
}

// WaitForVolumeDeletion checks the volume for valid status
func WaitForVolumeDeletion(vpcs *VPCSession, volumeID string) (err error) <span class="cov8" title="1">{
        vpcs.Logger.Debug("Entry of WaitForVolumeDeletion method...")
        defer vpcs.Logger.Debug("Exit from WaitForVolumeDeletion method...")
        var skip = false

        vpcs.Logger.Info("Getting volume details from VPC provider...", zap.Reflect("VolumeID", volumeID))

        err = vpcs.APIRetry.FlexyRetry(vpcs.Logger, func() (error, bool) </span><span class="cov8" title="1">{
                _, err = vpcs.Apiclient.FileShareService().GetFileShare(volumeID, vpcs.Logger)
                // Keep retry, until GetVolume returns volume not found
                if err != nil </span><span class="cov0" title="0">{
                        skip = skipRetry(err.(*models.Error))
                        return nil, skip
                }</span>
                <span class="cov8" title="1">return err, false</span> // continue retry as we are not seeing error which means volume is stable
        })

        <span class="cov8" title="1">if err == nil &amp;&amp; skip </span><span class="cov0" title="0">{
                vpcs.Logger.Info("Volume got deleted.", zap.Reflect("volumeID", volumeID))
        }</span>
        <span class="cov8" title="1">return err</span>
}
</pre>
		
		<pre class="file" id="file34" style="display: none">/**
 * Copyright 2021 IBM Corp.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// Package provider ...
package provider

import (
        userError "github.com/IBM/ibmcloud-volume-file-vpc/common/messages"
        "github.com/IBM/ibmcloud-volume-file-vpc/common/vpcclient/models"
        "github.com/IBM/ibmcloud-volume-interface/lib/metrics"
        "github.com/IBM/ibmcloud-volume-interface/lib/provider"

        "net/http"
        "time"

        "go.uber.org/zap"
)

// DeleteVolumeAccessPoint deletes file share target for given volume VolumeAccessPoint request
func (vpcs *VPCSession) DeleteVolumeAccessPoint(deleteAccessPointRequest provider.VolumeAccessPointRequest) (*http.Response, error) <span class="cov8" title="1">{
        vpcs.Logger.Debug("Entry of DeleteVolumeAccessPoint method...")
        defer vpcs.Logger.Debug("Exit from DeleteVolumeAccessPoint method...")
        defer metrics.UpdateDurationFromStart(vpcs.Logger, "DeleteVolumeAccessPoint", time.Now())
        var err error
        vpcs.Logger.Info("Validating basic inputs for delete AccessPoint method...", zap.Reflect("deleteAccessPointRequest", deleteAccessPointRequest))
        err = vpcs.validateVolumeAccessPointRequest(deleteAccessPointRequest)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">var response *http.Response

        err = vpcs.APIRetry.FlexyRetry(vpcs.Logger, func() (error, bool) </span><span class="cov8" title="1">{
                // First , check if volume AccessPoint is already deleted to given instance
                vpcs.Logger.Info("Checking if volume AccessPoint is already deleted ")
                currentVolumeAccessPoint, err := vpcs.GetVolumeAccessPoint(deleteAccessPointRequest)
                if err == nil &amp;&amp; currentVolumeAccessPoint != nil &amp;&amp; currentVolumeAccessPoint.Status != StatusDeleting &amp;&amp; currentVolumeAccessPoint.Status != StatusDeleted </span><span class="cov8" title="1">{
                        // If no error and current volume AccessPoint is not already in deleting or deleted state ( i.e in stable or pending state) attempt to delete
                        vpcs.Logger.Info("Found volume AccessPoint", zap.Reflect("currentVolAccessPoint", currentVolumeAccessPoint))
                        volumeAccessPoint := models.NewShareTarget(deleteAccessPointRequest)
                        volumeAccessPoint.ShareID = currentVolumeAccessPoint.VolumeID
                        volumeAccessPoint.ID = currentVolumeAccessPoint.AccessPointID
                        vpcs.Logger.Info("Deleting volume AccessPoint from VPC provider...")
                        response, err = vpcs.Apiclient.FileShareService().DeleteFileShareTarget(&amp;volumeAccessPoint, vpcs.Logger)

                        //Retry in case of all errors
                        if err != nil </span><span class="cov8" title="1">{
                                return err, false
                        }</span>
                }
                <span class="cov8" title="1">vpcs.Logger.Info("No volume access point found for", zap.Reflect("currentVolumeAccessPoint", currentVolumeAccessPoint), zap.Error(err))
                // consider volume delete success if its  already  in deleting, pending deletion or VolumeAccessPoint is not found
                response = &amp;http.Response{
                        StatusCode: http.StatusOK,
                }
                return nil, true</span> // skip retry if volume AccessPoint is not found OR already in deleting, pending deletion state
        })
        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                userErr := userError.GetUserError(string(userError.DeleteVolumeAccessPointFailed), err, deleteAccessPointRequest.VolumeID, deleteAccessPointRequest.AccessPointID)
                vpcs.Logger.Error("Volume AccessPoint delete failed with error", zap.Error(err))
                return response, userErr
        }</span>
        <span class="cov8" title="1">vpcs.Logger.Info("Successfully deleted volume AccessPoint from VPC provider", zap.Reflect("resp", response))
        return response, nil</span>
}
</pre>
		
		<pre class="file" id="file35" style="display: none">/**
 * Copyright 2022 IBM Corp.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// Package provider ...
package provider

import (
        "time"

        userError "github.com/IBM/ibmcloud-volume-file-vpc/common/messages"
        "github.com/IBM/ibmcloud-volume-file-vpc/common/vpcclient/models"
        "github.com/IBM/ibmcloud-volume-interface/lib/metrics"
        "github.com/IBM/ibmcloud-volume-interface/lib/provider"
        "go.uber.org/zap"
)

// GiB ...
const (
        GiB = 1024 * 1024 * 1024
)

func (vpcs *VPCSession) ExpandVolume(expandVolumeRequest provider.ExpandVolumeRequest) (size int64, err error) <span class="cov8" title="1">{
        vpcs.Logger.Debug("Entry of ExpandVolume method...")
        defer vpcs.Logger.Debug("Exit from ExpandVolume method...")
        defer metrics.UpdateDurationFromStart(vpcs.Logger, "ExpandVolume", time.Now())

        // Get volume details
        existingVolume, err := vpcs.GetVolume(expandVolumeRequest.VolumeID)
        if err != nil </span><span class="cov8" title="1">{
                return -1, err
        }</span>
        // Return existing Capacity if its greater or equal to expandable size
        <span class="cov8" title="1">if existingVolume.Capacity != nil &amp;&amp; int64(*existingVolume.Capacity) &gt;= expandVolumeRequest.Capacity </span><span class="cov8" title="1">{
                vpcs.Logger.Warn("Requested size is less than current size.", zap.Reflect("Current Size: ", existingVolume.VolumeID), zap.Reflect("Requested Size: ", expandVolumeRequest.Capacity))
                return int64(*existingVolume.Capacity), nil
        }</span>
        <span class="cov8" title="1">vpcs.Logger.Info("Successfully validated inputs for ExpandVolume request... ")

        newSize := roundUpSize(expandVolumeRequest.Capacity, GiB)

        // Build the template to send to backend
        shareTemplate := &amp;models.Share{
                Size: newSize,
        }

        vpcs.Logger.Info("Calling VPC provider for volume expand...")
        var share *models.Share
        err = retry(vpcs.Logger, func() error </span><span class="cov8" title="1">{
                share, err = vpcs.Apiclient.FileShareService().ExpandVolume(expandVolumeRequest.VolumeID, shareTemplate, vpcs.Logger)
                return err
        }</span>)

        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                vpcs.Logger.Debug("Failed to expand volume from VPC provider", zap.Reflect("BackendError", err))
                return -1, userError.GetUserError("FailedToExpandVolume", err, expandVolumeRequest.VolumeID)
        }</span>

        <span class="cov8" title="1">vpcs.Logger.Info("Successfully accepted volume expansion request, now waiting for volume state equal to stable")
        err = WaitForValidVolumeState(vpcs, share.ID)
        if err != nil </span><span class="cov8" title="1">{
                return -1, userError.GetUserError("VolumeNotInValidState", err, share.ID)
        }</span>

        <span class="cov8" title="1">vpcs.Logger.Info("Volume got valid (stable) state", zap.Reflect("VolumeDetails", share))
        return expandVolumeRequest.Capacity, nil</span>
}
</pre>
		
		<pre class="file" id="file36" style="display: none">/**
 * Copyright 2023 IBM Corp.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// Package provider ...
package provider

import (
        "errors"
        userError "github.com/IBM/ibmcloud-volume-file-vpc/common/messages"
        "github.com/IBM/ibmcloud-volume-file-vpc/common/vpcclient/models"
        "github.com/IBM/ibmcloud-volume-interface/lib/provider"
        "go.uber.org/zap"
        "net/url"
        "strings"
)

// GetSecurityGroupForVolumeAccessPoint  get the SecurityGroup based on the request
func (vpcs *VPCSession) GetSecurityGroupForVolumeAccessPoint(securityGroupRequest provider.SecurityGroupRequest) (string, error) <span class="cov8" title="1">{
        vpcs.Logger.Info("Entry of GetSecurityGroupForVolumeAccessPoint method...", zap.Reflect("securityGroupRequest", securityGroupRequest))
        defer vpcs.Logger.Info("Exit from GetSecurityGroupForVolumeAccessPoint method...")

        // Get SecurityGroup by VPC and name. This is inefficient operation which requires iteration over SecurityGroup list
        securityGroup, err := vpcs.getSecurityGroupByVPCAndSecurityGroupName(securityGroupRequest)
        vpcs.Logger.Info("getSecurityGroupByVPCAndSecurityGroupName response", zap.Reflect("securityGroup", securityGroup), zap.Error(err))
        return securityGroup, err
}</span>

func (vpcs *VPCSession) getSecurityGroupByVPCAndSecurityGroupName(securityGroupRequest provider.SecurityGroupRequest) (string, error) <span class="cov8" title="1">{
        vpcs.Logger.Debug("Entry of getSecurityGroupByVPCAndSecurityGroupName()")
        defer vpcs.Logger.Debug("Exit from getSecurityGroupByVPCAndSecurityGroupName()")
        vpcs.Logger.Info("Getting getSecurityGroupByVPCAndSecurityGroupName from VPC provider...")
        var err error
        var start = ""

        filters := &amp;models.ListSecurityGroupFilters{
                ResourceGroupID: securityGroupRequest.ResourceGroup.ID,
                VPCID:           securityGroupRequest.VPCID,
        }

        for </span><span class="cov8" title="1">{

                securityGroups, err := vpcs.Apiclient.FileShareService().ListSecurityGroups(pageSize, start, filters, vpcs.Logger)

                if err != nil </span><span class="cov8" title="1">{
                        // API call is failed
                        return "", userError.GetUserError("SecurityGroupsListFailed", err)
                }</span>

                // Iterate over the SecurityGroup list for given volume
                <span class="cov8" title="1">if securityGroups != nil </span><span class="cov8" title="1">{
                        for _, securityGroupItem := range securityGroups.SecurityGroups </span><span class="cov8" title="1">{
                                // Check if securityGroup is matching with requested input securityGroup name
                                if strings.EqualFold(securityGroupRequest.Name, securityGroupItem.Name) </span><span class="cov8" title="1">{
                                        vpcs.Logger.Info("Successfully found securityGroup", zap.Reflect("securityGroupItem", securityGroupItem))
                                        return securityGroupItem.ID, nil
                                }</span>
                        }

                        <span class="cov0" title="0">if securityGroups.Next == nil </span><span class="cov0" title="0">{
                                break</span> // No more pages, exit the loop
                        }

                        // Fetch the start of next page
                        <span class="cov0" title="0">startUrl, err := url.Parse(securityGroups.Next.Href)
                        if err != nil </span><span class="cov0" title="0">{
                                // API call is failed
                                vpcs.Logger.Warn("The next parameter of the securityGroup list could not be parsed.", zap.Reflect("Next", securityGroups.Next.Href), zap.Error(err))
                                return "", userError.GetUserError(string("SecurityGroupFindFailed"), err, securityGroupRequest.Name)
                        }</span>

                        <span class="cov0" title="0">vpcs.Logger.Info("startUrl", zap.Reflect("startUrl", startUrl))
                        start = startUrl.Query().Get("start") //parse query param into map
                        if start == "" </span><span class="cov0" title="0">{
                                // API call is failed
                                vpcs.Logger.Warn("The start specified in the next parameter of the securityGroup list is empty.", zap.Reflect("startUrl", startUrl))
                                return "", userError.GetUserError(string("SecurityGroupFindFailed"), errors.New("no securityGroup found"), securityGroupRequest.Name)
                        }</span>
                } else<span class="cov0" title="0"> {
                        return "", userError.GetUserError(string("SecurityGroupsListFailed"), errors.New("SecurityGroup list is empty"))
                }</span>
        }

        // No volume SecurityGroup found in the  list. So return error
        <span class="cov0" title="0">vpcs.Logger.Error("SecurityGroup not found", zap.Error(err))
        return "", userError.GetUserError(string("SecurityGroupFindFailed"), errors.New("no securityGroup found"), securityGroupRequest.Name)</span>
}
</pre>
		
		<pre class="file" id="file37" style="display: none">/**
 * Copyright 2023 IBM Corp.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// Package provider ...
package provider

import (
        "errors"
        userError "github.com/IBM/ibmcloud-volume-file-vpc/common/messages"
        "github.com/IBM/ibmcloud-volume-file-vpc/common/vpcclient/models"
        "github.com/IBM/ibmcloud-volume-interface/lib/provider"
        "go.uber.org/zap"
        "net/url"
        "strings"
)

// / GetSubnet  get the subnet based on the request
func (vpcs *VPCSession) GetSubnetForVolumeAccessPoint(subnetRequest provider.SubnetRequest) (string, error) <span class="cov8" title="1">{
        vpcs.Logger.Info("Entry of GetSubnetForVolumeAccessPoint method...", zap.Reflect("subnetRequest", subnetRequest))
        defer vpcs.Logger.Info("Exit from GetSubnetForVolumeAccessPoint method...")

        // Get Subnet by zone and cluster subnet list. This is inefficient operation which requires iteration over subnet list
        subnet, err := vpcs.getSubnetByZoneAndSubnetID(subnetRequest)
        vpcs.Logger.Info("getSubnetByVPCIDAndZone response", zap.Reflect("subnet", subnet), zap.Error(err))
        return subnet, err
}</span>

func (vpcs *VPCSession) getSubnetByZoneAndSubnetID(subnetRequest provider.SubnetRequest) (string, error) <span class="cov8" title="1">{
        vpcs.Logger.Debug("Entry of getSubnetByVPCIDAndZone()")
        defer vpcs.Logger.Debug("Exit from getSubnetByVPCIDAndZone()")
        vpcs.Logger.Info("Getting getSubnetByVPCIDAndZone from VPC provider...")
        var err error
        var start = ""

        filters := &amp;models.ListSubnetFilters{
                ResourceGroupID: subnetRequest.ResourceGroup.ID,
                VPCID:           subnetRequest.VPCID,
                ZoneName:        subnetRequest.ZoneName,
        }

        for </span><span class="cov8" title="1">{

                subnets, err := vpcs.Apiclient.FileShareService().ListSubnets(pageSize, start, filters, vpcs.Logger)

                if err != nil </span><span class="cov8" title="1">{
                        // API call is failed
                        return "", userError.GetUserError("SubnetsListFailed", err)
                }</span>

                // Iterate over the subnet list for given volume
                <span class="cov8" title="1">if subnets != nil </span><span class="cov8" title="1">{
                        for _, subnetItem := range subnets.Subnets </span><span class="cov8" title="1">{
                                // Check if subnet is matching with requested input subnet-list
                                if strings.Contains(subnetRequest.SubnetIDList, subnetItem.ID) </span><span class="cov8" title="1">{
                                        vpcs.Logger.Info("Successfully found subnet", zap.Reflect("subnetItem", subnetItem))
                                        return subnetItem.ID, nil
                                }</span>
                        }

                        <span class="cov0" title="0">if subnets.Next == nil </span><span class="cov0" title="0">{
                                break</span> // No more pages, exit the loop
                        }

                        // Fetch the start of next page
                        <span class="cov0" title="0">startUrl, err := url.Parse(subnets.Next.Href)
                        if err != nil </span><span class="cov0" title="0">{
                                // API call is failed
                                vpcs.Logger.Warn("The next parameter of the subnet list could not be parsed.", zap.Reflect("Next", subnets.Next.Href), zap.Error(err))
                                return "", userError.GetUserError(string("SubnetFindFailed"), err, subnetRequest.ZoneName, subnetRequest.SubnetIDList)
                        }</span>

                        <span class="cov0" title="0">vpcs.Logger.Info("startUrl", zap.Reflect("startUrl", startUrl))
                        start = startUrl.Query().Get("start") //parse query param into map
                        if start == "" </span><span class="cov0" title="0">{
                                // API call is failed
                                vpcs.Logger.Warn("The start specified in the next parameter of the subnet list is empty.", zap.Reflect("start", startUrl))
                                return "", userError.GetUserError(string("SubnetFindFailed"), errors.New("no subnet found"), subnetRequest.ZoneName, subnetRequest.SubnetIDList)
                        }</span>
                } else<span class="cov0" title="0"> {
                        return "", userError.GetUserError(string("SubnetsListFailed"), errors.New("Subnet list is empty"))
                }</span>
        }

        // No volume Subnet found in the  list. So return error
        <span class="cov0" title="0">vpcs.Logger.Error("Subnet not found", zap.Error(err))
        return "", userError.GetUserError(string("SubnetFindFailed"), errors.New("no subnet found"), subnetRequest.ZoneName, subnetRequest.SubnetIDList)</span>
}
</pre>
		
		<pre class="file" id="file38" style="display: none">/**
 * Copyright 2021 IBM Corp.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// Package provider ...
package provider

import (
        "errors"

        userError "github.com/IBM/ibmcloud-volume-file-vpc/common/messages"
        "github.com/IBM/ibmcloud-volume-file-vpc/common/vpcclient/models"
        "github.com/IBM/ibmcloud-volume-interface/lib/provider"
        "go.uber.org/zap"
)

// GetVolumeAccessPoint  get the file share target based on the request
func (vpcs *VPCSession) GetVolumeAccessPoint(volumeAccessPointRequest provider.VolumeAccessPointRequest) (*provider.VolumeAccessPointResponse, error) <span class="cov8" title="1">{
        vpcs.Logger.Debug("Entry of GetVolumeAccessPoint method...", zap.Reflect("volumeAccessPointRequest", volumeAccessPointRequest))
        defer vpcs.Logger.Debug("Exit from GetVolumeAccessPoint method...")
        var err error
        vpcs.Logger.Info("Validating basic inputs for GetVolumeAccessPoint method...", zap.Reflect("volumeAccessPointRequest", volumeAccessPointRequest))
        err = vpcs.validateVolumeAccessPointRequest(volumeAccessPointRequest)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">var volumeAccessPointResponse *provider.VolumeAccessPointResponse
        volumeAccessPoint := models.NewShareTarget(volumeAccessPointRequest)
        if len(volumeAccessPoint.ID) &gt; 0 </span><span class="cov8" title="1">{
                //Get volume AccessPoint by target ID if it is specified
                volumeAccessPointResponse, err = vpcs.getVolumeAccessPointByID(volumeAccessPoint)
        }</span> else<span class="cov8" title="1"> {
                // Get volume AccessPoint by VPC ID. This is inefficient operation which requires iteration over volume target list
                volumeAccessPointResponse, err = vpcs.getVolumeAccessPointByVPCID(volumeAccessPoint)
        }</span>
        <span class="cov8" title="1">vpcs.Logger.Info("Volume access point response", zap.Reflect("volumeAccessPointResponse", volumeAccessPointResponse), zap.Error(err))
        return volumeAccessPointResponse, err</span>
}

func (vpcs *VPCSession) getVolumeAccessPointByID(volumeAccessPointRequest models.ShareTarget) (*provider.VolumeAccessPointResponse, error) <span class="cov8" title="1">{
        vpcs.Logger.Debug("Entry of getVolumeAccessPointByID()")
        defer vpcs.Logger.Debug("Exit from getVolumeAccessPointByID()")
        vpcs.Logger.Info("Getting VolumeAccessPoint from VPC provider...")
        var err error
        var volumeAccessPointResult *models.ShareTarget

        err = vpcs.APIRetry.FlexyRetry(vpcs.Logger, func() (error, bool) </span><span class="cov8" title="1">{
                volumeAccessPointResult, err = vpcs.Apiclient.FileShareService().GetFileShareTarget(volumeAccessPointRequest.ShareID, volumeAccessPointRequest.ID, vpcs.Logger)
                // Keep retry, until we get the proper volumeAccessPointResponse object
                if err != nil &amp;&amp; volumeAccessPointResult == nil </span><span class="cov8" title="1">{
                        return err, skipRetryForObviousErrors(err)
                }</span>
                <span class="cov8" title="1">return err, true</span> // stop retry as no error
        })

        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                // API call is failed
                userErr := userError.GetUserError(string(userError.AccessPointWithAPIDFindFailed), err, volumeAccessPointRequest.ShareID, volumeAccessPointRequest.ID)
                return nil, userErr
        }</span>

        <span class="cov8" title="1">volumeAccessPointResponse := volumeAccessPointResult.ToVolumeAccessPointResponse()
        volumeAccessPointResponse.VolumeID = volumeAccessPointRequest.ShareID

        vpcs.Logger.Info("Successfully retrieved volume AccessPoint", zap.Reflect("volumeAccessPointResponse", volumeAccessPointResponse))
        return volumeAccessPointResponse, err</span>
}

func (vpcs *VPCSession) getVolumeAccessPointByVPCID(volumeAccessPointRequest models.ShareTarget) (*provider.VolumeAccessPointResponse, error) <span class="cov8" title="1">{
        vpcs.Logger.Debug("Entry of getVolumeAccessPointByVPCID()")
        defer vpcs.Logger.Debug("Exit from getVolumeAccessPointByVPCID()")
        vpcs.Logger.Info("Getting VolumeTargetList from VPC provider...")
        var volumeAccessPointList *models.ShareTargetList
        var err error
        err = vpcs.APIRetry.FlexyRetry(vpcs.Logger, func() (error, bool) </span><span class="cov8" title="1">{
                volumeAccessPointList, err = vpcs.Apiclient.FileShareService().ListFileShareTargets(volumeAccessPointRequest.ShareID, nil, vpcs.Logger)
                // Keep retry, until we get the proper volumeAccessPointResponse object
                if err != nil </span><span class="cov8" title="1">{
                        return err, skipRetryForObviousErrors(err)
                }</span>
                <span class="cov8" title="1">return err, true</span> // stop retry as no error
        })

        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                // API call is failed
                userErr := userError.GetUserError(string(userError.AccessPointWithVPCIDFindFailed), err, volumeAccessPointRequest.ShareID, volumeAccessPointRequest.VPC.ID)
                return nil, userErr
        }</span>
        // Iterate over the volume AccessPoint list for given volume
        <span class="cov8" title="1">if volumeAccessPointList != nil </span><span class="cov8" title="1">{
                for _, volumeAccessPointItem := range volumeAccessPointList.ShareTargets </span><span class="cov8" title="1">{
                        // Check if VPC ID is matching with requested VPC ID in volume target list
                        if volumeAccessPointItem.VPC != nil &amp;&amp; volumeAccessPointItem.VPC.ID == volumeAccessPointRequest.VPC.ID </span><span class="cov8" title="1">{
                                vpcs.Logger.Info("Successfully found volume AccessPoint", zap.Reflect("volumeAccessPoint", volumeAccessPointItem))
                                volumeAccessPointResponse := volumeAccessPointItem.ToVolumeAccessPointResponse()
                                volumeAccessPointResponse.VolumeID = volumeAccessPointRequest.ShareID

                                vpcs.Logger.Info("Successfully fetched volume AccessPoint from VPC provider", zap.Reflect("volumeTargetResponse", volumeAccessPointResponse))
                                return volumeAccessPointResponse, nil
                        }</span>
                }
        }
        // No volume AccessPoint found in the  list. So return error
        <span class="cov8" title="1">userErr := userError.GetUserError(string(userError.AccessPointWithVPCIDFindFailed), errors.New("no volume access point found"), volumeAccessPointRequest.ShareID, volumeAccessPointRequest.VPC.ID)
        vpcs.Logger.Error("Volume AccessPoint not found", zap.Error(err))
        return nil, userErr</span>
}
</pre>
		
		<pre class="file" id="file39" style="display: none">/**
 * Copyright 2021 IBM Corp.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// Package provider ...
package provider

import (
        userError "github.com/IBM/ibmcloud-volume-file-vpc/common/messages"
        "github.com/IBM/ibmcloud-volume-file-vpc/common/vpcclient/models"
        "github.com/IBM/ibmcloud-volume-interface/lib/provider"
        "go.uber.org/zap"
)

// GetVolume gets the file share by using ID
func (vpcs *VPCSession) GetVolume(id string) (respVolume *provider.Volume, err error) <span class="cov8" title="1">{
        vpcs.Logger.Debug("Entry of GetVolume method...")
        defer vpcs.Logger.Debug("Exit from GetVolume method...")

        vpcs.Logger.Info("Basic validation for volume ID...", zap.Reflect("VolumeID", id))
        // validating volume ID
        err = validateVolumeID(id)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">vpcs.Logger.Info("Getting volume details from VPC provider...", zap.Reflect("VolumeID", id))

        var volume *models.Share
        err = retry(vpcs.Logger, func() error </span><span class="cov8" title="1">{
                volume, err = vpcs.Apiclient.FileShareService().GetFileShare(id, vpcs.Logger)
                return err
        }</span>)

        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                return nil, userError.GetUserError("StorageFindFailedWithVolumeId", err, id)
        }</span>

        <span class="cov8" title="1">vpcs.Logger.Info("Successfully retrieved volume details from VPC backend", zap.Reflect("VolumeDetails", volume))

        // Converting volume to lib volume type
        respVolume = FromProviderToLibVolume(volume, vpcs.Logger)
        return respVolume, err</span>
}

// GetVolumeByName ...
func (vpcs *VPCSession) GetVolumeByName(name string) (respVolume *provider.Volume, err error) <span class="cov8" title="1">{
        vpcs.Logger.Debug("Entry of GetVolumeByName method...")
        defer vpcs.Logger.Debug("Exit from GetVolumeByName method...")

        vpcs.Logger.Info("Basic validation for volume Name...", zap.Reflect("VolumeName", name))
        if len(name) &lt;= 0 </span><span class="cov8" title="1">{
                err = userError.GetUserError("InvalidVolumeName", nil, name)
                return
        }</span>

        <span class="cov8" title="1">vpcs.Logger.Info("Getting volume details from VPC provider...", zap.Reflect("VolumeName", name))

        var volume *models.Share
        err = retry(vpcs.Logger, func() error </span><span class="cov8" title="1">{
                volume, err = vpcs.Apiclient.FileShareService().GetFileShareByName(name, vpcs.Logger)
                return err
        }</span>)

        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                return nil, userError.GetUserError("StorageFindFailedWithVolumeName", err, name)
        }</span>

        <span class="cov8" title="1">vpcs.Logger.Info("Successfully retrieved volume details from VPC backend", zap.Reflect("VolumeDetails", volume))

        // Converting volume to lib volume type
        respVolume = FromProviderToLibVolume(volume, vpcs.Logger)
        return respVolume, err</span>
}

// validateVolumeID validating basic volume ID
func validateVolumeID(volumeID string) (err error) <span class="cov8" title="1">{
        if IsValidVolumeIDFormat(volumeID) </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">err = userError.GetUserError("InvalidVolumeID", nil, volumeID)
        return</span>
}
</pre>
		
		<pre class="file" id="file40" style="display: none">/**
 * Copyright 2025 IBM Corp.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// Package provider ...
package provider

import (
        "github.com/IBM/ibmcloud-volume-interface/lib/provider"
        "go.uber.org/zap"
)

// GetVolumeProfileByName ...
func (vpcs *VPCSession) GetVolumeProfileByName(name string) (*provider.Profile, error) <span class="cov8" title="1">{
        vpcs.Logger.Debug("Entry of GetVolumeProfileByName method...")
        defer vpcs.Logger.Debug("Exit from GetVolumeProfileByName method...")

        vpcs.Logger.Info("Fetching Volume Profile...", zap.Reflect("VolumeProfileName", name))

        profile, err := vpcs.Apiclient.FileShareService().GetShareProfile(name, vpcs.Logger)

        if err != nil || profile == nil </span><span class="cov8" title="1">{
                vpcs.Logger.Warn("Error fetching Volume Profile ...", zap.Reflect("VolumeProfileName", name))
                return nil, err
        }</span>

        // Converting lib profile to provider profile type
        <span class="cov8" title="1">respProfile := FromLibToProviderProfile(profile, vpcs.Logger)

        vpcs.Logger.Info("Volume Profile details...", zap.Reflect("respProfile", respProfile))

        return respProfile, nil</span>
}
</pre>
		
		<pre class="file" id="file41" style="display: none">/**
 * Copyright 2021 IBM Corp.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// Package provider ...
package provider

import (
        "fmt"
        "strings"
        "time"

        userError "github.com/IBM/ibmcloud-volume-file-vpc/common/messages"
        "github.com/IBM/ibmcloud-volume-file-vpc/common/vpcclient/models"
        "github.com/IBM/ibmcloud-volume-interface/lib/metrics"
        "github.com/IBM/ibmcloud-volume-interface/lib/provider"
        "go.uber.org/zap"
)

const (
        maxLimit                 = 100
        startVolumeIDNotFoundMsg = "start parameter is not valid"
)

// ListVolumes list all file shares
func (vpcs *VPCSession) ListVolumes(limit int, start string, tags map[string]string) (*provider.VolumeList, error) <span class="cov8" title="1">{
        vpcs.Logger.Info("Entry ListVolumes", zap.Reflect("start", start), zap.Reflect("filters", tags))
        defer vpcs.Logger.Info("Exit ListVolumes", zap.Reflect("start", start), zap.Reflect("filters", tags))
        defer metrics.UpdateDurationFromStart(vpcs.Logger, "ListVolumes", time.Now())

        if limit &lt; 0 </span><span class="cov8" title="1">{
                return nil, userError.GetUserError("InvalidListVolumesLimit", nil, limit)
        }</span>

        <span class="cov8" title="1">if limit &gt; maxLimit </span><span class="cov0" title="0">{
                vpcs.Logger.Warn(fmt.Sprintf("listVolumes requested max entries of %v, supports values &lt;= %v so defaulting value back to %v", limit, maxLimit, maxLimit))
                limit = maxLimit
        }</span>

        <span class="cov8" title="1">filters := &amp;models.ListShareFilters{
                ResourceGroupID: tags["resource_group.id"],
                ShareName:       tags["name"],
        }

        vpcs.Logger.Info("Getting volumes list from VPC provider...", zap.Reflect("start", start), zap.Reflect("filters", filters))

        var volumes *models.ShareList
        var err error
        err = retry(vpcs.Logger, func() error </span><span class="cov8" title="1">{
                volumes, err = vpcs.Apiclient.FileShareService().ListFileShares(limit, start, filters, vpcs.Logger)
                return err
        }</span>)

        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                if strings.Contains(err.Error(), startVolumeIDNotFoundMsg) </span><span class="cov8" title="1">{
                        return nil, userError.GetUserError("StartVolumeIDNotFound", err, start)
                }</span>
                <span class="cov8" title="1">return nil, userError.GetUserError("ListVolumesFailed", err)</span>
        }

        <span class="cov8" title="1">vpcs.Logger.Info("Successfully retrieved volumes list from VPC backend", zap.Reflect("VolumesList", volumes))

        var respVolumesList = &amp;provider.VolumeList{}
        if volumes != nil </span><span class="cov8" title="1">{
                if volumes.Next != nil </span><span class="cov8" title="1">{
                        var next string
                        // "Next":{"href":"https://eu-gb.iaas.cloud.ibm.com/v1/volumes?start=3e898aa7-ac71-4323-952d-a8d741c65a68\u0026limit=1\u0026name=eu-gb-1"}
                        if strings.Contains(volumes.Next.Href, "start=") </span><span class="cov0" title="0">{
                                next = strings.Split(strings.Split(volumes.Next.Href, "start=")[1], "\u0026")[0]
                        }</span> else<span class="cov8" title="1"> {
                                vpcs.Logger.Warn("Volumes.Next.Href is not in expected format", zap.Reflect("volumes.Next.Href", volumes.Next.Href))
                        }</span>
                        <span class="cov8" title="1">respVolumesList.Next = next</span>
                }

                <span class="cov8" title="1">volumeslist := volumes.Shares
                if len(volumeslist) &gt; 0 </span><span class="cov8" title="1">{
                        for _, volItem := range volumeslist </span><span class="cov8" title="1">{
                                volumeResponse := FromProviderToLibVolume(volItem, vpcs.Logger)
                                respVolumesList.Volumes = append(respVolumesList.Volumes, volumeResponse)
                        }</span>
                }
        }
        <span class="cov8" title="1">return respVolumesList, err</span>
}
</pre>
		
		<pre class="file" id="file42" style="display: none">/**
 * Copyright 2021 IBM Corp.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// Package provider ...
package provider

import (
        "context"
        "errors"
        "fmt"
        "net/http"
        "os"
        "strings"
        "time"

        vpcauth "github.com/IBM/ibmcloud-volume-file-vpc/common/auth"
        userError "github.com/IBM/ibmcloud-volume-file-vpc/common/messages"
        "github.com/IBM/ibmcloud-volume-file-vpc/common/vpcclient/riaas"
        vpcconfig "github.com/IBM/ibmcloud-volume-file-vpc/file/vpcconfig"
        "github.com/IBM/ibmcloud-volume-interface/config"
        "github.com/IBM/ibmcloud-volume-interface/lib/metrics"
        "github.com/IBM/ibmcloud-volume-interface/lib/provider"
        util "github.com/IBM/ibmcloud-volume-interface/lib/utils"
        "github.com/IBM/ibmcloud-volume-interface/provider/iam"
        "github.com/IBM/ibmcloud-volume-interface/provider/local"
        "github.com/IBM/secret-utils-lib/pkg/k8s_utils"
        "go.uber.org/zap"
)

const (
        // VPCNextGen ...
        VPCNextGen = "g2"
        // PrivatePrefix ...
        PrivatePrefix = "private-"
        // BasePrivateURL ...
        BasePrivateURL = "https://" + PrivatePrefix
        // HTTPSLength ...
        HTTPSLength = 8
        // NEXTGenProvider ...
        NEXTGenProvider = 2
)

// VPCFileProvider implements provider.Provider
type VPCFileProvider struct {
        timeout        time.Duration
        Config         *vpcconfig.VPCFileConfig
        tokenGenerator *tokenGenerator
        ContextCF      local.ContextCredentialsFactory

        ClientProvider riaas.RegionalAPIClientProvider
        httpClient     *http.Client
        APIConfig      riaas.Config
}

var _ local.Provider = &amp;VPCFileProvider{}

// NewProvider initialises an instance of an IaaS provider.
func NewProvider(conf *vpcconfig.VPCFileConfig, k8sClient *k8s_utils.KubernetesClient, logger *zap.Logger) (local.Provider, error) <span class="cov8" title="1">{
        logger.Info("Entering NewProvider")

        if conf.VPCConfig == nil </span><span class="cov0" title="0">{
                return nil, errors.New("incomplete config for VPCFileProvider")
        }</span>

        <span class="cov8" title="1">if conf.VPCConfig.G2EndpointPrivateURL != "" </span><span class="cov8" title="1">{
                conf.VPCConfig.G2EndpointURL = conf.VPCConfig.G2EndpointPrivateURL
        }</span>

        //Set API Generation As 2
        <span class="cov8" title="1">conf.VPCConfig.G2VPCAPIGeneration = NEXTGenProvider

        //Set the APIVersion Date, it can be different in GC and NG
        if conf.VPCConfig.G2APIVersion != "" </span><span class="cov0" title="0">{
                conf.VPCConfig.APIVersion = conf.VPCConfig.G2APIVersion
        }</span>

        //set provider-type
        <span class="cov8" title="1">conf.VPCConfig.VPCBlockProviderType = VPCNextGen

        //Mark this as enabled/active
        conf.VPCConfig.VPCTypeEnabled = VPCNextGen

        contextCF, err := vpcauth.NewVPCContextCredentialsFactory(conf, k8sClient)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">timeoutString := conf.VPCConfig.VPCTimeout
        if timeoutString == "" || timeoutString == "0s" </span><span class="cov8" title="1">{
                logger.Info("Using VPC default timeout")
                timeoutString = "120s"
        }</span>
        <span class="cov8" title="1">timeout, err := time.ParseDuration(timeoutString)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">httpClient, err := config.GeneralCAHttpClientWithTimeout(timeout)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to prepare HTTP client", util.ZapError(err))
                return nil, err
        }</span>

        // SetRetryParameters sets the retry logic parameters
        <span class="cov8" title="1">SetRetryParameters(conf.VPCConfig.MaxRetryAttempt, conf.VPCConfig.MaxRetryGap)
        provider := &amp;VPCFileProvider{
                timeout:        timeout,
                Config:         conf,
                tokenGenerator: &amp;tokenGenerator{config: conf.VPCConfig},
                ContextCF:      contextCF,
                httpClient:     httpClient,
                APIConfig: riaas.Config{
                        BaseURL:       conf.VPCConfig.G2EndpointURL,
                        HTTPClient:    httpClient,
                        APIVersion:    conf.VPCConfig.APIVersion,
                        APIGeneration: conf.VPCConfig.G2VPCAPIGeneration,
                        ResourceGroup: conf.VPCConfig.G2ResourceGroupID,
                },
        }
        userError.MessagesEn = userError.InitMessages()
        return provider, nil</span>
}

// ContextCredentialsFactory ...
func (vpcp *VPCFileProvider) ContextCredentialsFactory(zone *string) (local.ContextCredentialsFactory, error) <span class="cov8" title="1">{
        //  Datacenter name not required by VPC provider implementation
        return vpcp.ContextCF, nil
}</span>

// OpenSession opens a session on the provider
func (vpcp *VPCFileProvider) OpenSession(ctx context.Context, contextCredentials provider.ContextCredentials, ctxLogger *zap.Logger) (provider.Session, error) <span class="cov8" title="1">{
        ctxLogger.Info("Entering OpenSession")
        defer metrics.UpdateDurationFromStart(ctxLogger, "OpenSession", time.Now())
        defer func() </span><span class="cov8" title="1">{
                ctxLogger.Debug("Exiting OpenSession")
        }</span>()

        // validate that we have what we need - i.e. valid credentials
        <span class="cov8" title="1">if contextCredentials.Credential == "" </span><span class="cov8" title="1">{
                return nil, util.NewError("Error Insufficient Authentication", "No authentication credential provided")
        }</span>

        <span class="cov8" title="1">if vpcp.Config.ServerConfig.DebugTrace </span><span class="cov8" title="1">{
                vpcp.APIConfig.DebugWriter = os.Stdout
        }</span>

        <span class="cov8" title="1">if vpcp.ClientProvider == nil </span><span class="cov8" title="1">{
                vpcp.ClientProvider = riaas.DefaultRegionalAPIClientProvider{}
        }</span>
        <span class="cov8" title="1">ctxLogger.Debug("", zap.Reflect("apiConfig.BaseURL", vpcp.APIConfig.BaseURL))

        if ctx != nil &amp;&amp; ctx.Value(provider.RequestID) != nil </span><span class="cov0" title="0">{
                // set ContextID only of speicifed in the context
                vpcp.APIConfig.ContextID = fmt.Sprintf("%v", ctx.Value(provider.RequestID))
        }</span>
        <span class="cov8" title="1">client, err := vpcp.ClientProvider.New(vpcp.APIConfig)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Create a token for all other API calls
        <span class="cov8" title="1">token, err := getAccessToken(contextCredentials, ctxLogger)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">ctxLogger.Debug("", zap.Reflect("Token", token.Token))

        err = client.Login(token.Token)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Update retry logic default values
        <span class="cov8" title="1">if vpcp.Config.VPCConfig.MaxRetryAttempt &gt; 0 </span><span class="cov8" title="1">{
                ctxLogger.Debug("", zap.Reflect("MaxRetryAttempt", vpcp.Config.VPCConfig.MaxRetryAttempt))
                maxRetryAttempt = vpcp.Config.VPCConfig.MaxRetryAttempt
        }</span>
        <span class="cov8" title="1">if vpcp.Config.VPCConfig.MaxRetryGap &gt; 0 </span><span class="cov8" title="1">{
                ctxLogger.Debug("", zap.Reflect("MaxRetryGap", vpcp.Config.VPCConfig.MaxRetryGap))
                maxRetryGap = vpcp.Config.VPCConfig.MaxRetryGap
        }</span>

        <span class="cov8" title="1">vpcSession := &amp;VPCSession{
                VPCAccountID:       contextCredentials.IAMAccountID,
                Config:             vpcp.Config,
                ContextCredentials: contextCredentials,
                VolumeType:         "vpc-share",
                Provider:           VPC,
                Apiclient:          client,
                Logger:             ctxLogger,
                APIRetry:           NewFlexyRetryDefault(),
        }

        return vpcSession, nil</span>
}

// getAccessToken ...
func getAccessToken(creds provider.ContextCredentials, logger *zap.Logger) (token *iam.AccessToken, err error) <span class="cov8" title="1">{
        switch creds.AuthType </span>{
        case provider.IAMAccessToken:<span class="cov8" title="1">
                token = &amp;iam.AccessToken{Token: creds.Credential}</span>
        default:<span class="cov0" title="0">
                err = errors.New("unknown AuthType")</span>
        }
        <span class="cov8" title="1">return</span>
}

// getPrivateEndpoint ...
func getPrivateEndpoint(logger *zap.Logger, publicEndPoint string) string <span class="cov8" title="1">{
        logger.Info("In getPrivateEndpoint, RIaaS public endpoint", zap.Reflect("URL", publicEndPoint))
        if !strings.Contains(publicEndPoint, PrivatePrefix) </span><span class="cov8" title="1">{
                if len(publicEndPoint) &gt; HTTPSLength </span><span class="cov8" title="1">{
                        return BasePrivateURL + publicEndPoint[HTTPSLength:]
                }</span>
        } else<span class="cov8" title="1"> {
                return publicEndPoint
        }</span>
        <span class="cov8" title="1">return ""</span>
}
</pre>
		
		<pre class="file" id="file43" style="display: none">/**
 * Copyright 2021 IBM Corp.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// Package provider ...
package provider

import (
        "github.com/IBM/ibmcloud-volume-file-vpc/common/vpcclient/riaas"
        vpcconfig "github.com/IBM/ibmcloud-volume-file-vpc/file/vpcconfig"
        "github.com/IBM/ibmcloud-volume-interface/lib/provider"

        "go.uber.org/zap"
)

// VPCSession implements lib.Session
type VPCSession struct {
        provider.DefaultVolumeProvider
        VPCAccountID       string
        Config             *vpcconfig.VPCFileConfig
        ContextCredentials provider.ContextCredentials
        VolumeType         provider.VolumeType
        Provider           provider.VolumeProvider
        Apiclient          riaas.RegionalAPI
        APIVersion         string
        Logger             *zap.Logger
        APIRetry           FlexyRetry
        SessionError       error
}

const (

        // VPC storage provider
        VPC = provider.VolumeProvider("VPC-SHARE")
        // VolumeType ...
        VolumeType = provider.VolumeType("vpc-share")
)

// Close at present does nothing
func (*VPCSession) Close() {<span class="cov8" title="1">
        // Do nothing for now
}</span>

// GetProviderDisplayName returns the name of the VPC provider
func (vpcs *VPCSession) GetProviderDisplayName() provider.VolumeProvider <span class="cov8" title="1">{
        return VPC
}</span>

// ProviderName ...
func (vpcs *VPCSession) ProviderName() provider.VolumeProvider <span class="cov8" title="1">{
        return VPC
}</span>

// Type ...
func (vpcs *VPCSession) Type() provider.VolumeType <span class="cov8" title="1">{
        return VolumeType
}</span>
</pre>
		
		<pre class="file" id="file44" style="display: none">/**
 * Copyright 2021 IBM Corp.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// Package provider ...
package provider

import (
        "crypto/rsa"
        "errors"
        "io/ioutil"
        "path/filepath"
        "time"

        "github.com/golang-jwt/jwt/v4"
        "go.uber.org/zap"

        "github.com/IBM/ibmcloud-volume-interface/config"
        "github.com/IBM/ibmcloud-volume-interface/lib/provider"
        "github.com/IBM/ibmcloud-volume-interface/provider/auth"
        "github.com/IBM/ibmcloud-volume-interface/provider/local"
)

// tokenGenerator ...
type tokenGenerator struct {
        config *config.VPCProviderConfig

        tokenKID        string
        tokenTTL        time.Duration
        tokenBeforeTime time.Duration

        privateKey *rsa.PrivateKey // Secret. Do not export
}

// readConfig ...
func (tg *tokenGenerator) readConfig(logger zap.Logger) (err error) <span class="cov8" title="1">{
        logger.Info("Entering readConfig")
        defer func() </span><span class="cov8" title="1">{
                logger.Info("Exiting readConfig", zap.Duration("tokenTTL", tg.tokenTTL), zap.Duration("tokenBeforeTime", tg.tokenBeforeTime), zap.String("tokenKID", tg.tokenKID), local.ZapError(err))
        }</span>()

        <span class="cov8" title="1">if tg.privateKey != nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">path := filepath.Join(GetEtcPath(), tg.tokenKID)

        pem, err := ioutil.ReadFile(filepath.Clean(path))
        if err != nil </span><span class="cov8" title="1">{
                logger.Error("Error reading PEM", local.ZapError(err))
                return
        }</span>

        <span class="cov0" title="0">privateKey, err := jwt.ParseRSAPrivateKeyFromPEM(pem)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Error parsing PEM", local.ZapError(err))
                return
        }</span>

        <span class="cov0" title="0">tg.privateKey = privateKey

        return</span>
}

// buildToken ...
func (tg *tokenGenerator) buildToken(contextCredentials provider.ContextCredentials, ts time.Time, logger zap.Logger) (token *jwt.Token, err error) <span class="cov8" title="1">{
        logger.Info("Entering getJWTToken", zap.Reflect("contextCredentials", contextCredentials))
        defer func() </span><span class="cov8" title="1">{
                logger.Info("Exiting getJWTToken", zap.Reflect("token", token), local.ZapError(err))
        }</span>()

        <span class="cov8" title="1">err = tg.readConfig(logger)
        if err != nil </span><span class="cov8" title="1">{
                return
        }</span>

        <span class="cov0" title="0">claims := jwt.MapClaims{
                "iss": "armada",
                "exp": ts.Add(tg.tokenTTL).Unix(),
                "nbf": ts.Add(tg.tokenBeforeTime).Unix(),
                "iat": ts.Unix(),
        }

        switch </span>{
        case contextCredentials.UserID == "":<span class="cov0" title="0">
                errStr := "User ID is not configured"
                logger.Error(errStr)
                err = errors.New(errStr)
                return</span>

        case contextCredentials.AuthType == auth.IMSToken:<span class="cov0" title="0">
                claims["ims_user_id"] = contextCredentials.UserID</span>

        default:<span class="cov0" title="0">
                claims["ims_username"] = contextCredentials.UserID</span>
        }

        <span class="cov0" title="0">token = jwt.NewWithClaims(jwt.SigningMethodRS256, claims)
        token.Header["kid"] = tg.tokenKID

        return</span>
}

// getServiceToken ...
func (tg *tokenGenerator) getServiceToken(contextCredentials provider.ContextCredentials, logger zap.Logger) (signedToken *string, err error) <span class="cov8" title="1">{
        token, err := tg.buildToken(contextCredentials, time.Now(), logger)
        if err != nil </span><span class="cov8" title="1">{
                return
        }</span>

        <span class="cov0" title="0">signedString, err := token.SignedString(tg.privateKey)
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">signedToken = &amp;signedString

        return</span>
}

// GetEtcPath returns the path to the etc directory
func GetEtcPath() string <span class="cov8" title="1">{
        goPath := config.GetGoPath()
        srcPath := filepath.Join("src", "github.com", "IBM",
                "ibmcloud-volume-file-vpc")
        return filepath.Join(goPath, srcPath, "etc")
}</span>
</pre>
		
		<pre class="file" id="file45" style="display: none">/**
 * Copyright 2021 IBM Corp.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// Package provider ...
package provider

import (
        "strings"

        userError "github.com/IBM/ibmcloud-volume-file-vpc/common/messages"
        "github.com/IBM/ibmcloud-volume-file-vpc/common/vpcclient/models"
        "github.com/IBM/ibmcloud-volume-interface/lib/provider"
        "go.uber.org/zap"
)

// UpdateVolume PATCH to /volumes
func (vpcs *VPCSession) UpdateVolume(volumeTemplate provider.Volume) error <span class="cov8" title="1">{
        var existShare *models.Share
        var err error
        var etag string

        //Fetch existing volume Tags
        err = retryWithMinRetries(vpcs.Logger, func() error </span><span class="cov8" title="1">{
                // Get volume details
                existShare, etag, err = vpcs.Apiclient.FileShareService().GetFileShareEtag(volumeTemplate.VolumeID, vpcs.Logger)

                if err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>

                <span class="cov8" title="1">if existShare != nil &amp;&amp; existShare.Status == StatusStable </span><span class="cov8" title="1">{
                        vpcs.Logger.Info("Volume got valid (stable) state", zap.Reflect("etag", etag))
                }</span> else<span class="cov0" title="0"> {
                        return userError.GetUserError("VolumeNotInValidState", err, volumeTemplate.VolumeID)
                }</span>

                //If tags are equal then skip the UpdateFileShare RIAAS API call
                <span class="cov8" title="1">if ifTagsEqual(existShare.UserTags, volumeTemplate.VPCVolume.Tags) </span><span class="cov8" title="1">{
                        vpcs.Logger.Info("There is no change in user tags for volume, skipping the updateVolume for VPC IaaS... ", zap.Reflect("existShare", existShare.UserTags), zap.Reflect("volumeRequest", volumeTemplate.VPCVolume.Tags))
                        return nil
                }</span>

                //Append the existing tags with the requested input tags
                <span class="cov8" title="1">existShare.UserTags = append(existShare.UserTags, volumeTemplate.VPCVolume.Tags...)

                volume := &amp;models.Share{
                        UserTags: existShare.UserTags,
                }

                vpcs.Logger.Info("Calling VPC provider for volume UpdateVolumeWithTags...")

                err = vpcs.Apiclient.FileShareService().UpdateFileShareWithEtag(volumeTemplate.VolumeID, etag, volume, vpcs.Logger)
                return err</span>
        })

        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                vpcs.Logger.Error("Failed to update volume tags from VPC provider", zap.Reflect("BackendError", err))
                return userError.GetUserError("FailedToUpdateVolume", err, volumeTemplate.VolumeID)
        }</span>

        <span class="cov8" title="1">return err</span>
}

// ifTagsEqual will check if there is change to existing tags
func ifTagsEqual(existingTags []string, newTags []string) bool <span class="cov8" title="1">{
        //Join slice into a string
        tags := strings.ToLower(strings.Join(existingTags, ","))
        for _, v := range newTags </span><span class="cov8" title="1">{
                if !strings.Contains(tags, strings.ToLower(v)) </span><span class="cov8" title="1">{
                        //Tags are different
                        return false
                }</span>
        }
        //Tags are equal
        <span class="cov8" title="1">return true</span>
}
</pre>
		
		<pre class="file" id="file46" style="display: none">/**
 * Copyright 2021 IBM Corp.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// Package provider ...
package provider

import (
        "strconv"
        "strings"
        "time"

        "github.com/IBM/ibmcloud-volume-file-vpc/common/vpcclient/models"
        "github.com/IBM/ibmcloud-volume-interface/lib/provider"
        "go.uber.org/zap"
)

// maxRetryAttempt ...
var maxRetryAttempt = 10

// minRetryAttempt ...
var minRetryAttempt = 5

// maxRetryGap ...
var maxRetryGap = 60

// retryGap ...
var retryGap = 10

// ConstantRetryGap ...
const (
        ConstantRetryGap     = 10 // seconds
        SecurityGroup        = "security_group"
        EncryptionTrasitMode = "user_managed"
        pageSize             = 50
)

var volumeIDPartsCount = 5

// TODO need to introduce file share related to error codes
var skipErrorCodes = map[string]bool{
        "shares_profile_iops_not_allowed":           true,
        "shares_profile_capacity_invalid":           true,
        "shares_profile_capacity_iops_invalid":      true,
        "shares_encryption_key_crn_invalid":         true,
        "shares_zone_not_found":                     true,
        "shares_bad_request":                        true,
        "shares_resource_group_bad_request":         true,
        "shares_vpc_not_found":                      true,
        "shares_not_found":                          true,
        "shares_target_not_found":                   true,
        "shares_target_one_per_vpc":                 true,
        "bad_field":                                 true,
        "shares_name_duplicate":                     true,
        "shares_subnet_zone_mismatch":               true,
        "targets_primary_ip_id_required":            true,
        "targets_subnet_and_primary_ip_missing":     true,
        "targets_primary_ip_not_related_to_subnet":  true,
        "shares_target_vpc_and_network_interface":   true,
        "shares_security_group_id_invalid":          true,
        "targets_primary_ip_address_already_in_use": true,
        "reserved_ip_not_found":                     true,
        "shares_subnet_not_found":                   true,
        "targets_subnet_all_addresses_taken":        true,
        "InvalidArgument":                           true,
        "shares_status_pending":                     false,
        "internal_error":                            false,
        "invalid_route":                             true,
        "service_error":                             false,
        "shares_bad_field_for_rfs_profile":          true,
        "shares_profile_bandwidth_not_allowed":      true,
        "shares_bandwidth_invalid":                  true,
        "shares_not_implemented":                    true,
}

// retry ...
func retry(logger *zap.Logger, retryfunc func() error) error <span class="cov8" title="1">{
        var err error

        for i := 0; i &lt; maxRetryAttempt; i++ </span><span class="cov8" title="1">{
                if i &gt; 0 </span><span class="cov8" title="1">{
                        time.Sleep(time.Duration(retryGap) * time.Second)
                }</span>
                <span class="cov8" title="1">err = retryfunc()
                if err != nil </span><span class="cov8" title="1">{
                        //Skip retry for the below type of Errors
                        modelError, ok := err.(*models.Error)
                        if !ok </span><span class="cov8" title="1">{
                                continue</span>
                        }
                        <span class="cov8" title="1">if skipRetry(modelError) </span><span class="cov0" title="0">{
                                break</span>
                        }
                        <span class="cov8" title="1">if i &gt;= 1 </span><span class="cov8" title="1">{
                                retryGap = 2 * retryGap
                                if retryGap &gt; maxRetryGap </span><span class="cov8" title="1">{
                                        retryGap = maxRetryGap
                                }</span>
                        }
                        <span class="cov8" title="1">if (i + 1) &lt; maxRetryAttempt </span><span class="cov8" title="1">{
                                logger.Info("Error while executing the function. Re-attempting execution ..", zap.Int("attempt..", i+2), zap.Int("retry-gap", retryGap), zap.Int("max-retry-Attempts", maxRetryAttempt), zap.Error(err))
                        }</span>
                        <span class="cov8" title="1">continue</span>
                }
                <span class="cov8" title="1">return err</span>
        }
        <span class="cov8" title="1">return err</span>
}

// retry ...
func retryWithMinRetries(logger *zap.Logger, retryfunc func() error) error <span class="cov8" title="1">{
        var err error
        retryGap := 10
        for i := 0; i &lt; minRetryAttempt; i++ </span><span class="cov8" title="1">{
                if i &gt; 0 </span><span class="cov8" title="1">{
                        time.Sleep(time.Duration(retryGap) * time.Second)
                }</span>
                <span class="cov8" title="1">err = retryfunc()
                if err != nil </span><span class="cov8" title="1">{
                        logger.Info("err object is not nil", zap.Reflect("ERR", err))
                        //Skip retry for the below type of Errors
                        modelError, ok := err.(*models.Error)
                        if !ok </span><span class="cov8" title="1">{
                                continue</span>
                        }
                        <span class="cov0" title="0">if skipRetry(modelError) </span><span class="cov0" title="0">{
                                break</span>
                        }
                        <span class="cov0" title="0">if i &gt;= 1 </span><span class="cov0" title="0">{
                                retryGap = 2 * retryGap
                                if retryGap &gt; maxRetryGap </span><span class="cov0" title="0">{
                                        retryGap = maxRetryGap
                                }</span>
                        }
                        <span class="cov0" title="0">if (i + 1) &lt; minRetryAttempt </span><span class="cov0" title="0">{
                                logger.Info("Error while executing the function. Re-attempting execution ..", zap.Int("attempt..", i+2), zap.Int("retry-gap", retryGap), zap.Int("max-retry-Attempts", minRetryAttempt), zap.Error(err))
                        }</span>
                        <span class="cov0" title="0">continue</span>
                }
                <span class="cov8" title="1">return err</span>
        }
        <span class="cov8" title="1">return err</span>
}

// skipRetry skip retry as per listed error codes
func skipRetry(err *models.Error) bool <span class="cov8" title="1">{
        for _, errorItem := range err.Errors </span><span class="cov8" title="1">{
                skipStatus, ok := skipErrorCodes[string(errorItem.Code)]
                if ok </span><span class="cov8" title="1">{
                        return skipStatus
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}

// skipRetryForObviousErrors skip retry as per listed error codes
func skipRetryForObviousErrors(err error) bool <span class="cov8" title="1">{

        // Only for RIaaS attachment related calls error
        riaasError, ok := err.(*models.Error)
        if ok </span><span class="cov0" title="0">{
                return skipRetry(riaasError)
        }</span>
        <span class="cov8" title="1">return false</span>
}

// FlexyRetry ...
type FlexyRetry struct {
        maxRetryAttempt int
        maxRetryGap     int
}

// NewFlexyRetryDefault ...
func NewFlexyRetryDefault() FlexyRetry <span class="cov8" title="1">{
        return FlexyRetry{
                // Default values as we configuration
                maxRetryAttempt: maxRetryAttempt,
                maxRetryGap:     maxRetryGap,
        }
}</span>

// NewFlexyRetry ...
func NewFlexyRetry(maxRtyAtmpt int, maxrRtyGap int) FlexyRetry <span class="cov0" title="0">{
        return FlexyRetry{
                maxRetryAttempt: maxRtyAtmpt,
                maxRetryGap:     maxrRtyGap,
        }
}</span>

// FlexyRetry ...
func (fRetry *FlexyRetry) FlexyRetry(logger *zap.Logger, funcToRetry func() (error, bool)) error <span class="cov8" title="1">{
        var err error
        var stopRetry bool
        for i := 0; i &lt; fRetry.maxRetryAttempt; i++ </span><span class="cov8" title="1">{
                if i &gt; 0 </span><span class="cov8" title="1">{
                        time.Sleep(time.Duration(retryGap) * time.Second)
                }</span>
                // Call function which required retry, retry is decided by function itself
                <span class="cov8" title="1">err, stopRetry = funcToRetry()
                if stopRetry </span><span class="cov8" title="1">{
                        break</span>
                }

                // Update retry gap as per exponentioal
                <span class="cov8" title="1">if i &gt;= 1 </span><span class="cov8" title="1">{
                        retryGap = 2 * retryGap
                        if retryGap &gt; fRetry.maxRetryGap </span><span class="cov8" title="1">{
                                retryGap = fRetry.maxRetryGap
                        }</span>
                }
                <span class="cov8" title="1">if (i + 1) &lt; fRetry.maxRetryAttempt </span><span class="cov8" title="1">{
                        logger.Info("UNEXPECTED RESULT, Re-attempting execution ..", zap.Int("attempt..", i+2),
                                zap.Int("retry-gap", retryGap), zap.Int("max-retry-Attempts", fRetry.maxRetryAttempt),
                                zap.Bool("stopRetry", stopRetry), zap.Error(err))
                }</span>
        }
        <span class="cov8" title="1">return err</span>
}

// FlexyRetryWithConstGap ...
func (fRetry *FlexyRetry) FlexyRetryWithConstGap(logger *zap.Logger, funcToRetry func() (error, bool)) error <span class="cov8" title="1">{
        var err error
        var stopRetry bool
        // lets have more number of try for wait for attach and detach specially
        totalAttempt := fRetry.maxRetryAttempt * 4 // 40 time as per default values i.e 400 seconds
        for i := 0; i &lt; totalAttempt; i++ </span><span class="cov8" title="1">{
                if i &gt; 0 </span><span class="cov8" title="1">{
                        time.Sleep(time.Duration(ConstantRetryGap) * time.Second)
                }</span>
                // Call function which required retry, retry is decided by function itself
                <span class="cov8" title="1">err, stopRetry = funcToRetry()
                if stopRetry </span><span class="cov8" title="1">{
                        break</span>
                }

                <span class="cov8" title="1">if (i + 1) &lt; totalAttempt </span><span class="cov8" title="1">{
                        logger.Info("UNEXPECTED RESULT from FlexyRetryWithConstGap, Re-attempting execution ..", zap.Int("attempt..", i+2),
                                zap.Int("retry-gap", ConstantRetryGap), zap.Int("max-retry-Attempts", totalAttempt),
                                zap.Bool("stopRetry", stopRetry), zap.Error(err))
                }</span>
        }
        <span class="cov8" title="1">return err</span>
}

// ToInt ...
func ToInt(valueInInt string) int <span class="cov8" title="1">{
        value, err := strconv.Atoi(valueInInt)
        if err != nil </span><span class="cov8" title="1">{
                return 0
        }</span>
        <span class="cov8" title="1">return value</span>
}

// ToInt64 ...
func ToInt64(valueInInt string) int64 <span class="cov8" title="1">{
        value, err := strconv.ParseInt(valueInInt, 10, 64)
        if err != nil </span><span class="cov8" title="1">{
                return 0
        }</span>
        <span class="cov8" title="1">return value</span>
}

// FromProviderToLibVolume converting vpc provider share type to generic lib volume type
func FromProviderToLibVolume(vpcVolume *models.Share, logger *zap.Logger) (libVolume *provider.Volume) <span class="cov8" title="1">{
        logger.Debug("Entry of FromProviderToLibVolume method...")
        defer logger.Debug("Exit from FromProviderToLibVolume method...")

        if vpcVolume == nil </span><span class="cov0" title="0">{
                logger.Info("Volume details are empty")
                return
        }</span>

        <span class="cov8" title="1">logger.Debug("Volume details of VPC client", zap.Reflect("models.Volume", vpcVolume))

        volumeCap := int(vpcVolume.Size)
        iops := strconv.Itoa(int(vpcVolume.Iops))
        bandwidth := vpcVolume.Bandwidth
        var createdDate time.Time
        if vpcVolume.CreatedAt != nil </span><span class="cov8" title="1">{
                createdDate = *vpcVolume.CreatedAt
        }</span>
        <span class="cov8" title="1">var profile *provider.Profile
        if vpcVolume.Profile != nil </span><span class="cov8" title="1">{
                profile = &amp;provider.Profile{
                        Name: vpcVolume.Profile.Name,
                }
        }</span>
        <span class="cov8" title="1">libVolume = &amp;provider.Volume{
                VolumeID: vpcVolume.ID,
                Provider: VPC,
                Capacity: &amp;volumeCap,
                Iops:     &amp;iops,
                VPCVolume: provider.VPCVolume{
                        Href:      vpcVolume.Href,
                        Profile:   profile,
                        Bandwidth: bandwidth,
                },
                VolumeType:   VolumeType,
                CreationTime: createdDate,
        }

        // Zone can be nil for some profiles (e.g., RFS)
        if vpcVolume.Zone != nil </span><span class="cov8" title="1">{
                libVolume.Az = vpcVolume.Zone.Name
        }</span>

        <span class="cov8" title="1">libVolume.CRN = vpcVolume.CRN

        var respAccessPointlist = []provider.VolumeAccessPoint{}

        shareTargetlist := vpcVolume.ShareTargets

        //If there exists no share target return empty list
        if shareTargetlist == nil || len(*shareTargetlist) == 0 </span><span class="cov8" title="1">{
                libVolume.VolumeAccessPoints = &amp;respAccessPointlist
                return
        }</span>

        <span class="cov8" title="1">for _, shareTargetItem := range *shareTargetlist </span><span class="cov8" title="1">{
                volumeAccessPointResponse := FromProviderToLibVolumeAccessPoint(&amp;shareTargetItem, logger)
                respAccessPointlist = append(respAccessPointlist, *volumeAccessPointResponse)
        }</span>

        <span class="cov8" title="1">libVolume.VolumeAccessPoints = &amp;respAccessPointlist
        return</span>
}

// FromLibToProviderProfile converting vpc provider volume profile type from generic lib share profile type
func FromLibToProviderProfile(vpcProfile *models.ProfileDetails, logger *zap.Logger) (libProfile *provider.Profile) <span class="cov8" title="1">{
        logger.Debug("Entry of FromLibToProviderProfile method...")
        defer logger.Debug("Exit from FromLibToProviderProfile method...")

        if vpcProfile == nil </span><span class="cov0" title="0">{
                logger.Info("Profile details are empty")
                return nil
        }</span>

        <span class="cov8" title="1">logger.Debug("Profile details of VPC client", zap.Reflect("models.Profile", vpcProfile))

        profile := &amp;provider.Profile{
                Name:         vpcProfile.Name,
                Href:         vpcProfile.Href,
                Capacity:     (provider.CapIops)(vpcProfile.Capacity),
                Family:       vpcProfile.Family,
                Iops:         (provider.CapIops)(vpcProfile.Iops),
                ResourceType: vpcProfile.ResourceType,
        }

        return profile</span>
}

// FromProviderToLibVolumeAccessPoint converting vpc provider share target type to generic lib volume accessPoint Type
func FromProviderToLibVolumeAccessPoint(vpcShareTarget *models.ShareTarget, logger *zap.Logger) (libVolumeAccessPoint *provider.VolumeAccessPoint) <span class="cov8" title="1">{
        logger.Info("Entry of FromProviderToLibVolumeAccessPoint method...")
        defer logger.Info("Exit from FromProviderToLibVolumeAccessPoint method...")

        if vpcShareTarget == nil </span><span class="cov0" title="0">{
                logger.Info("VPC Share Target details are empty")
                return &amp;provider.VolumeAccessPoint{}
        }</span>

        <span class="cov8" title="1">logger.Debug("Share Target details of VPC client", zap.Reflect("models.ShareTarget", vpcShareTarget))

        libVolumeAccessPoint = &amp;provider.VolumeAccessPoint{
                ID:        vpcShareTarget.ID,
                Href:      vpcShareTarget.Href,
                Name:      vpcShareTarget.Name,
                Status:    vpcShareTarget.Status,
                MountPath: &amp;vpcShareTarget.MountPath,
                VPC:       vpcShareTarget.VPC,
                CreatedAt: vpcShareTarget.CreatedAt,
        }

        if vpcShareTarget.Zone != nil </span><span class="cov8" title="1">{
                libVolumeAccessPoint.Zone = &amp;provider.Zone{
                        Name: vpcShareTarget.Zone.Name,
                        Href: vpcShareTarget.Zone.Href,
                }

        }</span>

        <span class="cov8" title="1">return</span>
}

// IsValidVolumeIDFormat validating(gc has 5 parts and NG has 6 parts)
func IsValidVolumeIDFormat(volID string) bool <span class="cov8" title="1">{
        parts := strings.Split(volID, "-")
        return len(parts) &gt;= volumeIDPartsCount
}</span>

// SetRetryParameters sets the retry logic parameters
func SetRetryParameters(maxAttempts int, maxGap int) <span class="cov8" title="1">{
        if maxAttempts &gt; 0 </span><span class="cov8" title="1">{
                maxRetryAttempt = maxAttempts
        }</span>

        <span class="cov8" title="1">if maxGap &gt; 0 </span><span class="cov8" title="1">{
                maxRetryGap = maxGap
        }</span>
}

func roundUpSize(volumeSizeBytes int64, allocationUnitBytes int64) int64 <span class="cov8" title="1">{
        return (volumeSizeBytes + allocationUnitBytes - 1) / allocationUnitBytes
}</span>

// SkipRetryForIKS skip retry as per listed error codes
func SkipRetryForIKS(err error) bool <span class="cov0" title="0">{
        iksError, iksok := err.(*models.IksError)
        if iksok </span><span class="cov0" title="0">{
                skipStatus, ok := skipErrorCodes[iksError.Code]
                if ok </span><span class="cov0" title="0">{
                        return skipStatus
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}
</pre>
		
		<pre class="file" id="file47" style="display: none">/**
 * Copyright 2021 IBM Corp.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// Package provider ...
package provider

import (
        "time"

        userError "github.com/IBM/ibmcloud-volume-file-vpc/common/messages"
        "github.com/IBM/ibmcloud-volume-interface/lib/metrics"
        "github.com/IBM/ibmcloud-volume-interface/lib/provider"
        "go.uber.org/zap"
)

// WaitForCreateVolumeAccessPoint checks if file share target is created and is stable state
func (vpcs *VPCSession) WaitForCreateVolumeAccessPoint(AccessPointRequest provider.VolumeAccessPointRequest) (*provider.VolumeAccessPointResponse, error) <span class="cov8" title="1">{
        vpcs.Logger.Debug("Entry of WaitForCreateVolumeAccessPoint file method...")
        defer vpcs.Logger.Debug("Exit from WaitForCreateVolumeAccessPoint file method...")
        defer metrics.UpdateDurationFromStart(vpcs.Logger, "WaitForCreateVolumeAccessPoint", time.Now())

        vpcs.Logger.Info("Getting volume target details from VPC file provider...", zap.Reflect("VolumeID", AccessPointRequest.VolumeID), zap.Reflect("VPCID", AccessPointRequest.VPCID))

        vpcs.Logger.Info("Validating basic inputs for WaitForCreateVolumeAccessPoint method...", zap.Reflect("volumeAccessPointTemplate", AccessPointRequest))
        err := vpcs.validateVolumeAccessPointRequest(AccessPointRequest)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">var currentVolAccessPoint *provider.VolumeAccessPointResponse
        err = vpcs.APIRetry.FlexyRetryWithConstGap(vpcs.Logger, func() (error, bool) </span><span class="cov8" title="1">{
                currentVolAccessPoint, err = vpcs.GetVolumeAccessPoint(AccessPointRequest)
                if err != nil </span><span class="cov8" title="1">{
                        // Need to stop retry as there is an error while getting volume target
                        // considering that vpcs.GetVolumeAccessPoint already re-tried
                        return err, true
                }</span>
                // Stop retry in case of volume target is stable
                <span class="cov8" title="1">return err, currentVolAccessPoint != nil &amp;&amp; currentVolAccessPoint.Status == StatusStable</span>
        })

        // Success case, checks are required in case of timeout happened and volume is still not attached state
        <span class="cov8" title="1">if err == nil &amp;&amp; (currentVolAccessPoint != nil &amp;&amp; currentVolAccessPoint.Status == StatusStable) </span><span class="cov8" title="1">{
                return currentVolAccessPoint, nil
        }</span>

        <span class="cov8" title="1">userErr := userError.GetUserError(string(userError.CreateVolumeAccessPointTimedOut), nil, AccessPointRequest.VolumeID, AccessPointRequest.AccessPointID)
        vpcs.Logger.Info("Wait for AccessPoint creation timed out", zap.Error(userErr))

        return nil, userErr</span>
}
</pre>
		
		<pre class="file" id="file48" style="display: none">/**
 * Copyright 2021 IBM Corp.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// Package provider ...
package provider

import (
        "time"

        userError "github.com/IBM/ibmcloud-volume-file-vpc/common/messages"
        "github.com/IBM/ibmcloud-volume-interface/lib/metrics"
        "github.com/IBM/ibmcloud-volume-interface/lib/provider"
        util "github.com/IBM/ibmcloud-volume-interface/lib/utils"
        "go.uber.org/zap"
)

// WaitForDeleteVolumeAccessPoint waits for file share target to be deleted. e.g waits till no file share target is found
func (vpcs *VPCSession) WaitForDeleteVolumeAccessPoint(deleteAccessPointRequest provider.VolumeAccessPointRequest) error <span class="cov8" title="1">{
        vpcs.Logger.Debug("Entry of WaitForDeleteVolumeAccessPoint method...")
        defer vpcs.Logger.Debug("Exit from WaitForDeleteVolumeAccessPoint method...")
        defer metrics.UpdateDurationFromStart(vpcs.Logger, "WaitForDeleteVolumeAccessPoint", time.Now())
        var err error
        vpcs.Logger.Info("Validating basic inputs for WaitForDeleteVolumeAccessPoint method...", zap.Reflect("deleteAccessPointRequest", deleteAccessPointRequest))
        err = vpcs.validateVolumeAccessPointRequest(deleteAccessPointRequest)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">err = vpcs.APIRetry.FlexyRetryWithConstGap(vpcs.Logger, func() (error, bool) </span><span class="cov8" title="1">{
                _, err := vpcs.GetVolumeAccessPoint(deleteAccessPointRequest)
                // In case of error we should not retry as there are two conditions for error
                // 1- some issues at endpoint side --&gt; Which is already covered in vpcs.GetVolumeAccessPoint
                // 2- AccessPoint not found i.e err != nil --&gt; in this case we should not re-try as it has been deleted
                if err != nil </span><span class="cov8" title="1">{
                        return err, true
                }</span>
                <span class="cov8" title="1">return err, false</span>
        })

        // Could be a success case
        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                if errMsg, ok := err.(util.Message); ok </span><span class="cov8" title="1">{
                        if errMsg.Code == userError.AccessPointWithAPIDFindFailed </span><span class="cov8" title="1">{
                                vpcs.Logger.Info("Volume AccessPoint delete is complete")
                                return nil
                        }</span>
                }
        }

        <span class="cov8" title="1">userErr := userError.GetUserError(string(userError.DeleteVolumeAccessPointTimedOut), err, deleteAccessPointRequest.VolumeID, deleteAccessPointRequest.AccessPointID)
        vpcs.Logger.Info("Wait for delete AccessPoint timed out", zap.Error(userErr))
        return userErr</span>
}
</pre>
		
		<pre class="file" id="file49" style="display: none">/**
 * Copyright 2021 IBM Corp.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// Package provider ...
package provider

import (
        "time"

        userError "github.com/IBM/ibmcloud-volume-file-vpc/common/messages"
        "github.com/IBM/ibmcloud-volume-file-vpc/common/vpcclient/models"
        "github.com/IBM/ibmcloud-volume-interface/lib/metrics"
        "go.uber.org/zap"
)

// WaitForValidVolumeState checks the file share for valid status
func WaitForValidVolumeState(vpcs *VPCSession, volumeID string) (err error) <span class="cov8" title="1">{
        vpcs.Logger.Debug("Entry of WaitForValidVolumeState file method...")
        defer vpcs.Logger.Debug("Exit from WaitForValidVolumeState file method...")
        defer metrics.UpdateDurationFromStart(vpcs.Logger, "WaitForValidVolumeState", time.Now())

        vpcs.Logger.Info("Getting file share details from VPC file provider...", zap.Reflect("VolumeID", volumeID))

        var volume *models.Share
        err = retry(vpcs.Logger, func() error </span><span class="cov8" title="1">{
                volume, err = vpcs.Apiclient.FileShareService().GetFileShare(volumeID, vpcs.Logger)
                if err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>
                <span class="cov8" title="1">vpcs.Logger.Info("Getting file share details from VPC provider...", zap.Reflect("volume", volume))
                if volume != nil &amp;&amp; volume.Status == StatusStable </span><span class="cov8" title="1">{
                        vpcs.Logger.Info("Volume got valid (stable) state", zap.Reflect("VolumeDetails", volume))
                        return nil
                }</span>
                <span class="cov8" title="1">return userError.GetUserError("VolumeNotInValidState", err, volumeID)</span>
        })

        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                vpcs.Logger.Info("Volume could not get valid (stable) state", zap.Reflect("VolumeDetails", volume))
                return userError.GetUserError("VolumeNotInValidState", err, volumeID)
        }</span>

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file50" style="display: none">/**
 * Copyright 2021 IBM Corp.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// Package utils ...
package utils

import (
        "errors"

        "go.uber.org/zap"
        "golang.org/x/net/context"

        "github.com/IBM/ibmcloud-volume-file-vpc/common/registry"
        vpc_provider "github.com/IBM/ibmcloud-volume-file-vpc/file/provider"
        vpcfileconfig "github.com/IBM/ibmcloud-volume-file-vpc/file/vpcconfig"
        iks_vpc_provider "github.com/IBM/ibmcloud-volume-file-vpc/iks/provider"
        "github.com/IBM/ibmcloud-volume-interface/lib/provider"
        util "github.com/IBM/ibmcloud-volume-interface/lib/utils"
        "github.com/IBM/ibmcloud-volume-interface/provider/local"
        "github.com/IBM/secret-utils-lib/pkg/k8s_utils"
)

// InitProviders initialization for all providers as per configurations
func InitProviders(conf *vpcfileconfig.VPCFileConfig, k8sClient *k8s_utils.KubernetesClient, logger *zap.Logger) (registry.Providers, error) <span class="cov8" title="1">{
        var haveProviders bool
        providerRegistry := &amp;registry.ProviderRegistry{}

        // VPC provider registration
        if conf.VPCConfig != nil &amp;&amp; conf.VPCConfig.Enabled </span><span class="cov8" title="1">{
                logger.Info("Configuring VPC File Provider")
                prov, err := vpc_provider.NewProvider(conf, k8sClient, logger)
                if err != nil </span><span class="cov8" title="1">{
                        logger.Info("VPC file provider error!")
                        return nil, err
                }</span>
                <span class="cov8" title="1">providerRegistry.Register(conf.VPCConfig.VPCVolumeType, prov)
                haveProviders = true</span>
        }

        // IKS provider registration
        <span class="cov8" title="1">if conf.IKSConfig != nil &amp;&amp; conf.IKSConfig.Enabled </span><span class="cov8" title="1">{
                logger.Info("Configuring IKS-VPC FILE Provider")
                prov, err := iks_vpc_provider.NewProvider(conf, k8sClient, logger)
                if err != nil </span><span class="cov8" title="1">{
                        logger.Error("VPC file provider error!")
                        return nil, err
                }</span>
                <span class="cov8" title="1">providerRegistry.Register(conf.IKSConfig.IKSFileProviderName, prov)
                haveProviders = true</span>
        }

        <span class="cov8" title="1">if haveProviders </span><span class="cov8" title="1">{
                logger.Info("Provider registration done!!!")
                return providerRegistry, nil
        }</span>

        <span class="cov8" title="1">return nil, errors.New("no providers registered")</span>
}

// OpenProviderSession ...
func OpenProviderSession(prov local.Provider, vpcfileconf *vpcfileconfig.VPCFileConfig, providers registry.Providers, providerID string, ctxLogger *zap.Logger) (session provider.Session, fatal bool, err error) <span class="cov8" title="1">{
        return OpenProviderSessionWithContext(context.TODO(), prov, vpcfileconf, providerID, ctxLogger)
}</span>

// OpenProviderSessionWithContext ...
func OpenProviderSessionWithContext(ctx context.Context, prov local.Provider, vpcfileconf *vpcfileconfig.VPCFileConfig, providerID string, ctxLogger *zap.Logger) (provider.Session, bool, error) <span class="cov8" title="1">{
        ctxLogger.Info("Fetching provider session")
        ccf, err := prov.ContextCredentialsFactory(nil)
        if err != nil </span><span class="cov8" title="1">{
                ctxLogger.Error("Unable to fetch credentials", local.ZapError(err))
                return nil, true, err
        }</span>
        <span class="cov8" title="1">contextCredentials, err := GenerateContextCredentials(vpcfileconf, providerID, ccf, ctxLogger)
        if err != nil </span><span class="cov8" title="1">{
                ctxLogger.Error("Unable to generate credentials", local.ZapError(err))
                return nil, true, err
        }</span>

        <span class="cov8" title="1">session, err := prov.OpenSession(ctx, contextCredentials, ctxLogger)
        if err != nil </span><span class="cov8" title="1">{
                ctxLogger.Error("Failed to open provider session", local.ZapError(err))
                return nil, true, err
        }</span>

        <span class="cov8" title="1">ctxLogger.Info("Successfully fetched provider session")
        return session, false, nil</span>
}

// GenerateContextCredentials ...
func GenerateContextCredentials(conf *vpcfileconfig.VPCFileConfig, providerID string, contextCredentialsFactory local.ContextCredentialsFactory, ctxLogger *zap.Logger) (provider.ContextCredentials, error) <span class="cov8" title="1">{
        ctxLogger.Info("Generating generateContextCredentials for ", zap.String("Provider ID", providerID))

        // Select appropriate authentication strategy
        switch </span>{
        case (conf.VPCConfig != nil &amp;&amp; providerID == conf.VPCConfig.VPCVolumeType):<span class="cov0" title="0">
                ctxLogger.Info("Calling provider/init_provider.go ForIAMAccessToken")
                return contextCredentialsFactory.ForIAMAccessToken(conf.VPCConfig.G2APIKey, ctxLogger)</span>

        case (conf.IKSConfig != nil &amp;&amp; providerID == conf.IKSConfig.IKSFileProviderName):<span class="cov8" title="1">
                return provider.ContextCredentials{}, nil</span> // Get credentials  in OpenSession method

        default:<span class="cov8" title="1">
                return provider.ContextCredentials{}, util.NewError("ErrorInsufficientAuthentication",
                        "Insufficient authentication credentials")</span>
        }
}
</pre>
		
		<pre class="file" id="file51" style="display: none">/**
 * Copyright 2024 IBM Corp.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// Package provider ...
package provider

import (
        "context"

        vpcauth "github.com/IBM/ibmcloud-volume-file-vpc/common/auth"
        userError "github.com/IBM/ibmcloud-volume-file-vpc/common/messages"
        "github.com/IBM/ibmcloud-volume-file-vpc/common/vpcclient/riaas"
        vpcprovider "github.com/IBM/ibmcloud-volume-file-vpc/file/provider"
        vpcconfig "github.com/IBM/ibmcloud-volume-file-vpc/file/vpcconfig"
        "github.com/IBM/ibmcloud-volume-interface/lib/provider"
        util "github.com/IBM/ibmcloud-volume-interface/lib/utils"
        utilReasonCode "github.com/IBM/ibmcloud-volume-interface/lib/utils/reasoncode"
        "github.com/IBM/ibmcloud-volume-interface/provider/local"
        "github.com/IBM/secret-utils-lib/pkg/k8s_utils"

        "go.uber.org/zap"
)

// IksVpcFileProvider  handles both IKS and  RIAAS sessions
type IksVpcFileProvider struct {
        vpcprovider.VPCFileProvider
        vpcFileProvider *vpcprovider.VPCFileProvider // Holds VPC provider. Requires to avoid recursive calls
        iksFileProvider *vpcprovider.VPCFileProvider // Holds IKS provider
}

var _ local.Provider = &amp;IksVpcFileProvider{}

// NewProvider handles both IKS and  RIAAS sessions
func NewProvider(conf *vpcconfig.VPCFileConfig, k8sClient *k8s_utils.KubernetesClient, logger *zap.Logger) (local.Provider, error) <span class="cov8" title="1">{
        var err error
        //Setup vpc provider
        provider, err := vpcprovider.NewProvider(conf, k8sClient, logger)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Error initializing VPC Provider", zap.Error(err))
                return nil, err
        }</span>
        <span class="cov8" title="1">vpcFileProvider, _ := provider.(*vpcprovider.VPCFileProvider)

        // Setup IKS provider
        provider, err = vpcprovider.NewProvider(conf, k8sClient, logger)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Error initializing IKS Provider", zap.Error(err))
                return nil, err
        }</span>
        <span class="cov8" title="1">iksFileProvider, _ := provider.(*vpcprovider.VPCFileProvider)

        //Overrider Base URL
        iksFileProvider.APIConfig.BaseURL = conf.VPCConfig.IKSTokenExchangePrivateURL
        // Setup IKS-VPC dual provider
        iksVpcFileProvider := &amp;IksVpcFileProvider{
                VPCFileProvider: *vpcFileProvider,
                vpcFileProvider: vpcFileProvider,
                iksFileProvider: iksFileProvider,
        }

        iksVpcFileProvider.iksFileProvider.ContextCF, err = vpcauth.NewVPCContextCredentialsFactory(iksVpcFileProvider.vpcFileProvider.Config, k8sClient)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Error initializing context credentials factory", zap.Error(err))
                return nil, err
        }</span>

        <span class="cov8" title="1">return iksVpcFileProvider, nil</span>
}

// OpenSession opens a session on the provider
func (iksp *IksVpcFileProvider) OpenSession(ctx context.Context, contextCredentials provider.ContextCredentials, ctxLogger *zap.Logger) (provider.Session, error) <span class="cov0" title="0">{
        ctxLogger.Info("Entering IksVpcFileProvider.OpenSession")

        defer func() </span><span class="cov0" title="0">{
                ctxLogger.Debug("Exiting IksVpcFileProvider.OpenSession")
        }</span>()
        <span class="cov0" title="0">ctxLogger.Info("Opening VPC file session")
        ccf, _ := iksp.vpcFileProvider.ContextCredentialsFactory(nil)
        ctxLogger.Info("Its IKS dual session. Getttng IAM token for  VPC file session")
        vpcContextCredentials, err := ccf.ForIAMAccessToken(iksp.iksFileProvider.Config.VPCConfig.G2APIKey, ctxLogger)
        if err != nil </span><span class="cov0" title="0">{
                ctxLogger.Error("Error occurred while generating IAM token for VPC", zap.Error(err))
                if util.ErrorReasonCode(err) == utilReasonCode.EndpointNotReachable </span><span class="cov0" title="0">{
                        userErr := userError.GetUserError(string(userError.EndpointNotReachable), err)
                        return nil, userErr
                }</span>
                <span class="cov0" title="0">if util.ErrorReasonCode(err) == utilReasonCode.Timeout </span><span class="cov0" title="0">{
                        userErr := userError.GetUserError(string(userError.Timeout), err)
                        return nil, userErr
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }
        <span class="cov0" title="0">session, err := iksp.vpcFileProvider.OpenSession(ctx, vpcContextCredentials, ctxLogger)
        if err != nil </span><span class="cov0" title="0">{
                ctxLogger.Error("Error occurred while opening VPCSession", zap.Error(err))
                return nil, err
        }</span>
        <span class="cov0" title="0">vpcSession, _ := session.(*vpcprovider.VPCSession)
        ctxLogger.Info("Opening IKS file session")

        ccf = iksp.iksFileProvider.ContextCF
        iksp.iksFileProvider.ClientProvider = riaas.IKSRegionalAPIClientProvider{}

        ctxLogger.Info("Its ISK dual session. Getttng IAM token for  IKS file session")
        iksContextCredentials, err := ccf.ForIAMAccessToken(iksp.iksFileProvider.Config.VPCConfig.G2APIKey, ctxLogger)
        if err != nil </span><span class="cov0" title="0">{
                ctxLogger.Warn("Error occurred while generating IAM token for IKS. But continue with VPC session alone. \n Share provisioning will work but cleanup on cluster deletion will failed.", zap.Error(err))
                session = &amp;vpcprovider.VPCSession{
                        Logger:       ctxLogger,
                        SessionError: err,
                } // Empty session to avoid Nil references.
        }</span> else<span class="cov0" title="0"> {
                session, err = iksp.iksFileProvider.OpenSession(ctx, iksContextCredentials, ctxLogger)
                if err != nil </span><span class="cov0" title="0">{
                        ctxLogger.Error("Error occurred while opening IKSSession", zap.Error(err))
                }</span>
        }

        <span class="cov0" title="0">iksSession, _ := session.(*vpcprovider.VPCSession)

        // Setup Dual Session that handles for VPC and IKS connections
        vpcIksSession := IksVpcSession{
                VPCSession: *vpcSession,
                IksSession: iksSession,
        }
        ctxLogger.Debug("IksVpcSession", zap.Reflect("IksVpcSession", vpcIksSession))
        return &amp;vpcIksSession, nil</span>
}

// ContextCredentialsFactory ...
func (iksp *IksVpcFileProvider) ContextCredentialsFactory(zone *string) (local.ContextCredentialsFactory, error) <span class="cov0" title="0">{
        return iksp.iksFileProvider.ContextCF, nil
}</span>
</pre>
		
		<pre class="file" id="file52" style="display: none">/**
 * Copyright 2024 IBM Corp.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// Package provider ...
package provider

import (
        vpcprovider "github.com/IBM/ibmcloud-volume-file-vpc/file/provider"
        "github.com/IBM/ibmcloud-volume-interface/lib/provider"
)

// IksVpcSession implements lib.Session for VPC IKS dual session
type IksVpcSession struct {
        vpcprovider.VPCSession                         // Holds VPC/Riaas session by default
        IksSession             *vpcprovider.VPCSession // Holds IKS session
}

var _ provider.Session = &amp;IksVpcSession{}

const (
        // Provider storage provider
        Provider = provider.VolumeProvider("VPC-SHARE")
        // VolumeType ...
        VolumeType = provider.VolumeType("vpc-share")
)

// Close at present does nothing
func (vpcIks *IksVpcSession) Close() {<span class="cov8" title="1">
        // Do nothing for now
}</span>

// GetProviderDisplayName returns the name of the VPC provider
func (vpcIks *IksVpcSession) GetProviderDisplayName() provider.VolumeProvider <span class="cov8" title="1">{
        return Provider
}</span>

// ProviderName ...
func (vpcIks *IksVpcSession) ProviderName() provider.VolumeProvider <span class="cov8" title="1">{
        return Provider
}</span>

// Type ...
func (vpcIks *IksVpcSession) Type() provider.VolumeType <span class="cov8" title="1">{
        return VolumeType
}</span>
</pre>
		
		<pre class="file" id="file53" style="display: none">/**
 * Copyright 2024 IBM Corp.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// Package provider ...
package provider

import (
        "strconv"
        "time"

        userError "github.com/IBM/ibmcloud-volume-file-vpc/common/messages"
        vpc_provider "github.com/IBM/ibmcloud-volume-file-vpc/file/provider"
        "github.com/IBM/ibmcloud-volume-interface/lib/metrics"
        "github.com/IBM/ibmcloud-volume-interface/lib/provider"
        "go.uber.org/zap"
)

const (
        //ClusterIDTagName ...
        ClusterIDTagName = "clusterid"
        //VolumeStatus ...
        VolumeStatus = "status"
)

// UpdateVolume updates the volume with given information
func (vpcIks *IksVpcSession) UpdateVolume(volumeRequest provider.Volume) (err error) <span class="cov0" title="0">{
        vpcIks.Logger.Debug("Entry of UpdateVolume method...")
        defer vpcIks.Logger.Debug("Exit from UpdateVolume method...")
        defer metrics.UpdateDurationFromStart(vpcIks.Logger, "UpdateVolume", time.Now())

        vpcIks.Logger.Info("Basic validation for UpdateVolume request... ", zap.Reflect("RequestedVolumeDetails", volumeRequest))

        // Build the template to send to backend
        pvcTemplate := NewUpdatePVC(volumeRequest)
        err = validateVolumeRequest(volumeRequest)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">vpcIks.Logger.Info("Successfully validated inputs for UpdateVolume request... ")

        vpcIks.Logger.Info("Calling  provider for volume update...")
        err = vpcIks.APIRetry.FlexyRetry(vpcIks.Logger, func() (error, bool) </span><span class="cov0" title="0">{
                err = vpcIks.IksSession.Apiclient.FileShareService().UpdateVolume(&amp;pvcTemplate, vpcIks.Logger)
                return err, err == nil || vpc_provider.SkipRetryForIKS(err)
        }</span>)

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                vpcIks.Logger.Debug("Failed to update volume", zap.Reflect("BackendError", err))
                return userError.GetUserError("UpdateFailed", err)
        }</span>

        <span class="cov0" title="0">return err</span>
}

// validateVolumeRequest validating volume request
func validateVolumeRequest(volumeRequest provider.Volume) error <span class="cov8" title="1">{
        // Volume name should not be empty
        if len(volumeRequest.VolumeID) == 0 </span><span class="cov8" title="1">{
                return userError.GetUserError("ErrorRequiredFieldMissing", nil, "VolumeID")
        }</span>
        // Provider name should not be empty
        <span class="cov8" title="1">if len(volumeRequest.Provider) == 0 </span><span class="cov8" title="1">{
                return userError.GetUserError("ErrorRequiredFieldMissing", nil, "Provider")
        }</span>
        // VolumeType  should not be empty
        <span class="cov8" title="1">if len(volumeRequest.VolumeType) == 0 </span><span class="cov8" title="1">{
                return userError.GetUserError("ErrorRequiredFieldMissing", nil, "VolumeType")
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// Only for v2/storage/updateVolume
// NewUpdatePVC creates model UpdatePVC from provider volume
func NewUpdatePVC(volumeRequest provider.Volume) provider.UpdatePVC <span class="cov8" title="1">{
        // Build the template to send to backend

        pvc := provider.UpdatePVC{
                ID:         volumeRequest.VolumeID,
                CRN:        volumeRequest.CRN,
                Tags:       volumeRequest.VPCVolume.Tags,
                Provider:   string(volumeRequest.Provider),
                VolumeType: string(volumeRequest.VolumeType),
        }
        if volumeRequest.Name != nil </span><span class="cov8" title="1">{
                pvc.Name = *volumeRequest.Name
        }</span>
        <span class="cov8" title="1">if volumeRequest.Capacity != nil </span><span class="cov8" title="1">{
                pvc.Capacity = int64(*volumeRequest.Capacity)
        }</span>

        <span class="cov8" title="1">if volumeRequest.Iops != nil </span><span class="cov8" title="1">{
                value, err := strconv.ParseInt(*volumeRequest.Iops, 10, 64)
                if err != nil </span><span class="cov0" title="0">{
                        pvc.Iops = 0
                }</span>
                <span class="cov8" title="1">pvc.Iops = value</span>
        }

        <span class="cov8" title="1">pvc.Cluster = volumeRequest.Attributes[ClusterIDTagName]
        pvc.Status = volumeRequest.Attributes[VolumeStatus]

        return pvc</span>
}
</pre>
		
		<pre class="file" id="file54" style="display: none">/*
Copyright 2018 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at
    http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package ibmcloudprovider

import (
        "bytes"
        "os"
        "path/filepath"
        "testing"

        provider_util "github.com/IBM/ibmcloud-volume-file-vpc/file/utils"
        vpcconfig "github.com/IBM/ibmcloud-volume-file-vpc/file/vpcconfig"
        "github.com/IBM/ibmcloud-volume-interface/config"
        "github.com/IBM/ibmcloud-volume-interface/lib/provider"
        "github.com/IBM/ibmcloud-volume-interface/lib/provider/fake"
        "github.com/IBM/ibmcloud-volume-interface/provider/local"
        "github.com/IBM/secret-utils-lib/pkg/k8s_utils"
        "go.uber.org/zap"
        "go.uber.org/zap/zapcore"
        "golang.org/x/net/context"
)

const (
        // TestProviderAccountID ...
        TestProviderAccountID = "test-provider-account"

        // TestProviderAccessToken ...
        TestProviderAccessToken = "test-provider-access-token"

        // TestIKSAccountID ...
        TestIKSAccountID = "test-iks-account"

        // TestZone ...
        TestZone = "test-zone"

        // IAMURL ...
        IAMURL = "test-iam-url"

        // IAMClientID ...
        IAMClientID = "test-iam_client_id"

        // IAMClientSecret ...
        IAMClientSecret = "test-iam_client_secret"

        // IAMAPIKey ...
        IAMAPIKey = "test-iam_api_key"

        // RefreshToken ...
        RefreshToken = "test-refresh_token"

        // TestEndpointURL ...
        TestEndpointURL = "http://some_endpoint"

        // TestAPIVersion ...
        TestAPIVersion = "2019-07-02"
)

// GetTestLogger ...
func GetTestLogger(t *testing.T) (logger *zap.Logger, teardown func()) <span class="cov8" title="1">{

        atom := zap.NewAtomicLevel()
        atom.SetLevel(zap.DebugLevel)

        encoderCfg := zap.NewProductionEncoderConfig()
        encoderCfg.TimeKey = "timestamp"
        encoderCfg.EncodeTime = zapcore.ISO8601TimeEncoder

        buf := &amp;bytes.Buffer{}

        logger = zap.New(
                zapcore.NewCore(
                        zapcore.NewJSONEncoder(encoderCfg),
                        zapcore.AddSync(buf),
                        atom,
                ),
                zap.AddCaller(),
        )

        teardown = func() </span><span class="cov8" title="1">{
                _ = logger.Sync()
                if t.Failed() </span><span class="cov0" title="0">{
                        t.Log(buf)
                }</span>
        }
        <span class="cov8" title="1">return</span>
}

// GetTestProvider ...
func GetTestProvider(t *testing.T, logger *zap.Logger) (*IBMCloudStorageProvider, error) <span class="cov0" title="0">{
        logger.Info("GetTestProvider-Getting New test Provider")
        // vpcFileConfig struct
        vpcFileConfig := &amp;vpcconfig.VPCFileConfig{
                VPCConfig: &amp;config.VPCProviderConfig{
                        Enabled:         true,
                        VPCVolumeType:   "vpc-share",
                        EndpointURL:     TestEndpointURL,
                        VPCTimeout:      "30s",
                        MaxRetryAttempt: 5,
                        MaxRetryGap:     10,
                        APIVersion:      TestAPIVersion,
                        IamClientID:     IAMClientID,
                        IamClientSecret: IAMClientSecret,
                },
                ServerConfig: &amp;config.ServerConfig{
                        DebugTrace: true,
                },
        }
        // full config struct
        conf := &amp;config.Config{
                Server: &amp;config.ServerConfig{
                        DebugTrace: true,
                },
                Bluemix: &amp;config.BluemixConfig{
                        IamURL:          IAMURL,
                        IamClientID:     IAMClientID,
                        IamClientSecret: IAMClientSecret,
                        IamAPIKey:       IAMClientSecret,
                        RefreshToken:    RefreshToken,
                },
                VPC: &amp;config.VPCProviderConfig{
                        Enabled:         true,
                        VPCVolumeType:   "vpc-share",
                        EndpointURL:     TestEndpointURL,
                        VPCTimeout:      "30s",
                        MaxRetryAttempt: 5,
                        MaxRetryGap:     10,
                        APIVersion:      TestAPIVersion,
                },
                IKS: &amp;config.IKSConfig{
                        Enabled: true,
                },
        }

        // Prepare provider registry
        k8sClient, _ := k8s_utils.FakeGetk8sClientSet()
        pwd, err := os.Getwd()
        if err != nil </span><span class="cov0" title="0">{
                logger.Fatal("Failed to get current working directory, test related to read config will fail, error: %v", local.ZapError(err))
        }</span>

        <span class="cov0" title="0">clusterConfPath := filepath.Join(pwd, "..", "..", "test-fixtures", "valid", "cluster_info", "cluster-config.json")
        _ = k8s_utils.FakeCreateCM(k8sClient, clusterConfPath)

        secretConfPath := filepath.Join(pwd, "..", "..", "test-fixtures", "slconfig.toml")
        _ = k8s_utils.FakeCreateSecret(k8sClient, "DEFAULT", secretConfPath)
        registry, err := provider_util.InitProviders(vpcFileConfig, &amp;k8sClient, logger)
        if err != nil </span><span class="cov0" title="0">{
                logger.Fatal("Error configuring providers", local.ZapError(err))
        }</span>

        <span class="cov0" title="0">cloudProvider := &amp;IBMCloudStorageProvider{
                ProviderName:   "vpc-share",
                ProviderConfig: conf,
                Registry:       registry,
                ClusterID:      "",
        }
        logger.Info("Successfully read provider configuration...")
        return cloudProvider, nil</span>
}

// FakeIBMCloudStorageProvider Provider
type FakeIBMCloudStorageProvider struct {
        ProviderName   string
        ProviderConfig *config.Config
        ClusterID      string
        fakeSession    *fake.FakeSession
}

var _ CloudProviderInterface = &amp;FakeIBMCloudStorageProvider{}

// NewFakeIBMCloudStorageProvider ...
func NewFakeIBMCloudStorageProvider(configPath string, logger *zap.Logger) (*FakeIBMCloudStorageProvider, error) <span class="cov8" title="1">{
        return &amp;FakeIBMCloudStorageProvider{ProviderName: "FakeIBMCloudStorageProvider",
                ProviderConfig: &amp;config.Config{VPC: &amp;config.VPCProviderConfig{VPCVolumeType: "VPCFakeProvider"}},
                ClusterID:      "fake-cluster-id", fakeSession: &amp;fake.FakeSession{}}, nil
}</span>

// GetProviderSession ...
func (ficp *FakeIBMCloudStorageProvider) GetProviderSession(ctx context.Context, logger *zap.Logger) (provider.Session, error) <span class="cov8" title="1">{
        return ficp.fakeSession, nil
}</span>

// GetConfig ...
func (ficp *FakeIBMCloudStorageProvider) GetConfig() *config.Config <span class="cov8" title="1">{
        return ficp.ProviderConfig
}</span>

// GetClusterID ...
func (ficp *FakeIBMCloudStorageProvider) GetClusterID() string <span class="cov8" title="1">{
        return ficp.ClusterID
}</span>
</pre>
		
		<pre class="file" id="file55" style="display: none">/**
 * Copyright 2021 IBM Corp.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// Package ibmcloudprovider ...
package ibmcloudprovider

import (
        "fmt"
        "os"
        "time"

        "github.com/IBM/ibmcloud-volume-file-vpc/common/registry"
        provider_util "github.com/IBM/ibmcloud-volume-file-vpc/file/utils"
        vpcconfig "github.com/IBM/ibmcloud-volume-file-vpc/file/vpcconfig"
        "github.com/IBM/ibmcloud-volume-interface/config"
        "github.com/IBM/ibmcloud-volume-interface/lib/provider"
        "github.com/IBM/ibmcloud-volume-interface/provider/local"
        utilsConfig "github.com/IBM/secret-utils-lib/pkg/config"
        "github.com/IBM/secret-utils-lib/pkg/k8s_utils"
        "go.uber.org/zap"
        "golang.org/x/net/context"
)

// IBMCloudStorageProvider Provider
type IBMCloudStorageProvider struct {
        ProviderName   string
        ProviderConfig *config.Config
        Registry       registry.Providers
        ClusterID      string
}

var _ CloudProviderInterface = &amp;IBMCloudStorageProvider{}

// NewIBMCloudStorageProvider ...
func NewIBMCloudStorageProvider(clusterVolumeLabel string, k8sClient *k8s_utils.KubernetesClient, logger *zap.Logger) (*IBMCloudStorageProvider, error) <span class="cov8" title="1">{
        logger.Info("NewIBMCloudStorageProvider-Reading provider configuration...")
        // Load config file
        conf, err := config.ReadConfig(*k8sClient, logger)
        if err != nil </span><span class="cov8" title="1">{
                logger.Error("Error loading configuration")
                return nil, err
        }</span>
        // Get only VPC_API_VERSION, in "YYYY-MM-DD" format
        <span class="cov8" title="1">dateTime, err := time.Parse(time.DateOnly, conf.VPC.APIVersion)
        if err == nil </span><span class="cov8" title="1">{
                conf.VPC.APIVersion = fmt.Sprintf("%d-%02d-%02d", dateTime.Year(), dateTime.Month(), dateTime.Day())
        }</span> else<span class="cov0" title="0"> {
                logger.Warn("Failed to parse VPC_API_VERSION, setting default value")
                conf.VPC.APIVersion = "2025-08-05" // setting default values
        }</span>

        <span class="cov8" title="1">var clusterInfo utilsConfig.ClusterConfig
        if conf.IKS != nil &amp;&amp; conf.IKS.Enabled || os.Getenv("IKS_ENABLED") == "True" </span><span class="cov8" title="1">{
                logger.Info("Fetching clusterInfo")
                clusterInfo, err = utilsConfig.GetClusterInfo(*k8sClient, logger)
                if err != nil </span><span class="cov8" title="1">{
                        logger.Error("Unable to load ClusterInfo", local.ZapError(err))
                        return nil, err
                }</span>
                <span class="cov0" title="0">logger.Info("Fetched clusterInfo..")</span>
        }

        <span class="cov8" title="1">vpcFileConfig := &amp;vpcconfig.VPCFileConfig{
                VPCConfig:    conf.VPC,
                IKSConfig:    conf.IKS,
                ServerConfig: conf.Server,
        }

        // Prepare provider registry
        registry, err := provider_util.InitProviders(vpcFileConfig, k8sClient, logger)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Error configuring providers", local.ZapError(err))
                return nil, err
        }</span>

        <span class="cov8" title="1">var providerName string
        if conf.IKS.Enabled </span><span class="cov0" title="0">{
                providerName = conf.IKS.IKSFileProviderName
        }</span> else<span class="cov8" title="1"> if conf.VPC.Enabled </span><span class="cov8" title="1">{
                providerName = conf.VPC.VPCVolumeType
        }</span>
        <span class="cov8" title="1">cloudProvider := &amp;IBMCloudStorageProvider{
                ProviderName:   providerName,
                ProviderConfig: conf,
                Registry:       registry,
                ClusterID:      clusterInfo.ClusterID,
        }
        logger.Info("Successfully read provider configuration")
        return cloudProvider, nil</span>
}

// GetProviderSession ...
func (icp *IBMCloudStorageProvider) GetProviderSession(ctx context.Context, logger *zap.Logger) (provider.Session, error) <span class="cov0" title="0">{
        logger.Info("IBMCloudStorageProvider-GetProviderSession...")

        prov, err := icp.Registry.Get(icp.ProviderName)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Not able to get the said provider, might be its not registered", local.ZapError(err))
                return nil, err
        }</span>

        // Populating vpcfileConfig which is used to open session
        <span class="cov0" title="0">vpcfileConfig := &amp;vpcconfig.VPCFileConfig{
                VPCConfig:    icp.ProviderConfig.VPC,
                IKSConfig:    icp.ProviderConfig.IKS,
                ServerConfig: icp.ProviderConfig.Server,
        }

        session, _, err := provider_util.OpenProviderSessionWithContext(ctx, prov, vpcfileConfig, icp.ProviderName, logger)
        if err == nil </span><span class="cov0" title="0">{
                logger.Info("Successfully got the provider session", zap.Reflect("ProviderName", session.ProviderName()))
                return session, nil
        }</span>
        <span class="cov0" title="0">logger.Error("Failed to get provider session", zap.Reflect("Error", err))
        return nil, err</span>
}

// GetConfig ...
func (icp *IBMCloudStorageProvider) GetConfig() *config.Config <span class="cov0" title="0">{
        return icp.ProviderConfig
}</span>

// GetClusterID ...
func (icp *IBMCloudStorageProvider) GetClusterID() string <span class="cov0" title="0">{
        return icp.ClusterID
}</span>
</pre>
		
		<pre class="file" id="file56" style="display: none">// Code generated by counterfeiter. DO NOT EDIT.
package metadata

import (
        "sync"
)

type FakeNodeMetadata struct {
        GetRegionStub        func() string
        getRegionMutex       sync.RWMutex
        getRegionArgsForCall []struct {
        }
        getRegionReturns struct {
                result1 string
        }
        getRegionReturnsOnCall map[int]struct {
                result1 string
        }
        GetWorkerIDStub        func() string
        getWorkerIDMutex       sync.RWMutex
        getWorkerIDArgsForCall []struct {
        }
        getWorkerIDReturns struct {
                result1 string
        }
        getWorkerIDReturnsOnCall map[int]struct {
                result1 string
        }
        GetZoneStub        func() string
        getZoneMutex       sync.RWMutex
        getZoneArgsForCall []struct {
        }
        getZoneReturns struct {
                result1 string
        }
        getZoneReturnsOnCall map[int]struct {
                result1 string
        }
        invocations      map[string][][]interface{}
        invocationsMutex sync.RWMutex
}

func (fake *FakeNodeMetadata) GetRegion() string <span class="cov8" title="1">{
        fake.getRegionMutex.Lock()
        ret, specificReturn := fake.getRegionReturnsOnCall[len(fake.getRegionArgsForCall)]
        fake.getRegionArgsForCall = append(fake.getRegionArgsForCall, struct {
        }{})
        fake.recordInvocation("GetRegion", []interface{}{})
        fake.getRegionMutex.Unlock()
        if fake.GetRegionStub != nil </span><span class="cov0" title="0">{
                return fake.GetRegionStub()
        }</span>
        <span class="cov8" title="1">if specificReturn </span><span class="cov0" title="0">{
                return ret.result1
        }</span>
        <span class="cov8" title="1">fakeReturns := fake.getRegionReturns
        return fakeReturns.result1</span>
}

func (fake *FakeNodeMetadata) GetRegionCallCount() int <span class="cov0" title="0">{
        fake.getRegionMutex.RLock()
        defer fake.getRegionMutex.RUnlock()
        return len(fake.getRegionArgsForCall)
}</span>

func (fake *FakeNodeMetadata) GetRegionCalls(stub func() string) <span class="cov0" title="0">{
        fake.getRegionMutex.Lock()
        defer fake.getRegionMutex.Unlock()
        fake.GetRegionStub = stub
}</span>

func (fake *FakeNodeMetadata) GetRegionReturns(result1 string) <span class="cov8" title="1">{
        fake.getRegionMutex.Lock()
        defer fake.getRegionMutex.Unlock()
        fake.GetRegionStub = nil
        fake.getRegionReturns = struct {
                result1 string
        }{result1}
}</span>

func (fake *FakeNodeMetadata) GetRegionReturnsOnCall(i int, result1 string) <span class="cov0" title="0">{
        fake.getRegionMutex.Lock()
        defer fake.getRegionMutex.Unlock()
        fake.GetRegionStub = nil
        if fake.getRegionReturnsOnCall == nil </span><span class="cov0" title="0">{
                fake.getRegionReturnsOnCall = make(map[int]struct {
                        result1 string
                })
        }</span>
        <span class="cov0" title="0">fake.getRegionReturnsOnCall[i] = struct {
                result1 string
        }{result1}</span>
}

func (fake *FakeNodeMetadata) GetWorkerID() string <span class="cov8" title="1">{
        fake.getWorkerIDMutex.Lock()
        ret, specificReturn := fake.getWorkerIDReturnsOnCall[len(fake.getWorkerIDArgsForCall)]
        fake.getWorkerIDArgsForCall = append(fake.getWorkerIDArgsForCall, struct {
        }{})
        fake.recordInvocation("GetWorkerID", []interface{}{})
        fake.getWorkerIDMutex.Unlock()
        if fake.GetWorkerIDStub != nil </span><span class="cov0" title="0">{
                return fake.GetWorkerIDStub()
        }</span>
        <span class="cov8" title="1">if specificReturn </span><span class="cov0" title="0">{
                return ret.result1
        }</span>
        <span class="cov8" title="1">fakeReturns := fake.getWorkerIDReturns
        return fakeReturns.result1</span>
}

func (fake *FakeNodeMetadata) GetWorkerIDCallCount() int <span class="cov0" title="0">{
        fake.getWorkerIDMutex.RLock()
        defer fake.getWorkerIDMutex.RUnlock()
        return len(fake.getWorkerIDArgsForCall)
}</span>

func (fake *FakeNodeMetadata) GetWorkerIDCalls(stub func() string) <span class="cov0" title="0">{
        fake.getWorkerIDMutex.Lock()
        defer fake.getWorkerIDMutex.Unlock()
        fake.GetWorkerIDStub = stub
}</span>

func (fake *FakeNodeMetadata) GetWorkerIDReturns(result1 string) <span class="cov8" title="1">{
        fake.getWorkerIDMutex.Lock()
        defer fake.getWorkerIDMutex.Unlock()
        fake.GetWorkerIDStub = nil
        fake.getWorkerIDReturns = struct {
                result1 string
        }{result1}
}</span>

func (fake *FakeNodeMetadata) GetWorkerIDReturnsOnCall(i int, result1 string) <span class="cov0" title="0">{
        fake.getWorkerIDMutex.Lock()
        defer fake.getWorkerIDMutex.Unlock()
        fake.GetWorkerIDStub = nil
        if fake.getWorkerIDReturnsOnCall == nil </span><span class="cov0" title="0">{
                fake.getWorkerIDReturnsOnCall = make(map[int]struct {
                        result1 string
                })
        }</span>
        <span class="cov0" title="0">fake.getWorkerIDReturnsOnCall[i] = struct {
                result1 string
        }{result1}</span>
}

func (fake *FakeNodeMetadata) GetZone() string <span class="cov8" title="1">{
        fake.getZoneMutex.Lock()
        ret, specificReturn := fake.getZoneReturnsOnCall[len(fake.getZoneArgsForCall)]
        fake.getZoneArgsForCall = append(fake.getZoneArgsForCall, struct {
        }{})
        fake.recordInvocation("GetZone", []interface{}{})
        fake.getZoneMutex.Unlock()
        if fake.GetZoneStub != nil </span><span class="cov0" title="0">{
                return fake.GetZoneStub()
        }</span>
        <span class="cov8" title="1">if specificReturn </span><span class="cov0" title="0">{
                return ret.result1
        }</span>
        <span class="cov8" title="1">fakeReturns := fake.getZoneReturns
        return fakeReturns.result1</span>
}

func (fake *FakeNodeMetadata) GetZoneCallCount() int <span class="cov0" title="0">{
        fake.getZoneMutex.RLock()
        defer fake.getZoneMutex.RUnlock()
        return len(fake.getZoneArgsForCall)
}</span>

func (fake *FakeNodeMetadata) GetZoneCalls(stub func() string) <span class="cov0" title="0">{
        fake.getZoneMutex.Lock()
        defer fake.getZoneMutex.Unlock()
        fake.GetZoneStub = stub
}</span>

func (fake *FakeNodeMetadata) GetZoneReturns(result1 string) <span class="cov8" title="1">{
        fake.getZoneMutex.Lock()
        defer fake.getZoneMutex.Unlock()
        fake.GetZoneStub = nil
        fake.getZoneReturns = struct {
                result1 string
        }{result1}
}</span>

func (fake *FakeNodeMetadata) GetZoneReturnsOnCall(i int, result1 string) <span class="cov0" title="0">{
        fake.getZoneMutex.Lock()
        defer fake.getZoneMutex.Unlock()
        fake.GetZoneStub = nil
        if fake.getZoneReturnsOnCall == nil </span><span class="cov0" title="0">{
                fake.getZoneReturnsOnCall = make(map[int]struct {
                        result1 string
                })
        }</span>
        <span class="cov0" title="0">fake.getZoneReturnsOnCall[i] = struct {
                result1 string
        }{result1}</span>
}

func (fake *FakeNodeMetadata) Invocations() map[string][][]interface{} <span class="cov0" title="0">{
        fake.invocationsMutex.RLock()
        defer fake.invocationsMutex.RUnlock()
        fake.getRegionMutex.RLock()
        defer fake.getRegionMutex.RUnlock()
        fake.getWorkerIDMutex.RLock()
        defer fake.getWorkerIDMutex.RUnlock()
        fake.getZoneMutex.RLock()
        defer fake.getZoneMutex.RUnlock()
        copiedInvocations := map[string][][]interface{}{}
        for key, value := range fake.invocations </span><span class="cov0" title="0">{
                copiedInvocations[key] = value
        }</span>
        <span class="cov0" title="0">return copiedInvocations</span>
}

func (fake *FakeNodeMetadata) recordInvocation(key string, args []interface{}) <span class="cov8" title="1">{
        fake.invocationsMutex.Lock()
        defer fake.invocationsMutex.Unlock()
        if fake.invocations == nil </span><span class="cov8" title="1">{
                fake.invocations = map[string][][]interface{}{}
        }</span>
        <span class="cov8" title="1">if fake.invocations[key] == nil </span><span class="cov8" title="1">{
                fake.invocations[key] = [][]interface{}{}
        }</span>
        <span class="cov8" title="1">fake.invocations[key] = append(fake.invocations[key], args)</span>
}

var _ NodeMetadata = new(FakeNodeMetadata)
</pre>
		
		<pre class="file" id="file57" style="display: none">/**
 * Copyright 2022 IBM Corp.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// Package metadata ...
package metadata

import "go.uber.org/zap"

// InitMetadata ...
func InitMetadata(nodeName string, logger *zap.Logger) (NodeMetadata, error) <span class="cov8" title="1">{
        return &amp;nodeMetadataManager{
                zone:     "testzone",
                region:   "testregion",
                workerID: "testworkerid",
        }, nil
}</span>
</pre>
		
		<pre class="file" id="file58" style="display: none">/**
 * Copyright 2022 IBM Corp.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// Package metadata ...
package metadata

import (
        "context"
        "fmt"
        "strings"

        "go.uber.org/zap"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/client-go/kubernetes"
        "k8s.io/client-go/rest"
)

const (
        // NodeZoneLabel  Zone Label attached to node
        NodeZoneLabel = "failure-domain.beta.kubernetes.io/zone"

        // NodeRegionLabel Region Label attached to node
        NodeRegionLabel = "failure-domain.beta.kubernetes.io/region"

        // NodeInstanceIDLabel VPC ID label attached to satellite host
        NodeInstanceIDLabel = "ibm-cloud.kubernetes.io/vpc-instance-id"

        // MachineTypeLabel is the node label used to identify the cluster type (upi,ipi,etc)
        MachineTypeLabel = "ibm-cloud.kubernetes.io/machine-type"

        // UPI is the expected value assigned to machine-type label on satellite cluster nodes
        UPI = "upi"
)

// NodeMetadata is a fakeable interface exposing necessary data
type NodeMetadata interface {
        // GetZone ...
        GetZone() string

        // GetRegion ...
        GetRegion() string

        // GetWorkerID ...
        GetWorkerID() string
}

type nodeMetadataManager struct {
        zone     string
        region   string
        workerID string
}

// NodeInfo ...
//
//go:generate counterfeiter -o fake/fake_node_info.go --fake-name FakeNodeInfo . NodeInfo
type NodeInfo interface {
        NewNodeMetadata(logger *zap.Logger) (NodeMetadata, error)
}

// NodeInfoManager ...
type NodeInfoManager struct {
        NodeName string
}

var _ NodeMetadata = &amp;nodeMetadataManager{}

// NewNodeMetadata ...
func (nodeManager *NodeInfoManager) NewNodeMetadata(logger *zap.Logger) (NodeMetadata, error) <span class="cov8" title="1">{
        config, err := rest.InClusterConfig()
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        // creates the clientset
        <span class="cov0" title="0">clientset, err := kubernetes.NewForConfig(config)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">node, err := clientset.CoreV1().Nodes().Get(context.Background(), nodeManager.NodeName, metav1.GetOptions{})
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">nodeLabels := node.ObjectMeta.Labels
        if len(nodeLabels[NodeRegionLabel]) == 0 || len(nodeLabels[NodeZoneLabel]) == 0 </span><span class="cov0" title="0">{
                errorMsg := fmt.Errorf("One or few required node label(s) is/are missing [%s, %s]. Node Labels Found = [#%v]", NodeRegionLabel, NodeZoneLabel, nodeLabels) //nolint:golint
                return nil, errorMsg
        }</span>

        <span class="cov0" title="0">var workerID string
        // If the cluster is satellite, the machine-type label equals to UPI
        if nodeLabels[MachineTypeLabel] == UPI </span><span class="cov0" title="0">{
                // For a satellite cluster, workerID is fetched from vpc-instance-id node label, which is updated by the vpc-node-label-updater (init container)
                workerID = nodeLabels[NodeInstanceIDLabel]
        }</span> else<span class="cov0" title="0"> {
                // For managed and IPI cluster, workerID is fetched from the ProviderID in node spec.
                workerID = fetchInstanceID(node.Spec.ProviderID)
                if workerID == "" </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("Unable to fetch instance ID from node provider ID - %s", node.Spec.ProviderID)
                }</span>
        }

        <span class="cov0" title="0">return &amp;nodeMetadataManager{
                zone:     nodeLabels[NodeZoneLabel],
                region:   nodeLabels[NodeRegionLabel],
                workerID: workerID,
        }, nil</span>
}

func (manager *nodeMetadataManager) GetZone() string <span class="cov8" title="1">{
        return manager.zone
}</span>

func (manager *nodeMetadataManager) GetRegion() string <span class="cov8" title="1">{
        return manager.region
}</span>

func (manager *nodeMetadataManager) GetWorkerID() string <span class="cov8" title="1">{
        return manager.workerID
}</span>

// fetchInstanceID fetches instance ID from the provider ID in node spec.
func fetchInstanceID(providerID string) string <span class="cov0" title="0">{
        s := strings.Split(providerID, "/")
        if len(s) != 7 </span><span class="cov0" title="0">{
                return ""
        }</span>

        <span class="cov0" title="0">return s[6]</span>
}
</pre>
		
		<pre class="file" id="file59" style="display: none">/**
 * Copyright 2025 IBM Corp.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// Package watcher ...
package watcher

import (
        "flag"
        "os"
        "strings"
        "time"

        uid "github.com/gofrs/uuid"
        "go.uber.org/zap/zapcore"

        "github.com/golang/glog"

        iks_vpc_provider "github.com/IBM/ibmcloud-volume-file-vpc/iks/provider"
        cloudprovider "github.com/IBM/ibmcloud-volume-file-vpc/pkg/ibmcloudprovider"
        "github.com/IBM/ibmcloud-volume-interface/config"
        "github.com/IBM/ibmcloud-volume-interface/lib/provider"

        "go.uber.org/zap"
        "golang.org/x/net/context"
        v1 "k8s.io/api/core/v1"
        "k8s.io/apimachinery/pkg/fields"
        "k8s.io/apimachinery/pkg/util/wait"
        "k8s.io/client-go/kubernetes"
        "k8s.io/client-go/kubernetes/scheme"
        v1core "k8s.io/client-go/kubernetes/typed/core/v1"
        "k8s.io/client-go/rest"
        "k8s.io/client-go/tools/cache"
        "k8s.io/client-go/tools/clientcmd"
        "k8s.io/client-go/tools/record"
)

// PVWatcher to watch  pv creation and add taggs
type PVWatcher struct {
        logger          *zap.Logger
        kclient         kubernetes.Interface
        config          *config.Config
        provisionerName string
        recorder        record.EventRecorder
        cloudProvider   cloudprovider.CloudProviderInterface
}

const (
        //IbmCloudGtAPIEndpoint ...
        IbmCloudGtAPIEndpoint = "IBMCLOUD_GT_API_ENDPOINT"
        //ReclaimPolicyTag ...
        ReclaimPolicyTag = "reclaimpolicy:"
        //NameSpaceTag ...
        NameSpaceTag = "namespace:"
        //StorageClassTag ...
        StorageClassTag = "storageclass:"
        //PVCNameTag ...
        PVCNameTag = "pvc:"
        //PVNameTag ...
        PVNameTag = "pv:"
        //VolumeCRN ...
        VolumeCRN = "volumeCRN"
        //ProvisionerTag ...
        ProvisionerTag = "provisioner:"

        //VolumeStatus ...
        VolumeStatus = "status"
        //VolumeStatusCreated ...
        VolumeStatusCreated = "created"
        //VolumeStatusDeleted ...
        VolumeStatusDeleted = "deleted"
        //VolumeUpdateEventReason ...
        VolumeUpdateEventReason = "VolumeMetaDataSaved"
        //VolumeUpdateEventSuccess ...
        VolumeUpdateEventSuccess = "Success"

        // VolumeIDLabel ...
        VolumeIDLabel = "volumeId"

        // VolumeCRNLabel ...
        VolumeCRNLabel = "volumeCRN"

        // ClusterIDLabel ...
        ClusterIDLabel = "clusterID"

        // IOPSLabel ...
        IOPSLabel = "iops"

        // ZoneLabel ...
        ZoneLabel = "zone"

        // GiB in bytes
        GiB = 1024 * 1024 * 1024
)

// VolumeTypeMap ...
var VolumeTypeMap = map[string]string{}

var master = flag.String(
        "master",
        "",
        "Master URL to build a client config from. Either this or kubeconfig needs to be set if the provisioner is being run out of cluster.",
)
var kubeconfig = flag.String(
        "kubeconfig",
        "",
        "Absolute path to the kubeconfig file. Either this or master needs to be set if the provisioner is being run out of cluster.",
)

// New creates the Watcher instance
func New(logger *zap.Logger, provisionerName string, volumeType string, cloudProvider cloudprovider.CloudProviderInterface) *PVWatcher <span class="cov0" title="0">{
        var restConfig *rest.Config
        var err error
        // Register provider
        VolumeTypeMap[provisionerName] = volumeType

        restConfig, err = clientcmd.BuildConfigFromFlags(*master, *kubeconfig)
        if err != nil </span><span class="cov0" title="0">{
                logger.Fatal("Failed to create config:", zap.Error(err))
        }</span>

        <span class="cov0" title="0">clientset, err := kubernetes.NewForConfig(restConfig)
        if err != nil </span><span class="cov0" title="0">{
                logger.Fatal("Failed to create client:", zap.Error(err))
        }</span>
        <span class="cov0" title="0">iksPodName := os.Getenv("POD_NAME")

        broadcaster := record.NewBroadcaster()
        broadcaster.StartLogging(glog.Infof)
        eventInterface := clientset.CoreV1().Events("")
        broadcaster.StartRecordingToSink(&amp;v1core.EventSinkImpl{Interface: eventInterface})
        pvw := &amp;PVWatcher{
                logger:          logger,
                config:          cloudProvider.GetConfig(),
                provisionerName: provisionerName,
                kclient:         clientset,
                cloudProvider:   cloudProvider,
                recorder:        broadcaster.NewRecorder(scheme.Scheme, v1.EventSource{Component: iksPodName}),
        }
        return pvw</span>
}

// Start start pv watcher
func (pvw *PVWatcher) Start() <span class="cov0" title="0">{
        watchlist := cache.NewListWatchFromClient(pvw.kclient.CoreV1().RESTClient(), "persistentvolumes", "", fields.Everything())
        _, controller := cache.NewInformer(watchlist, &amp;v1.PersistentVolume{}, time.Second*0,
                cache.FilteringResourceEventHandler{
                        Handler: cache.ResourceEventHandlerFuncs{
                                UpdateFunc: pvw.updateVolume,
                        },
                        FilterFunc: pvw.filter,
                },
        )
        pvw.logger.Info("PVWatcher starting")
        stopch := wait.NeverStop
        go controller.Run(stopch)
        pvw.logger.Info("PVWatcher started")
        &lt;-stopch
}</span>

func (pvw *PVWatcher) updateVolume(oldobj, obj interface{}) <span class="cov8" title="1">{
        // Run as non-blocking thread to allow parallel processing of volumes
        go func() </span><span class="cov0" title="0">{
                var oldStatus v1.PersistentVolumePhase
                var newStatus v1.PersistentVolumePhase
                ctxLogger, requestID := GetContextLogger(context.Background(), false)
                // panic-recovery function that avoid watcher thread to stop because of unexexpected error
                defer func() </span><span class="cov0" title="0">{
                        if r := recover(); r != nil </span><span class="cov0" title="0">{
                                ctxLogger.Error("Recovered from panic in pvwatcher", zap.Stack("stack"), zap.String("requestID", requestID))
                        }</span>
                }()

                <span class="cov0" title="0">ctxLogger.Info("Entry updateVolume()", zap.Reflect("obj", obj), zap.Reflect("oldobj", oldobj))
                newpv, _ := obj.(*v1.PersistentVolume)
                //If there is no change to status , capacity or iops we can skip the updateVolume call.
                if oldobj != nil </span><span class="cov0" title="0">{
                        oldpv, _ := oldobj.(*v1.PersistentVolume)
                        oldCapacity := oldpv.Spec.Capacity[v1.ResourceStorage]
                        capacity := newpv.Spec.Capacity[v1.ResourceStorage]
                        iops := newpv.Spec.CSI.VolumeAttributes[IOPSLabel]
                        oldiops := oldpv.Spec.CSI.VolumeAttributes[IOPSLabel]
                        newStatus = newpv.Status.Phase
                        oldStatus = oldpv.Status.Phase
                        if (newStatus == oldStatus) &amp;&amp; (oldCapacity.Value() == capacity.Value()) &amp;&amp; (oldiops == iops) </span><span class="cov0" title="0">{
                                ctxLogger.Info("Skipping update Volume as there is no change in status , capacity and iops")
                                return
                        }</span>
                }

                <span class="cov0" title="0">session, err := pvw.cloudProvider.GetProviderSession(context.Background(), ctxLogger)
                if session != nil </span><span class="cov0" title="0">{
                        iksVpc, ok := session.(*iks_vpc_provider.IksVpcSession)

                        if !ok </span><span class="cov0" title="0">{
                                ctxLogger.Error("Failed to get the IKS-VPC session, Try to restart the CSI driver controller POD")
                                return
                        }</span>

                        <span class="cov0" title="0">volume := pvw.getVolumeFromPV(newpv, ctxLogger)
                        // Updating metadata for the volume
                        ctxLogger.Info("Updating metadata for the volume", zap.Reflect("volume", volume))
                        err := iksVpc.UpdateVolume(volume)
                        if err != nil </span><span class="cov0" title="0">{
                                ctxLogger.Warn("Failed to update volume metadata", zap.Error(err))
                                pvw.recorder.Event(newpv, v1.EventTypeWarning, VolumeUpdateEventReason, err.Error())
                        }</span>

                        //Lets invoke the VPC IaaS update Volume only if there is status change and new status is bound state.
                        //This will be true only when PVC is first time created
                        <span class="cov0" title="0">if newStatus != oldStatus &amp;&amp; newStatus == v1.VolumeBound </span><span class="cov0" title="0">{
                                ctxLogger.Info("Updating tags from VPC IaaS")
                                err = iksVpc.VPCSession.UpdateVolume(volume)
                                if err != nil </span><span class="cov0" title="0">{
                                        ctxLogger.Warn("Failed to update volume with tags from VPC IaaS", zap.Error(err))
                                        pvw.recorder.Event(newpv, v1.EventTypeWarning, VolumeUpdateEventReason, err.Error())
                                }</span> else<span class="cov0" title="0"> {
                                        pvw.recorder.Event(newpv, v1.EventTypeNormal, VolumeUpdateEventReason, VolumeUpdateEventSuccess)
                                        ctxLogger.Warn("Volume Metadata saved successfully")
                                }</span>
                        } else<span class="cov0" title="0"> {
                                ctxLogger.Info("Skipping Updating tags from VPC IaaS as there is no change in tags")
                        }</span>
                }
                <span class="cov0" title="0">ctxLogger.Info("Exit updateVolume()", zap.Error(err))</span>
        }()
}

func (pvw *PVWatcher) getTags(pv *v1.PersistentVolume, ctxLogger *zap.Logger) (string, []string) <span class="cov8" title="1">{
        ctxLogger.Debug("Entry getTags()", zap.Reflect("pv", pv))
        volAttributes := pv.Spec.CSI.VolumeAttributes
        // Get user tag list
        tagstr := strings.TrimSpace(volAttributes["tags"])
        var tags []string
        if len(tagstr) &gt; 0 </span><span class="cov8" title="1">{
                tags = strings.Split(tagstr, ",")
        }</span>
        // append default tags to users tag list
        <span class="cov8" title="1">tags = append(tags, ClusterIDLabel+":"+volAttributes[ClusterIDLabel])
        tags = append(tags, ReclaimPolicyTag+string(pv.Spec.PersistentVolumeReclaimPolicy))
        tags = append(tags, StorageClassTag+pv.Spec.StorageClassName)
        tags = append(tags, NameSpaceTag+pv.Spec.ClaimRef.Namespace)
        tags = append(tags, PVCNameTag+pv.Spec.ClaimRef.Name)
        tags = append(tags, PVNameTag+pv.ObjectMeta.Name)
        tags = append(tags, ProvisionerTag+pvw.provisionerName)
        ctxLogger.Debug("Exit getTags()", zap.String("VolumeCRN", volAttributes[VolumeCRN]), zap.Reflect("tags", tags))
        return volAttributes[VolumeCRN], tags</span>
}

func (pvw *PVWatcher) getVolumeFromPV(pv *v1.PersistentVolume, ctxLogger *zap.Logger) provider.Volume <span class="cov8" title="1">{
        ctxLogger.Debug("Entry getVolume()", zap.Reflect("pv", pv))
        crn, tags := pvw.getTags(pv, ctxLogger)
        volume := provider.Volume{
                VolumeID:   pv.Spec.CSI.VolumeHandle,
                Provider:   provider.VolumeProvider(pvw.config.VPC.VPCBlockProviderType),
                VolumeType: provider.VolumeType(VolumeTypeMap[pv.Spec.CSI.Driver]),
        }
        volume.CRN = crn
        clusterID := pv.Spec.CSI.VolumeAttributes[ClusterIDLabel]
        volume.Attributes = map[string]string{strings.ToLower(ClusterIDLabel): clusterID}
        if pv.Status.Phase == v1.VolumeReleased </span><span class="cov0" title="0">{
                // Set only status in case of delete operation
                volume.Attributes[VolumeStatus] = VolumeStatusDeleted
        }</span> else<span class="cov8" title="1"> {
                volume.Tags = tags
                //Get Capacity and convert to GiB
                capacity := pv.Spec.Capacity[v1.ResourceStorage]
                capacityGiB := BytesToGiB(capacity.Value())
                volume.Capacity = &amp;capacityGiB
                iops := pv.Spec.CSI.VolumeAttributes[IOPSLabel]
                volume.Iops = &amp;iops
                volume.Attributes[VolumeStatus] = VolumeStatusCreated
        }</span>
        <span class="cov8" title="1">ctxLogger.Debug("Exit getVolume()", zap.Reflect("volume", volume))
        return volume</span>
}

func (pvw *PVWatcher) filter(obj interface{}) bool <span class="cov0" title="0">{
        pvw.logger.Debug("Entry filter()", zap.Reflect("obj", obj))
        pv, _ := obj.(*v1.PersistentVolume)
        var provisoinerMatch = false
        if pv != nil &amp;&amp; pv.Spec.CSI != nil </span><span class="cov0" title="0">{
                provisoinerMatch = pv.Spec.CSI.Driver == pvw.provisionerName
        }</span>
        <span class="cov0" title="0">pvw.logger.Debug("Exit filter()", zap.Bool("provisoinerMatch", provisoinerMatch))
        return provisoinerMatch</span>
}

// BytesToGiB converts Bytes to GiB
func BytesToGiB(volumeSizeBytes int64) int <span class="cov8" title="1">{
        return int(volumeSizeBytes / GiB)
}</span>

// GetContextLogger ...
func GetContextLogger(ctx context.Context, isDebug bool) (*zap.Logger, string) <span class="cov0" title="0">{
        return GetContextLoggerWithRequestID(ctx, isDebug, nil)
}</span>

// GetContextLoggerWithRequestID  adds existing requestID in the logger
// The Existing requestID might be coming from ControllerPublishVolume etc
func GetContextLoggerWithRequestID(ctx context.Context, isDebug bool, requestIDIn *string) (*zap.Logger, string) <span class="cov0" title="0">{
        consoleDebugging := zapcore.Lock(os.Stdout)
        consoleErrors := zapcore.Lock(os.Stderr)
        encoderConfig := zap.NewProductionEncoderConfig()
        encoderConfig.TimeKey = "ts"
        encoderConfig.EncodeTime = zapcore.ISO8601TimeEncoder
        traceLevel := zap.NewAtomicLevel()
        if isDebug </span><span class="cov0" title="0">{
                traceLevel.SetLevel(zap.DebugLevel)
        }</span> else<span class="cov0" title="0"> {
                traceLevel.SetLevel(zap.InfoLevel)
        }</span>

        <span class="cov0" title="0">core := zapcore.NewTee(
                zapcore.NewCore(zapcore.NewJSONEncoder(encoderConfig), consoleDebugging, zap.LevelEnablerFunc(func(lvl zapcore.Level) bool </span><span class="cov0" title="0">{
                        return (lvl &gt;= traceLevel.Level()) &amp;&amp; (lvl &lt; zapcore.ErrorLevel)
                }</span>)),
                zapcore.NewCore(zapcore.NewJSONEncoder(encoderConfig), consoleErrors, zap.LevelEnablerFunc(func(lvl zapcore.Level) bool <span class="cov0" title="0">{
                        return lvl &gt;= zapcore.ErrorLevel
                }</span>)),
        )
        <span class="cov0" title="0">logger := zap.New(core, zap.AddCaller())
        // generating a unique request ID so that logs can be filter
        if requestIDIn == nil </span><span class="cov0" title="0">{
                // Generate New RequestID if not provided
                uuid, _ := uid.NewV4() // #nosec G104: Attempt to randomly generate uuid
                requestID := uuid.String()
                requestIDIn = &amp;requestID
        }</span>
        <span class="cov0" title="0">logger = logger.With(zap.String("RequestID", *requestIDIn))
        return logger, *requestIDIn + " "</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
